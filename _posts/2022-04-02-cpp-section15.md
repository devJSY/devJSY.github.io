---
published: true
title:  "ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 15. ì˜ë¯¸ë¡ ì  ì´ë™ê³¼ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°"
excerpt: ""

categories:
  - ë”°ë°°ì”¨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-01
last_modified_at: 2022-05-03
---

# ğŸ¤” í•™ìŠµëª©í‘œ
- ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 15. ì˜ë¯¸ë¡ ì  ì´ë™ê³¼ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°

# ğŸ“ƒ í•™ìŠµë‚´ìš©
## ğŸ“ **ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 15. ì˜ë¯¸ë¡ ì  ì´ë™ê³¼ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**

### **ğŸŒ± 15.1 ì´ë™ì˜ ì˜ë¯¸ì™€ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**

- move semantics
- Smart pointers

```cpp
#include <iostream>

using namespace std;

class Resource
{
public:
	int m_data[100];

public:
	Resource()
	{
		cout << "Resource constructed" << endl;
	}

	~Resource()
	{
		cout << "Resource destroyed" << endl;
	}
};

void doSomething()
{
	try
	{
		Resource* res = new Resource;

		if (true)
		{
			throw - 1; // exception
		}
		delete res;
	}
	catch (...)
	{
	}
	return;
}

int main()
{
	doSomething();
}
```

- new í•œê³³ì—ì„œ delete í•´ì£¼ëŠ”ê²ƒì„ RAII ë¼ê³ í•¨
  - RAII: resource acquisition is initialization
- early return
  - deleteí•˜ê¸°ì „ íŠ¹ì •ì¡°ê±´ì´ ì¶©ì¡±ë˜ì–´ returní•´ë²„ë¦¬ëŠ”ê²ƒ
  - ì „í†µì ì¸ c++ì—ì„  ì´ëŸ°ì‹ìœ¼ë¡œ í•´ì£¼ë„ë¡ ë˜ì–´ìˆì—ˆìŒ

___


**std::auto_ptr<int>;** 

- c++ 98 ë§Œë“¤ì–´ì§ c++ 11ë•Œ ì‚¬ìš©í•˜ì§€ ì•Šê¸°ë¡œí–ˆê³  c++ 17ë•Œ ì‚­ì œê°€ë¨ 
- ë³µì¡í•œê²½ìš° ì‘ë™í•˜ì§€ ì•ŠëŠ”ê²½ìš°ê°€ ìˆì—ˆìŒ
- ìŠ¤ë§ˆíŠ¸í¬ì¸í„°ë¡œ ë„˜ì–´ê°€ê²Œë¨
- ì†Œë©¸ìì—ì„œ ë³€ìˆ˜ê°€ nullptrì´ ì•„ë‹ˆë©´ ì§€ìš°ëŠ” ê¸°ëŠ¥ì„
- í´ë˜ìŠ¤ë‹¨ìœ„ë¡œ ë¬¶ìœ¼ë©´ 

```cpp
class Resource
{
public:
	int m_data[100];

public:
	Resource()
	{
		cout << "Resource constructed" << endl;
	}

	~Resource()
	{
		cout << "Resource destroyed" << endl;
	}
};

template<typename T>
class AutoPtr
{
public:
	T* m_ptr = nullptr;

public:
	AutoPtr(T* ptr = nullptr)
		:m_ptr(ptr) {}
	~AutoPtr() 
	{
		if (m_ptr != nullptr) delete m_ptr; 
	}
	T& operator *() const { return *m_ptr; }  
	T* operator ->() const { return m_ptr; } 
	bool inNull() const { return m_ptr == nullptr; }
};
```

```cpp
void doSomething()
{
	try 
	{
		AutoPtr<Resource> res = new Resource;  
		if (true)
		{
			throw - 1; 
		}		

	}
	catch (...)
	{
	}
	return;		
}

int main()
{
	doSomething();
}
```

- **dull pointer:** ë™ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹ë°›ê³ ìˆì§€ë§Œ ìê¸°ê°€ëê¹Œì§€ ì±…ì„ì„ ì•ˆì§€ê³  ìˆ˜ë™ìœ¼ë¡œí•´ì¤˜ì•¼í•˜ëŠ” í¬ì¸í„°
- **smart pointer:** `AutoPtr<Resource> res = new Resource;` 
  - ê°ì²´ res ê°€ ì†Œë©¸ë  ë•Œ AutoPtr í´ë˜ìŠ¤ì˜ ì†Œë©¸ìì—ì„œ ì•Œì•„ì„œ delete í•´ì¤Œ
  - `AutoPtr<Resource> res(new Resource);` ì´ˆê¸°í™” í•´ì£¼ëŠ”ê²ƒì´ê¸° ë•Œë¬¸ì— ì´ë ‡ê²Œ í•´ì£¼ëŠ” ê²ƒì´ ì¢‹ìŒ

___

**ë¬¸ì œ ë°œìƒ ì½”ë“œ**

```cpp
int main()
{
	{]
    // int i; int *ptr(&i); int *ptr2 = nullptr; ê³¼ ê°™ì€ í˜•íƒœ
		AutoPtr<Resource> res1(new Resource); // ì´ˆê¸°í™” ëœ ìƒíƒœ
		AutoPtr<Resource> res2; // ì´ˆê¸°í™”ì•ˆë¨ nullptr

		cout << res1.m_ptr << endl; 
		cout << res2.m_ptr << endl; 

		res2 = res1;	// ë¬¸ì œ ë°œìƒ ë¶€ë¶„

		cout << res1.m_ptr << endl;  
		cout << res2.m_ptr << endl;  
	}
}
```

```cpp
ì¶œë ¥ ê²°ê³¼
Resource constructed
0014FFA8
00000000
0014FFA8
0014FFA8
Resource destroyed
Resource destroyed
```

- ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒë¨
  - ì´ë¯¸ ì§€ì›Œì§„ ê°ì²´ë¥¼ ë˜ ì§€ìš°ë ¤í•˜ì—¬ ì—ëŸ¬ ë°œìƒ
- `res2 = res1;` ë‚´ë¶€ì ìœ¼ë¡œ AutoPtrì•ˆì— ìˆëŠ” ë©¤ë²„ë¥¼ ë³µì‚¬í•´ì¤Œ
- `new Resource` ì— ëŒ€í•œ ì†Œìœ ê¶Œì„ `res2 = res1;` í•˜ê²Œë˜ëŠ” ìˆœê°„ res1ì˜ ì†Œìœ ê¶Œì„ res2 ì— ë„˜ê²¨ì£¼ê²Œ ë˜ì–´ ë‘ë³€ìˆ˜ê°€ ëª¨ë‘ ì†Œìœ ê¶Œì„ ê°–ê²Œë˜ì–´ ë¬¸ì œê°€ë¨


**í•´ê²° ë°©ë²•**

```cpp
#include <iostream>
using namespace std;

template<typename T>
class AutoPtr
{
public:
	T* m_ptr= nullptr;

public:
	AutoPtr(T* ptr = nullptr)
		:m_ptr(ptr) {}
	~AutoPtr()
	{
		if(m_ptr != nullptr) delete m_ptr;
	}

	AutoPtr(AutoPtr& a)  // ë³µì‚¬ ìƒì„±ì
	{
		m_ptr = a.m_ptr;
		a.m_ptr = nullptr;  // ì†Œìœ ê¶Œ ë°•íƒˆ
	}

	AutoPtr& operator = (AutoPtr& a)  // ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
	{
		if (&a == this)  
			return *this;
		
		delete m_ptr;   
		m_ptr = a.m_ptr; 
		a.m_ptr = nullptr;   
		return *this;
	}

	T& operator *() const { return *m_ptr; }
	T* operator ->() const { return m_ptr; }
	bool inNull() const { return m_ptr == nullptr; }
};
```
```cpp
ì¶œë ¥ê²°ê³¼
Resource constructed
000001F0E8063820
0000000000000000
0000000000000000
000001F0E8063820
Resource destroyed // res2.m_ptr ì˜ ì†Œë©¸ìì—ì„œ ì‹¤í–‰ì‹œí‚´
```

- ë³µì‚¬ ìƒì„±ìì—ì„œ íŒŒë¼ë©”íƒ€ì˜ ptrë¥¼ ë³µì‚¬í•´ì„œ m_ptrì— ë„£ê³  íŒŒë¼ë©”íƒ€ì˜ nullptrì„ ë„£ì–´ ì†Œìœ ê¶Œì„ ë°•íƒˆí•´ì£¼ëŠ” ë°©ì‹

- ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì—ì„œëŠ” ì´ë¯¸ ë‚´ê°€ ê°–ê³  ìˆë˜ê±´ ì§€ì›Œë²„ë¦¬ê³  ìƒˆë¡œ ë“¤ì–´ì˜¨ì–˜ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ë³µì‚¬í•´ì„œ ë°›ê³  ì›ë˜ ë©”ëª¨ë¦¬ ì£¼ì†ŒëŠ” nullptrë¡œ ë°”ê¿”ë²„ë¦¬ë©´ ì†Œìœ ê¶Œì´ ì´ì „ì´ ë¨

- **Move semantics:** ì†Œìœ ê¶Œì„ ì´ì „ ì‹œí‚¤ëŠ” ë°©ì‹

___

**syntax vs semantics**

- syntax
  - ë¬¸ë²•ì— ë§ëƒ ì•ˆë§ëƒ, ì»´íŒŒì¼ì´ ë˜ëƒ ì•ˆë˜ëƒë¥¼ ë³´ëŠ” ê²ƒ
- semantics
  - ì»´íŒŒì¼ì´ ë˜ëŠ”ê±´ ë˜‘ê°™ì€ë° ì‹¤ì§ˆì ìœ¼ë¡œ ë‚´ë¶€ì˜ ì˜ë¯¸ê°€ ë§ëŠ”ì§€ ë³´ëŠ”ê²ƒ

```cpp
int x = 1, y = 1;
x + y;

string str1("Hello"), str2("World");
str1 + str2; // append
```

- ìœ„ `+` ì˜ ê¸°í˜¸ëŠ” ê°™ì§€ë§Œ ì˜ë¯¸ê°€ ë‹¤ë¦„ ì´ë¥¼ semanticsë¼ê³  í•¨

- value semantics (copy semantics)
- reference semantice (pointer)
- move semantics (move)

### **ğŸŒ± 15.2 ì˜¤ë¥¸ìª½-ê°’ ì°¸ì¡°**

- R-value References

```cpp
#include <iostream>
using namespace std;

void doSomething(int& lref) { cout << "L-value ref" << endl; }
void doSomething(int&& rref) { cout << "R-value ref" << endl; }
int getResult() { return 100; }

int main()
{
	int x = 5;             
	int y = getResult();     
	const int cx = 6;          
	const int cy = getResult(); 

	/* L-value references */
	int& lr1 = x;		            
	int& lr2 = cx;		        
	int& lr3 = 10;			      

	const int& lr4 = x;		
	const int& lr5 = cx;
	const int& lr6 = 10;	

	/* R-value references */
	int&& rr1 = x;		
	int&& rr2 = cx;		
	int&& rr3 = 10;		
	int&& rr4 = getResult();
	rr3 = 20;			

	const int&& rr5 = x;	
	const int&& rr6 = cx;
	const int&& rr7 = 10;
	const int&& rr8 = getResult();

	doSomething(x);				/* L-value reference */
	doSomething(10);			/* R-value reference */
	doSomething(getResult());	/* R-value reference */
	doSomething(rr3);			/* L-value reference */
}
```

**variable**
-	`int x = 5;`                     
    - 5ë¼ëŠ” R-valueë¥¼ L-value ì¸ x ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ”ê²ƒ
-	`int y = getResult();`          
    - í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ R-valueë¥¼ L-value ì¸ y ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ”ê²ƒ
-	`const int cx = 6;`             
    - 6ë¼ëŠ” R-valueë¥¼ L-value ì¸ cx const ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ”ê²ƒ
-	`const int cy = getResult();`   
    - í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ R-valueë¥¼ L-value ì¸ cy const ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ”ê²ƒ

**L-value references**

- `int& lr1 = x;`
  - ì»´íŒŒì¼ â­•
  - Modifiable L-vlaue lr1ê³¼ xëŠ” ê°™ì€ ì£¼ì†Œë¥¼ ê°€ì§

- `int& lr2 = cx;`		            
  - ì»´íŒŒì¼ âŒ
  - Non-modifiable L-vlaue lr2ê°€ constê°€ ì•„ë‹ˆë¯€ë¡œ cxë¥¼ ë„£ì„ìˆ˜ ì—†ìŒ

- `int& lr3 = 10;`			  
  - ì»´íŒŒì¼ âŒ         
  -  R-value lr3ê°€ ì´í›„ ì‚¬ìš©ë ë•Œ ìê¸°ê°€ ì°¸ì¡°í•˜ê³ ìˆëŠ” ë³€ìˆ˜ê°€ ë©”ëª¨ë¦¬ë¥¼ ê°–ê³ ìˆë‹¤ëŠ” ì „ì œí•˜ì— ì‘ë™í•˜ê¸°ë•Œë¬¸ì— L-value references ì´ê¸°ë•Œë¬¸ì— R-valueì— ëŒ€í•´ì„œëŠ” referencesë¥¼ ê°€ì§ˆìˆ˜ ì—†ìŒ
  - ê³ ì „ì  C++ ì—ì„  referencesë¥¼ L-value referencesë¥¼ ì˜ë¯¸í•¨

- `const int& lr4 = x;`		
  - ì»´íŒŒì¼ â­•
  - Modifiable L-vlaue lr1ê³¼ xëŠ” ê°™ì€ ì£¼ì†Œë¥¼ ê°€ì§
- `const int& lr5 = cx;`
  - ì»´íŒŒì¼ â­•
  - Non-modifiable L-vlaue lr2ê°€ constê°€ ì•„ë‹ˆë¯€ë¡œ cxë¥¼ ë„£ì„ìˆ˜ ì—†ìŒ
- `const int& lr6 = 10;`	
  - ì»´íŒŒì¼ â­• 
  - R-value ë©”ëª¨ë¦¬ì£¼ì†Œì™€ ìƒê´€ì—†ì´ ì‹¬ë³¼ë¦­ ì»¨ìŠ¤í„´ìŠ¤ì²˜ëŸ¼ë§Œ ì‚¬ìš©í•˜ê² ë‹¤ëŠ” ì˜ë¯¸ë¡œ ê°€ëŠ¥í•¨

**R-value references**

- R-value references ëŠ” `&&` ì„ `&` ì™€ êµ¬ë¶„í•˜ê¸° ìœ„í•¨ì„ 
- ê³§ ì‚¬ë¼ì§ˆ ì–˜ë“¤ë§Œ ë‹´ì„ìˆ˜ ìˆìŒ
- R-value ë ˆí¼ëŸ°ìŠ¤ë¡œ ê°€ë¥´ì¼œì§€ëŠ” ì• ë“¤ì€ moveë¥¼ í•´ì„œ ë‹¤ë¥¸ê³³ìœ¼ë¡œ ì˜®ê²¨ë„ ì–´ì§œí”¼ ì‚¬ë¼ì§ˆ ì• ë“¤ì´ë¼ ì•„ë¬´ë„ ì°¾ì§€ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸
- R-valueê°€ í´ë˜ìŠ¤ì˜ ì˜¤ë¸Œì íŠ¸ë‚˜ ì¸ìŠ¤í„´ìŠ¤ë¼ë©´ valueë¡œ Move semantics ë¥¼ í•´ë²„ë ¤ë„ ë¬¸ì œê°€ ì—†ë‹¤ëŠ” ê²ƒì´ê³  ì‚¬ìš©ì„ í• ìˆ˜ë„ ìˆìŒ

<br>

- `int&& rr1 = x;`		
  - ì»´íŒŒì¼ âŒ
  - Modifiable L-vlaue
- `int&& rr2 = cx;`	
  - ì»´íŒŒì¼ âŒ
  - Non-modifiable L-vlaue
- `int&& rr3 = 10;`		
  - ì»´íŒŒì¼ â­•
  - R-value ë§Œ ë°›ì„ìˆ˜ ìˆìŒ
- `int&& rr4 = getResult();`
  - ì»´íŒŒì¼ â­•
  - ë¦¬í„´ë°›ì€ ì„ì‹œì ì¸ê°’ì„ `rr4`ì— ì €ì¥í•´ë†“ëŠ” ê²ƒ
- `rr3 = 20;`			
  - R-valueì˜ ê°’ì„ ë³€ê²½í• ìˆ˜ ìˆìŒ

<br>

- `const int&& rr5 = x;`	
  - ì»´íŒŒì¼ âŒ
  - Modifiable L-vlaue
- `const int&& rr6 = cx;`
  - ì»´íŒŒì¼ âŒ
  - Non-modifiable L-vlaue
- `const int&& rr7 = 10;`
  - ì»´íŒŒì¼ â­•
- `const int&& rr8 = getResult();`
  - ì»´íŒŒì¼ â­•

___

```cpp
void doSomething(int& lref) { cout << "L-value ref" << endl; }
void doSomething(int&& rref) { cout << "R-value ref" << endl; }
int getResult() { return 100; }
```
- ì»´íŒŒì¼ëŸ¬ê°€ íŒŒë¼ë©”íƒ€ê°€ L-value, R-value ë ˆí¼ëŸ°ìŠ¤ì¸ê²ƒì€ ë‹¤ë¥´ê²Œ ê¸°ëŠ¥ì„ í• ìˆ˜ ìˆë„ë¡ ì˜¤ë²„ë¡œë”©ì„ ì¸ì •í•´ì¤Œ

<br>

- `doSomething(x);`			
  - L-value reference 
- `doSomething(10);`			
  - R-value reference 
- `doSomething(getResult());`	
  - R-value reference 
- `doSomething(rr3);`		
  - L-value reference

<br>

- R-Value referenceë¡œ ë°›ì•„ì˜¨ ê²½ìš°ì—ëŠ” íŒŒë¼ë©”íƒ€ê°€ ì–´ì§œí”¼ ë‹¤ë¥¸ë°ì„œ ì“¸ì¼ì´ ì—†ê¸°ë•Œë¬¸ì— Move Semanticë¥¼ ì‚¬ìš©í• ìˆ˜ ìˆìŒ
- L-Value reference ë¥¼ ì‚¬ìš©í•  ê²½ìš°ì—ëŠ” íŒŒë¼ë©”íƒ€ê°€ ë©”ëª¨ë¦¬ë¥¼ ê°–ê³ ìˆëŠ” ë³€ìˆ˜ê³  ê·¸ ë³€ìˆ˜ëŠ” dosomethingí•¨ìˆ˜ ë°–ì—ì„œë„ ì‚¬ìš©ì„ í•´ì•¼í•˜ë‹ˆê¹Œ moveSemanticë¡œ ê°€ì ¸ì™€ë²„ë¦¬ë©´ ë¬¸ì œê°€ ìƒê¸¸ìˆ˜ ìˆìœ¼ë¯€ë¡œ Move Semanticë¥¼ ì‚¬ìš©í• ìˆ˜ ì—†ìŒ

### **ğŸŒ± 15.3 ì´ë™ ìƒì„±ìì™€ ì´ë™ ëŒ€ì…**

- Move constructors
- Move assignment 

- Deep copy ê°€ ì‹¤í–‰ë˜ê³  ì•ˆë˜ê³  ì°¨ì´ë¡œ ìˆ˜í–‰ì‹œê°„ì°¨ì´ê°€ ë§ì´ë°œìƒí•¨
- `cout.rdbuf(NULL)`  
  - disconnect cout from buffer
- `Deep copy` ëŒ€ì‹  R-valueë¡œ ë°›ì•„ì„œ shallow copy 
- R-valueì€ ì–´ì§œí”¼ ì‚¬ë¼ì§€ì§€ë§Œ nullptrì„ ë„£ì–´ì£¼ëŠ”ê²Œ ì¢‹ìŒ

**Resource.h**

```cpp
#include <iostream>
using namespace std;

class Resource
{
public:
	int * m_data = nullptr;
	unsigned m_length = 0;

public:
	Resource() // ê¸°ë³¸ ìƒì„±ì
	{
		cout << "Resource constructed" << endl;
	}

	Resource(unsigned length)
	{
		cout << "Resource length constructed" << endl;
		this->m_data = new int[length];
		this->m_length = length;
	}

	Resource(const Resource &res) // ë³µì‚¬ ìƒì„±ì
	{
		cout << "Resource copy constructed" << endl;
		
		Resource(res.m_length);

		for (unsigned i = 0; i < m_length; ++i)  // Deep copy
			m_data[i] = res.m_data[i];
	}
 
	~Resource()  // ì†Œë©¸ì
	{
		cout << "Resource destroyed" << endl;
	}

	Resource & operator = (Resource & res)  // ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
	{
		cout << "Resource copy assignment" << endl;

		if (&res == this) return *this; 
		if (this->m_data != nullptr) delete[] m_data; 
		m_length = res.m_length; 
		
		m_data = new int[m_length];

		for (unsigned i = 0; i < m_length; ++i) 
			m_data[i] = res.m_data[i]; 

		return *this;
	}   
};
```

**AutoPtr.h**

```cpp
template<typename T>
class AutoPtr
{
public:
	T* m_ptr;

public:
	AutoPtr(T* ptr = nullptr)
		:m_ptr(ptr) 
	{
		cout << "AutoPtr default constructor" << endl;
	}
	~AutoPtr()
	{
		cout << "AutoPtr destructor" << endl;

		if (m_ptr != nullptr) delete m_ptr;
	}

	AutoPtr(AutoPtr && a)  // ì´ë™ìƒì„±ì
		:  m_ptr(a.m_ptr) // ì–•ì€ ë³µì‚¬ 
	{ 
		cout << "AutoPtr move constructor" << endl;

		a.m_ptr = nullptr; // really necessary?
	}

	AutoPtr& operator = (AutoPtr && a)  // *ì´ë™ ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
	{
		cout << "AutoPtr move assignment" << endl;

		if (&a == this)
			return *this;

		if (m_ptr != nullptr) delete m_ptr; 
		
		m_ptr = a.m_ptr; 
		a.m_ptr = nullptr;
		return *this;
	}
	T& operator *() const { return *m_ptr; }
	T* operator ->() const { return m_ptr; }
	bool inNull() const { return m_ptr == nullptr; }
};
```

**main.cpp**

```cpp
#include <iostream>
#include "AutoPtr.h"
#include "Resource.h"
#include "Timer.h"

AutoPtr<Resource> generateResource()  
{
	AutoPtr<Resource> res(new Resource(10000000));

	return res;
}

int main()
{
	using namespace std;
	streambuf * orig_buf = cout.rdbuf();
	// cout.rdbuf(NULL);

	Timer timer;
	{
		AutoPtr<Resource> main_res;
		main_res = generateResource(); 
	}
		cout.rdbuf(orig_buf);
		cout << timer.elapsed() << endl; 
}
```

### **ğŸŒ± 15.4 std::move**

- copy constructor, copy assignment ë¥¼ ê°•ì œë¡œ ì‚¬ìš©ì•ˆí•˜ëŠ” ë°©ë²•
  - `AuroPtr(const AutoPtr& a) = delete;`
  - `AutoPtr& operator=(const AutoPtr& a) = delete;`

**AutoPtr.h**

```cpp
#include <iostream>
using namespace std;

template<typename T>
class AutoPtr
{
public:
	T* m_ptr;

public:
	AutoPtr(T* ptr = nullptr)
		:m_ptr(ptr) 
	{
		cout << "AutoPtr default constructor" << endl;
	}

	~AutoPtr()
	{
		cout << "AutoPtr destructor" << endl;

		if (m_ptr != nullptr) delete m_ptr;
	}

	AutoPtr(const AutoPtr& a) // ë³µì‚¬ ìƒì„±ì
	{
		cout << "AutoPtr copy constructor" << endl;

		// deep copy
		m_ptr = new T;  
		*m_ptr = *a.m_ptr;
	}

	AutoPtr& operator = (const AutoPtr& a) // ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
	{
		cout << "AutoPtr copy assignment" << endl;
		
		if (&a == this)
			return *this;

		if (m_ptr != nullptr) delete m_ptr;

		// deep copy
		m_ptr = new T;  
		*m_ptr = *a.m_ptr; 

		return *this;
	}
	//AutoPtr(const AutoPtr& a) = delete;
	//AutoPtr& operator = (**const** AutoPtr& a) = delete;  

	AutoPtr(AutoPtr&& a)  // ì´ë™ìƒì„±ì
		:  m_ptr(a.m_ptr)
	{ 
		a.m_ptr = nullptr;
	
		cout << "AutoPtr move constructor" << endl;
	}

	AutoPtr& operator = (AutoPtr&& a)  // ì´ë™ ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”© 
	{
		cout << "AutoPtr move assignment" << endl;

		if (&a == this)
			return *this;

		if (m_ptr != nullptr) delete m_ptr; 
		
		m_ptr = a.m_ptr;  
		a.m_ptr = nullptr; 

		return *this;
	}

	T& operator *() const { return *m_ptr; }
	T* operator ->() const { return m_ptr; }
	bool inNull() const { return m_ptr == nullptr; }
};
```

**main.cpp**

```cpp
#include <iostream>

int main()
{
	{
		AutoPtr<Resource> res1(new Resource(10000000));

		cout << res1.m_ptr << endl;

		AutoPtr<Resource> res2 = res1;

		cout << res1.m_ptr << endl;
		cout << res2.m_ptr << endl;
	}
}
```

___

**std::move();**

**main.cpp**

```cpp
#include <iostream>
#include <utility> // std::move();

int main()
{
	{
		AutoPtr<Resource> res1(new Resource(10000000));

		cout << res1.m_ptr << endl;

		AutoPtr<Resource> res2 = std::move(res1); 

		cout << res1.m_ptr << endl;
		cout << res2.m_ptr << endl;
	}
}
```

- `std::move();`
  - `()` ì•ˆì— ë“¤ì–´ì˜¤ëŠ”ê²ƒì„ R-valueë¡œ ë¦¬í„´í•´ì¤Œ

- classì—ì„œ moveë“± ëŒ€ì‘í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•´ì•¼ ì‚¬ìš©í• ìˆ˜ìˆìŒ

___

- í•­ìƒ move ì—°ì‚°ì´ ë³µì‚¬ë³´ë‹¤ ë” ë¹ ë¥¸ ê²ƒì€ ì•„ë‹˜
- std::stringì—ì„œëŠ” move ì—°ì‚°ì„ ì•ˆì“°ëŠ” ê²ƒì´ ë” ë‚«ë‹¤.
- std::stringëŠ” moveë¥¼ ì§€ì›í•˜ê¸´ í•˜ëŠ”ë° ë¬¸ìì—´ ê¸¸ì´ê°€ ì§§ì€ ê²½ìš°ì—” moveì—°ì‚°ë³´ë‹¤ ë³µì‚¬ê°€ ë” ì„±ëŠ¥ì´ ë‚«ë‹¤ê³  í•¨

### **ğŸŒ± 15.5 std::unique_ptr**

- `std::unique_ptr`
  - ì†Œìœ ê¶Œì„ í•œêµ°ë°ì—ì„œë§Œ ë°›ì„ìˆ˜ ìˆìŒ
  
```cpp
#include <iostream>
#include <memory>  
using namespace std;

class Resource
{
public:
	int* m_data = nullptr;
	unsigned m_length = 0;

public:
	Resource()
	{
		cout << "Resource constructed" << endl;
	}

	Resource(unsigned length)
	{
		cout << "Resource length constructed" << endl;
		this->m_data = new int[length];
		this->m_length = length;
	}

	Resource(const Resource& res) // ë³µì‚¬ ìƒì„±ì 
	{
		cout << "Resource copy constructed" << endl;

		Resource(res.m_length);

		for (unsigned i = 0; i < m_length; ++i)  // ê¹Šì€ ë³µì‚¬
			m_data[i] = res.m_data[i];
	}

	~Resource()  // ì†Œë©¸ì
	{
		cout << "Resource destroyed" << endl;
	}

	Resource& operator = (Resource& res)  // ëŒ€ì… ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
	{
		cout << "Resource copy assignment" << endl;

		if (&res == this) return *this;

		if (this->m_data != nullptr) delete[] m_data;

		m_length = res.m_length;

		m_data = new int[m_length];
		for (unsigned i = 0; i < m_length; ++i)
			m_data[i] = res.m_data[i]; //  ê¹Šì€ ë³µì‚¬

		return *this;
	}

	void print()  
	{
		for (unsigned i = 0; i < m_length; ++i)
			std::cout << m_data[i] << " ";
		std::cout << std::endl;
	}

	void setAll(const int& v) 
	{
		for (unsigned i = 0; i < m_length; ++i)
			m_data[i] = v;
	}
};

int main()
{
	{
		std::unique_ptr<int> upi(new int); 

		auto* ptr = new Resource(5);
		std::unique_ptr<Resource> res1(ptr); 

		res1->setAll(5); 
		res1->print(); 
	}
}
```

- `#include <memory>` ì— ë“¤ì–´ìˆìŒ  
- `std::unique_ptr<Resource> res (new Resource(10000000));` ì´ë ‡ê²Œì‚¬ìš©í• ìˆ˜ìˆìŒ
- **ìŠ¤ë§ˆíŠ¸í¬ì¸í„°:** í¬ì¸í„°ê°€ ì°¸ì¡°í•˜ê³  ìˆëŠ” ë™ì  ë©”ëª¨ë¦¬ë¥¼ ìë™ìœ¼ë¡œ delete ì‹œì¼œì¤€ë‹¤. scopeë¥¼ ë²—ì–´ë‚˜ë©´ ì•Œì•„ì„œ ì†Œë©¸ìë¥¼ í˜¸ì¶œí•´ì¤Œ

___

**make_unique**

```cpp
int main()
{
	auto res1 = std::make_unique<Resource>(5);
	std::unique_ptr<Resource> res1 = std::make_unique<Resource>(5);
	auto res2 = doSomething();
}
```

```cpp
auto doSomething()
{
	auto res1 = std::make_unique<Resource>(5);
	return res1; // 1

	return std::unique_ptr<Resource>(new Resource(5)); // 2

	return std::make_unique<Resource>(5); // 3
}

```

- `std::unique_ptr<Resource> res1 = std::make_unique<Resource>(5);` ì´ ê¸°ë³¸ ë¬¸ë²•ì´ê³  ë³´í†µì€ `auto res1 = std::make_unique<Resource>(5);` ë¥¼ ì‚¬ìš©í•¨
- `auto res2 = doSomething();` ì²˜ëŸ¼ í•¨ìˆ˜ ë¦¬í„´ê°’ìœ¼ë¡œ ë°›ëŠ” ë°©ë²•ë„ ìˆìŒ
	- ë‚´ë¶€ì ìœ¼ë¡œ `move semantics` ë¥¼ ì‚¬ìš©í•˜ê¸°ë•Œë¬¸ì— ë¹ ë¦„

___

```cpp
auto doSomething()
{
	return std::unique_ptr<Resource>(new Resource(5));
    // return std::make_unique<Resource>(5);
}

int main()
{
	{
		
        auto res1 = std::make_unique<Resource>(5);
		// auto res1 = doSomething(); 

		res1->setAll(5);
		res1->print();
	
		std::unique_ptr<Resource> res2; 

		std::cout << std::boolalpha;  
		std::cout << static_cast<bool>(res1) << std::endl;
		std::cout << static_cast<bool>(res2) << std::endl;

		res2 = std::move(res1);

		std::cout << std::boolalpha;
		std::cout << static_cast<bool>(res1) << std::endl;
		std::cout << static_cast<bool>(res2) << std::endl; 

		if (res1 != nullptr) res1->print();
		if (res2 != nullptr) res2->print();
	}
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
Resource length constructed
5 5 5 5 5
true
false
false
true
5 5 5 5 5
Resource destroyed
```

- `static_cast<bool>()`  bool íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…í•˜ì—¬ í¬ì¸í„°ì•ˆì˜ ê°’ì´ nullptr ê°’ì¸ì§€ í™•ì¸í• ìˆ˜ ìˆìŒ
- `res2 = std::move(res1);`
  - ìœ ë‹ˆí¬ í¬ì¸í„°ëŠ” ë³µì‚¬ë¥¼ ëª»í•¨ ex: `res2 = res1;`
  - í•œ ì†Œìœ ê¶Œì´ í•œê³³ì—ë§Œ ìˆì„ìˆ˜ ìˆê¸°ë•Œë¬¸ì— ë³µì‚¬ë¥¼ëª»í•¨
  - `Move semantics` ë§Œ ê°€ëŠ¥

___

```cpp
void doSomething2(std::unique_ptr<Resource> & res)  // unique_ptr ë¥¼ íŒŒë¼ë©”íƒ€ë¡œ ë°›ì„ ë• ë ˆí¼ëŸ°ìŠ¤ë¡œ ë°›ê¸°ë¥¼ ê¶Œì¥
{                                                  
	res->setAll(10); 
}

int main()
{
	{
		auto res1 = std::make_unique<Resource>(5);
		res1->setAll(1);
		res1->print();

		doSomething2(res1);

		res1->print();
	}
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
Resource length constructed
1 1 1 1 1
10 10 10 10 10
Resource destroyed
```

___

**unique_ptr ì„ ê·¸ëŒ€ë¡œ ê°€ì ¸ì˜¤ê³ ì‹¶ì„ë•Œ**

```cpp
void doSomething2(std::unique_ptr<Resource> res)
{
	res->setAll(1000);
	res->print();
}

int main()
{
	{
		std::cout << std::boolalpha;
		auto res1 = std::make_unique<Resource>(5);
		res1->setAll(1);
		res1->print();
		cout << static_cast<bool>(res1) << endl;

		doSomething2(std::move(res1));
		cout << static_cast<bool>(res1) << endl;

	}
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
Resource length constructed
1 1 1 1 1
true
1000 1000 1000 1000 1000
Resource destroyed
false
```

- ì†Œìœ ê¶Œì´ íŒŒë¼ë©”íƒ€ìª½ìœ¼ë¡œ ë„˜ì–´ê°€ì„œ `doSomething2()` ê°€ ëë‚˜ë©´ì„œ `Resource destroyed` ê°€ ì‹¤í–‰ë¨

___

**íŒŒë¼ë©”íƒ€ í¬ì¸í„°ë¡œ ë°›ì•„ì˜¤ê¸°**

```cpp
void doSomething2(Resource* res)
{
	res->setAll(1000);
	res->print();
}

int main()
{
	{
		std::cout << std::boolalpha;
		auto res1 = std::make_unique<Resource>(5);
		res1->setAll(1);
		res1->print();
		cout << static_cast<bool>(res1) << endl;

		doSomething2(res1.get());
		cout << static_cast<bool>(res1) << endl;

	}
}
```

**ì¶œë ¥ê²°ê³¼**

```
Resource length constructed
1 1 1 1 1
true
1000 1000 1000 1000 1000
true
Resource destroyed
```

- `res1.get()` Resource íƒ€ì…ì˜ ìœ ë‹ˆí¬í¬ì¸í„°ê°€ ë‚´ë¶€ì ìœ¼ë¡œ ê°–ê³ ìˆëŠ” Resourceì˜ í¬ì¸í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜

___

```cpp
int main()
{
	{
		Resource* res = new Resource;
		std::unique_ptr<Resource> res1(res);
		std::unique_ptr<Resource> res2(res);

		delete res;
	}
}
```

- `unique_ptr` ì˜ ì†Œìœ ê¶Œì€ res1,res2ì—ê²Œ ë™ì‹œì—ì£¼ëŠ” í˜•íƒœì„ delete ì‹œ ë¬¸ì œê°€ ìƒê¸¸ìˆ˜ ìˆìŒ
- `unique_ptr` ë¥¼ ì£¼ê³  `delete res;` ë¥¼ í•´ë²„ë¦¬ë©´ ë‘ë²ˆ ì§€ìš°ë ¤í•´ì„œ ë¬¸ì œê°€ ë°œìƒí• ìˆ˜ ìˆìŒ

### **ğŸŒ± 15.6 std::shared_ptr**

- `std::shared_ptr`
  - ì†Œìœ ê¶Œì„ ì—¬ëŸ¬êµ°ë°ì— ë™ì‹œì— ë°›ì„ìˆ˜ ìˆìŒ

```cpp
#include <iostream>
#include <memory>

int main()
{
    Resource * res = new Resource(3);
	res->setAll(1);
	std::shared_ptr<Resource> ptr1(res);

    ptr1 -> print();

    {
		std::shared_ptr<Resource> ptr2(ptr1);
		std::shared_ptr<Resource> ptr2(res); // ë¬¸ì œë°œìƒ

		ptr2->setAll(5);
		ptr2->print();

        std::cout << "Going out of the block" << std::endl;
	}

	ptr1->print();

    std::cout << "Going out of the block" << std::endl;

	return 0;
}
``` 

**ì¶œë ¥ê²°ê³¼**

```cpp
Resource length constructed
1 1 1
5 5 5
Going out of the block
5 5 5
Going out of the block
Resource destroyed
```
- ì†Œìœ ê¶Œì„ ì—¬ëŸ¬ shared_ptr ê°€ ë™ì‹œì— ê°€ì§ˆ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ê·¸ ì¤‘ í•œ í¬ì¸í„°ë¡œ deleteë˜ë”ë¼ë„ ê·¸ ê°ì²´ëŠ” ì†Œë©¸ë˜ì§€ ì•ŠëŠ”ë‹¤. ì†Œìœ ê¶Œë§Œ ë°•íƒˆë  ë¿ì´ë‹¤. ê·¸ ê°ì²´ë¥¼ ì†Œìœ í•œ í¬ì¸í„°ê°€ í•˜ë‚˜ ë°–ì— ì—†ì„ ë•Œë§Œ deleteëœë‹¤. ìœ„ ì½”ë“œì—ì„œ`Resource destroyed`ëŠ” ë§ˆì§€ë§‰ì— ptr1ì´ ëë‚ ë•Œ ì‹¤í–‰ì´ë˜ì–´ delete ë¨
- shared_ptrì€ ìì‹ ì´ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ê°ì²´ê°€ ëª‡ êµ°ë°ì„œ ê³µìœ ë˜ê³  ìˆëŠ”ì§€ ë‚´ë¶€ì ìœ¼ë¡œ í•­ìƒ ì„¸ê³  ìˆë‹¤.
- `std::shared_ptr<Resource> ptr2(res);` ptr1ì„ ê±°ì¹˜ì§€ì•Šê³  resë¡œ ì§ì ‘ë°›ì•„ë²„ë¦¬ë©´ ptr1ì—ì„  resì˜ ì†Œìœ ê¶Œì´ ìê¸°ë§ê³  ë”´ë° ë˜ìˆë‹¤ëŠ”ê±¸ ì•Œìˆ˜ê°€ ì—†ê¸° ë•Œë¬¸ì— ë¬¸ì œê°€ ìƒê¹€
  -`Going out of the block` ë¶€ë¶„ì—ì„œ `Resource destroyed` ê°€ ì‹¤í–‰ë„ì–´ ì•„ë˜ ì½”ë“œì—ì„œ ì‚¬ìš©í• ë•Œ ë¬¸ì œê°€ ë°œìƒí•¨

___


**ìŠ¤ë§ˆíŠ¸í¬ì¸í„° ì´ˆê¸°í™”**

```cpp
int main()
{
	Resource* res = new Resource(3);
	res->setAll(1); // 1 ì˜ì‚¬ìš©ì•ˆí•¨
	
	{
		auto ptr1 = std::make_shared<Resource>(3);
		ptr1->setAll(1);

		ptr1->print();
	}

	return 0;
}
```

- ìŠ¤ë§ˆíŠ¸í¬ì¸í„° ì´ˆê¸°í™”ì‹œ `#1` ê°™ì´ ê°„ì ‘ì ì¸ ì´ˆê¸°í™” ë³´ë‹¨ make_shared ì‚¬ìš©í•´ì„œ ì§ì ‘ì ìœ¼ë¡œ ì´ˆê¸°í™” í•˜ëŠ” ë°©ë²•ì„ ì„ í˜¸í•¨

___


**ìŠ¤ë§ˆíŠ¸í¬ì¸í„° í•¨ìˆ˜íŒŒë¼ë©”íƒ€ ì£¼ì˜ì‚¬í•­**

```cpp
void doSomething2(std::unique_ptr<Resource> res)
{

}

int main()
{
	doSomething(std::unique_ptr<Resource>(new Resource(1000000))); // 1
	doSomething(std::make_unique<Resource>(1000000)); // 2
}
```

- `#1` í•¨ìˆ˜íŒŒë¼ë©”íƒ€ë¡œ ë„£ì„ë•Œ ì™„ë²½í•˜ê²Œ ìƒì„±ëœí›„ ë„˜ì–´ê°€ëŠ”ê²ƒì´ ì•„ë‹ˆë¼ ìœ„í—˜í•¨
- `#2` `make_unique` ë¥¼ ì‚¬ìš©í•´ì„œ ë„˜ê¸°ëŠ”ê²Œ ì•ˆì „í•¨

___

- unique_ptrì€ ì†Œìœ ê¶Œì„ ì—„ê²©íˆ ê´€ë¦¬í•  ë•Œ ì‚¬ìš©
- shared_ptrì€ ì†Œìœ ê¶Œì„ ëŠìŠ¨í•˜ê²Œ ê´€ë¦¬í•  ë•Œ ì‚¬ìš©
- shared_ptrì€ ìµœì¢…ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ì˜ ì†Œìœ ê¶Œì´ í•˜ë‚˜ ë‚¨ì€ìƒíƒœì—ì„œ ì¢…ë£Œë ë•Œ ì†Œë©¸ìê°€ ì‹¤í–‰ë˜ì–´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë§‰ì•„ì£¼ëŠ” ê¸°ëŠ¥ì„

### **ğŸŒ± 15.7 ìˆœí™˜ ì˜ì¡´ì„± ë¬¸ì œì™€ std::weak_ptr**

- Circular dependency issues
- shared_ptr ì‚¬ìš©ì‹œ ë°œìƒí• ìˆ˜ìˆëŠ” ìˆœí™˜ ì˜ì¡´ì„± ë¬¸ì œ
  - ì´ë¥¼ í•´ê²°í• ìˆ˜ìˆëŠ” std::weak_ptr

```cpp
#include <iostream>
#include <memory>
#include <string>

class Person
{
	std::string m_name;
	std::shared_ptr<Person> m_partner;
	//std::weak_ptr<Person> m_partner;

public:
	Person(const std::string &name) : m_name(name)
	{
		std::cout << m_name << " created\n";
	}

	~Person()
	{
		std::cout << m_name << " destroyed\n";
	}

	friend bool partnerUp (std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2) 
	{
		if (!p1 || !p2)
			return false;
		
		p1->m_partner = p2;
		p2->m_partner = p1;

		std::cout << p1->m_name << " is partnered with " << p2->m_name << "\n";

		return true;
	}

	const std::string & getName() const
	{
		return m_name;
	}
};

int main()
{
	auto lucy = std::make_shared<Person>("Lucy");
	auto ricky = std::make_shared<Person>("Ricky");

	partnerUp(lucy, ricky); // ë¬¸ì œ ë°œìƒ

	return 0;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Lucy created
Ricky created
Lucy is partnered with Ricky
```

- `partberUp(lucy, ricky);` ì‹œ ì†Œë©¸ìê°€ ì‹¤í–‰ì´ ì•ˆë˜ì–´ ë©”ëª¨ë¦¬ ë¦­ì´ ë°œìƒí•¨
- `Person` ì„ ì§€ìš¸ë ¤ê³  í• ë•Œ `m_partner` ë¥¼ ì§€ìš¸ë ¤ê³  ì‹œë„ë¥¼ í•˜ëŠ”ë° ì¹´ìš´í„°ê°€ ë˜ë‹ˆê¹Œ ì§€ìš¸ìˆ˜ê°€ ì—†ì–´ì„œ `Person` ì„ ëª»ì§€ìš°ëŠ” í˜„ìƒì´ ë°œìƒí•¨
  - ì†Œìœ ê¶Œì´ ìˆœí™˜ë˜ëŠ” ìˆœí™˜ í˜„ìƒì´ ë°œìƒí•¨ 

___

**std::weak_ptr**

```cpp
#include <iostream>
#include <memory>
#include <string>

class Person
{
	std::string m_name;
	/*std::shared_ptr<Person> m_partner;*/
	std::weak_ptr<Person> m_partner;

public:
	Person(const std::string& name) : m_name(name)
	{
		std::cout << m_name << " created\n";
	}

	~Person()
	{
		std::cout << m_name << " destroyed\n";
	}

	friend bool partnerUp(std::shared_ptr<Person>& p1, std::shared_ptr<Person>& p2) // â­â­
	{
		if (!p1 || !p2)
			return false;

		p1->m_partner = p2;
		p2->m_partner = p1;

		std::cout << p1->m_name << " is partnered with " << p2->m_name << "\n";

		return true;
	}

	const std::string& getName() const
	{
		return m_name;
	}
};

int main()
{
	auto lucy = std::make_shared<Person>("Lucy");
	auto ricky = std::make_shared<Person>("Ricky");

	partnerUp(lucy, ricky); 

	return 0;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Lucy created
Ricky created
Lucy is partnered with Ricky
Ricky destroyed
Lucy destroyed
```

- weak_ptr ëŠ” í•œê³„ê°€ ìˆìŒ 
- weak_ptrì˜ ë‚´ìš©ë¬¼ì„ ì‚¬ìš©í• ë•Œ lockì„ í•´ì¤˜ì•¼í•¨
- weak_ptrëŠ” ì§ì ‘ì‚¬ìš©í• ìˆ˜ ì—†ê³  lockì„ í•´ì„œ shared_ptrë¥¼ ë¦¬í„´ë°›ì•„ ì‚¬ìš©í• ìˆ˜ ìˆìŒ

```cpp
const std::shared_ptr<Person> getPartner() const 
{                                            
	return m_partner.lock();
}         
```

- ìˆœí™˜ ì˜ì¡´ì„±ì„ê¹¨ê¸° ìœ„í•´ ìœ„ì™€ê°™ì€ í˜•íƒœì„

# ğŸ“Œì°¸ì¡°ë§í¬
ì¸í”„ëŸ° **ë”°ë¼í•˜ë©´ì„œ ë°°ìš°ëŠ” C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)