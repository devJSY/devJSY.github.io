---
published: true
title:  "따라하며 배우는 C++ Section 15. 의미론적 이동과 스마트 포인터"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-01
last_modified_at: 2022-05-01
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 15. 의미론적 이동과 스마트 포인터

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 15. 의미론적 이동과 스마트 포인터**

### **🌱 15.1 이동의 의미와 스마트 포인터**

- move semantics
- Smart pointers

```cpp
#include <iostream>

using namespace std;

class Resource
{
public:
	int m_data[100];

public:
	Resource()
	{
		cout << "Resource constructed" << endl;
	}

	~Resource()
	{
		cout << "Resource destroyed" << endl;
	}
};

void doSomething()
{
	try
	{
		Resource* res = new Resource;

		if (true)
		{
			throw - 1; // exception
		}
		delete res;
	}
	catch (...)
	{
	}
	return;
}

int main()
{
	doSomething();
}
```

- new 한곳에서 delete 해주는것을 RAII 라고함
  - RAII: resource acquisition is initialization
- early return
  - delete하기전 특정조건이 충족되어 return해버리는것
  - 전통적인 c++에선 이런식으로 해주도록 되어있었음

___


**std::auto_ptr<int>;** 

- c++ 98 만들어짐 c++ 11때 사용하지 않기로했고 c++ 17때 삭제가됨 
- 복잡한경우 작동하지 않는경우가 있었음
- 스마트포인터로 넘어가게됨
- 소멸자에서 변수가 nullptr이 아니면 지우는 기능임
- 클래스단위로 묶으면 

```cpp
class Resource
{
public:
	int m_data[100];

public:
	Resource()
	{
		cout << "Resource constructed" << endl;
	}

	~Resource()
	{
		cout << "Resource destroyed" << endl;
	}
};

template<typename T>
class AutoPtr
{
public:
	T* m_ptr = nullptr;

public:
	AutoPtr(T* ptr = nullptr)
		:m_ptr(ptr) {}
	~AutoPtr() 
	{
		if (m_ptr != nullptr) delete m_ptr; 
	}
	T& operator *() const { return *m_ptr; }  
	T* operator ->() const { return m_ptr; } 
	bool inNull() const { return m_ptr == nullptr; }
};
```

```cpp
void doSomething()
{
	try 
	{
		AutoPtr<Resource> res = new Resource;  
		if (true)
		{
			throw - 1; 
		}		

	}
	catch (...)
	{
	}
	return;		
}

int main()
{
	doSomething();
}
```

- **dull pointer:** 동적으로 메모리를 할당받고있지만 자기가끝까지 책임을 안지고 수동으로해줘야하는 포인터
- **smart pointer:** `AutoPtr<Resource> res = new Resource;` 
  - 객체 res 가 소멸될 때 AutoPtr 클래스의 소멸자에서 알아서 delete 해줌
  - `AutoPtr<Resource> res(new Resource);` 초기화 해주는것이기 때문에 이렇게 해주는 것이 좋음

___

**문제 발생 코드**

```cpp
int main()
{
	{]
    // int i; int *ptr(&i); int *ptr2 = nullptr; 과 같은 형태
		AutoPtr<Resource> res1(new Resource); // 초기화 된 상태
		AutoPtr<Resource> res2; // 초기화안됨 nullptr

		cout << res1.m_ptr << endl; 
		cout << res2.m_ptr << endl; 

		res2 = res1;	// 문제 발생 부분

		cout << res1.m_ptr << endl;  
		cout << res2.m_ptr << endl;  
	}
}
```

```cpp
출력 결과
Resource constructed
0014FFA8
00000000
0014FFA8
0014FFA8
Resource destroyed
Resource destroyed
```

- 런타임 에러 발생됨
  - 이미 지워진 객체를 또 지우려하여 에러 발생
- `res2 = res1;` 내부적으로 AutoPtr안에 있는 멤버를 복사해줌
- `new Resource` 에 대한 소유권을 `res2 = res1;` 하게되는 순간 res1의 소유권을 res2 에 넘겨주게 되어 두변수가 모두 소유권을 갖게되어 문제가됨


**해결 방법**

```cpp
#include <iostream>
using namespace std;

template<typename T>
class AutoPtr
{
public:
	T* m_ptr= nullptr;

public:
	AutoPtr(T* ptr = nullptr)
		:m_ptr(ptr) {}
	~AutoPtr()
	{
		if(m_ptr != nullptr) delete m_ptr;
	}

	AutoPtr(AutoPtr& a)  // 복사 생성자
	{
		m_ptr = a.m_ptr;
		a.m_ptr = nullptr;  // 소유권 박탈
	}

	AutoPtr& operator = (AutoPtr& a)  // 대입 연산자 오버로딩
	{
		if (&a == this)  
			return *this;
		
		delete m_ptr;   
		m_ptr = a.m_ptr; 
		a.m_ptr = nullptr;   
		return *this;
	}

	T& operator *() const { return *m_ptr; }
	T* operator ->() const { return m_ptr; }
	bool inNull() const { return m_ptr == nullptr; }
};
```
```cpp
출력결과
Resource constructed
000001F0E8063820
0000000000000000
0000000000000000
000001F0E8063820
Resource destroyed // res2.m_ptr 의 소멸자에서 실행시킴
```

- 복사 생성자에서 파라메타의 ptr를 복사해서 m_ptr에 넣고 파라메타의 nullptr을 넣어 소유권을 박탈해주는 방식

- 대입 연산자 오버로딩에서는 이미 내가 갖고 있던건 지워버리고 새로 들어온얘의 메모리 주소를 복사해서 받고 원래 메모리 주소는 nullptr로 바꿔버리면 소유권이 이전이 됨

- **Move semantics:** 소유권을 이전 시키는 방식

___

**syntax vs semantics**

- syntax
  - 문법에 맞냐 안맞냐, 컴파일이 되냐 안되냐를 보는 것
- semantics
  - 컴파일이 되는건 똑같은데 실질적으로 내부의 의미가 맞는지 보는것

```cpp
int x = 1, y = 1;
x + y;

string str1("Hello"), str2("World");
str1 + str2; // append
```

- 위 `+` 의 기호는 같지만 의미가 다름 이를 semantics라고 함

- value semantics (copy semantics)
- reference semantice (pointer)
- move semantics (move)

### **🌱 15.2 오른쪽-값 참조**

- R-value References

```cpp
#include <iostream>
using namespace std;

void doSomething(int& lref) { cout << "L-value ref" << endl; }
void doSomething(int&& rref) { cout << "R-value ref" << endl; }
int getResult() { return 100; }

int main()
{
	int x = 5;             
	int y = getResult();     
	const int cx = 6;          
	const int cy = getResult(); 

	/* L-value references */
	int& lr1 = x;		            
	int& lr2 = cx;		        
	int& lr3 = 10;			      

	const int& lr4 = x;		
	const int& lr5 = cx;
	const int& lr6 = 10;	

	/* R-value references */
	int&& rr1 = x;		
	int&& rr2 = cx;		
	int&& rr3 = 10;		
	int&& rr4 = getResult();
	rr3 = 20;			

	const int&& rr5 = x;	
	const int&& rr6 = cx;
	const int&& rr7 = 10;
	const int&& rr8 = getResult();

	doSomething(x);				/* L-value reference */
	doSomething(10);			/* R-value reference */
	doSomething(getResult());	/* R-value reference */
	doSomething(rr3);			/* L-value reference */
}
```

**variable**
-	`int x = 5;`                     
    - 5라는 R-value를 L-value 인 x 변수의 메모리에 저장하는것
-	`int y = getResult();`          
    - 함수의 리턴값 R-value를 L-value 인 y 변수의 메모리에 저장하는것
-	`const int cx = 6;`             
    - 6라는 R-value를 L-value 인 cx const 변수의 메모리에 저장하는것
-	`const int cy = getResult();`   
    - 함수의 리턴값 R-value를 L-value 인 cy const 변수의 메모리에 저장하는것

**L-value references**

- `int& lr1 = x;`
  - 컴파일 ⭕
  - Modifiable L-vlaue lr1과 x는 같은 주소를 가짐

- `int& lr2 = cx;`		            
  - 컴파일 ❌
  - Non-modifiable L-vlaue lr2가 const가 아니므로 cx를 넣을수 없음

- `int& lr3 = 10;`			  
  - 컴파일 ❌         
  -  R-value lr3가 이후 사용될때 자기가 참조하고있는 변수가 메모리를 갖고있다는 전제하에 작동하기때문에 L-value references 이기때문에 R-value에 대해서는 references를 가질수 없음
  - 고전적 C++ 에선 references를 L-value references를 의미함

- `const int& lr4 = x;`		
  - 컴파일 ⭕
  - Modifiable L-vlaue lr1과 x는 같은 주소를 가짐
- `const int& lr5 = cx;`
  - 컴파일 ⭕
  - Non-modifiable L-vlaue lr2가 const가 아니므로 cx를 넣을수 없음
- `const int& lr6 = 10;`	
  - 컴파일 ⭕ 
  - R-value 메모리주소와 상관없이 심볼릭 컨스턴스처럼만 사용하겠다는 의미로 가능함

**R-value references**

- R-value references 는 `&&` 임 `&` 와 구분하기 위함임 
- 곧 사라질 얘들만 담을수 있음
- R-value 레퍼런스로 가르켜지는 애들은 move를 해서 다른곳으로 옮겨도 어짜피 사라질 애들이라 아무도 찾지않는다는 의미
- R-value가 클래스의 오브젝트나 인스턴스라면 value로 Move semantics 를 해버려도 문제가 없다는 것이고 사용을 할수도 있음

<br>

- `int&& rr1 = x;`		
  - 컴파일 ❌
  - Modifiable L-vlaue
- `int&& rr2 = cx;`	
  - 컴파일 ❌
  - Non-modifiable L-vlaue
- `int&& rr3 = 10;`		
  - 컴파일 ⭕
  - R-value 만 받을수 있음
- `int&& rr4 = getResult();`
  - 컴파일 ⭕
  - 리턴받은 임시적인값을 `rr4`에 저장해놓는 것
- `rr3 = 20;`			
  - R-value의 값을 변경할수 있음

<br>

- `const int&& rr5 = x;`	
  - 컴파일 ❌
  - Modifiable L-vlaue
- `const int&& rr6 = cx;`
  - 컴파일 ❌
  - Non-modifiable L-vlaue
- `const int&& rr7 = 10;`
  - 컴파일 ⭕
- `const int&& rr8 = getResult();`
  - 컴파일 ⭕

___

```cpp
void doSomething(int& lref) { cout << "L-value ref" << endl; }
void doSomething(int&& rref) { cout << "R-value ref" << endl; }
int getResult() { return 100; }
```
- 컴파일러가 파라메타가 L-value, R-value 레퍼런스인것은 다르게 기능을 할수 있도록 오버로딩을 인정해줌

<br>

- `doSomething(x);`			
  - L-value reference 
- `doSomething(10);`			
  - R-value reference 
- `doSomething(getResult());`	
  - R-value reference 
- `doSomething(rr3);`		
  - L-value reference

<br>

- R-Value reference로 받아온 경우에는 파라메타가 어짜피 다른데서 쓸일이 없기때문에 Move Semantic를 사용할수 있음
- L-Value reference 를 사용할 경우에는 파라메타가 메모리를 갖고있는 변수고 그 변수는 dosomething함수 밖에서도 사용을 해야하니까 moveSemantic로 가져와버리면 문제가 생길수 있으므로 Move Semantic를 사용할수 없음

### **🌱 15.3 이동 생성자와 이동 대입**

### **🌱 15.4 std::move**

### **🌱 **

### **🌱 **

### **🌱 **

# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)