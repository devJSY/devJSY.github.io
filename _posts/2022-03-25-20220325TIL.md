---
published: true
title:  "ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ë²¨ë§Œ í¬ë“œ, ìë£Œêµ¬ì¡°:ë°”ì´ë„ˆë¦¬ ì¸ë±ìŠ¤ íŠ¸ë¦¬(Binary Indexed Tree), BIT, íœìœ… íŠ¸ë¦¬, ìµœì†Œ ê³µí†µ ì¡°ìƒ (Lowest Commin Ancestor)"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL, Python]

toc: true
toc_sticky: true
 
date: 2022-03-25
last_modified_at: 2022-03-25
---

# **2022-03-25 TIL**

# ğŸ¤” ì˜¤ëŠ˜ì˜ í•™ìŠµëª©í‘œ
- ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ë²¨ë§Œ í¬ë“œ 
- ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ìë£Œêµ¬ì¡°:ë°”ì´ë„ˆë¦¬ ì¸ë±ìŠ¤ íŠ¸ë¦¬(Binary Indexed Tree), BIT, íœìœ… íŠ¸ë¦¬
- ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ìµœì†Œ ê³µí†µ ì¡°ìƒ (Lowest Commin Ancestor)

# ğŸ“ƒ í•™ìŠµë‚´ìš©
### **ğŸ“ ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ë²¨ë§Œ í¬ë“œ**

ğŸ“Œ **ìŒìˆ˜ ê°„ì„ ì´ í¬í•¨ëœ ìƒí™©ì—ì„œì˜ ìµœë‹¨ ê±°ë¦¬ ë¬¸ì œ**

- ìŒìˆ˜ ê°„ì„ ì— ê´€í•˜ì—¬ ìµœë‹¨ ê²½ë¡œ ë¬¸ì œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë¶„ë¥˜ë¨
  1. ëª¨ë“œ ê°„ì„ ì´ ì–‘ìˆ˜ì¸ ê²½ìš°
  2. ìŒìˆ˜ ê°„ì„ ì´ ìˆëŠ” ê²½ìš°
     1. ìŒìˆ˜ ê°„ì„  ìˆœí™˜ì€ ì—†ëŠ” ê²½ìš°
     2. ìŒìˆ˜ ê°„ì„  ìˆœí™˜ì´ ìˆëŠ” ê²½ìš°

- ë²¨ë§Œ í¬ë“œ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ì€ ìŒì˜ ê°„ì„ ì´ í¬í•¨ëœ ìƒí™©ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
  - ë˜í•œ ìŒìˆ˜ ê°„ì„ ì˜ ìˆœí™˜ì„ ê°ì§€ í•  ìˆ˜ ìˆìŒ
  - ë²¨ë§Œ í¬ë“œì˜ ê¸°ë³¸ ì‹œê°„ ë³µì¡ë„ëŠ” O(VE)ë¡œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì— ë¹„í•´ ëŠë¦¼

**ë²¨ë§Œ í¬ë“œ ì•Œê³ ë¦¬ì¦˜**
1. ì¶œë°œ ë…¸ë“œë¥¼ ì„¤ì •
2. ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ì´ˆê¸°í™”
3. ë‹¤ìŒì˜ ê³¼ì •ì„ N -1 ë²ˆ ë°˜ë³µ
   1. ì „ì²´ ê°„ì„  Eê°œë¥¼ í•˜ë‚˜ì”© í™•ì¸
   2. ê° ê°„ì„ ì„ ê±°ì³ ë‹¤ë¥¸ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©ì„ ê³„ì‚°í•˜ì—¬ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ê°±ì‹ 

- ë§Œì•½ ìŒìˆ˜ ê°„ì„  ìˆœí™˜ì´ ë°œìƒí•˜ëŠ”ì§€ ì²´í¬í•˜ê³  ì‹¶ë‹¤ë©´ 3ë²ˆì˜ ê³¼ì •ì„ í•œ ë²ˆ ë” ìˆ˜í–‰
  - ì´ë•Œ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì´ ê°±ì‹  ë˜ë©´ ìŒìˆ˜ ê°„ì„  ìˆœí™˜ì´ ì¡´ì¬í•˜ë‹¤ëŠ” ëœ»

**ë²¨ë§Œ í¬ë“œ ì•Œê³ ë¦¬ì¦˜ vs ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**
- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
  - ë§¤ë²ˆ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ ì„ íƒ
  - ìŒìˆ˜ ê°„ì„ ì´ ì—†ë‹¤ë©´ ìµœì ì˜ í•´

- ë²¨ë§Œ í¬ë“œ ì•Œê³ ë¦¬ì¦˜
  - ë§¤ë²ˆ ëª¨ë“  ê°„ì„ ì„ ì „ë¶€ í™•ì¸
    - ë”°ë¼ì„œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ ìµœì ì˜ í•´ë¥¼ í•­ìƒ í¬í•¨
  - ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì— ë¹„í•´ì„œ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ì§€ë§Œ ìŒìˆ˜ ê°„ì„  ìˆœí™˜ì„ íƒì§€ í•  ìˆ˜ ìˆìŒ.

**íŒŒì´ì¬ ì†ŒìŠ¤ì½”ë“œ**

```py
import sys
input = sys.stdin.readline
INF = int(1e9) # ë¬´í•œì„ ì˜ë¯¸í•˜ëŠ” ê°’ìœ¼ë¡œ 10ì–µì„ ì„¤ì •

# ë…¸ë“œì˜ ê°œìˆ˜, ê°„ì„ ì˜ ê°œìˆ˜ë¥¼ ì…ë ¥ë°›ê¸°
n, m = map(int, input().split())
# ëª¨ë“  ê°„ì„ ì— ëŒ€í•œ ì •ë³´ë¥¼ ë‹´ëŠ” ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°
edges = []
# ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ëª¨ë‘ ë¬´í•œìœ¼ë¡œ ì´ˆê¸°í™”
distance = [INF] * (n + 1)

# ëª¨ë“  ê°„ì„  ì •ë³´ë¥¼ ì…ë ¥ë°›ê¸°
for _ in range(m):
    a, b, c = map(int, input().split())
    # aë²ˆ ë…¸ë“œì—ì„œ bë²ˆ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©ì´ cë¼ëŠ” ì˜ë¯¸
    edges.append((a, b, c))

def bf(start):
    # ì‹œì‘ ë…¸ë“œì— ëŒ€í•´ì„œ ì´ˆê¸°í™”
    distance[start] = 0
    # ì „ì²´ n - 1ë²ˆì˜ ë¼ìš´ë“œ(round)ë¥¼ ë°˜ë³µ
    for i in range(n):
        # ë§¤ ë°˜ë³µë§ˆë‹¤ "ëª¨ë“  ê°„ì„ "ì„ í™•ì¸í•˜ë©°
        for j in range(m):
            cur_node = edges[j][0]
            next_node = edges[j][1]
            edge_cost = edges[j][2]
            # í˜„ì¬ ê°„ì„ ì„ ê±°ì³ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì´ë™í•˜ëŠ” ê±°ë¦¬ê°€ ë” ì§§ì€ ê²½ìš°
            if distance[cur_node] != INF and distance[next_node] > distance[cur_node] + edge_cost:
                distance[next_node] = distance[cur_node] + edge_cost
                # në²ˆì§¸ ë¼ìš´ë“œì—ì„œë„ ê°’ì´ ê°±ì‹ ëœë‹¤ë©´ ìŒìˆ˜ ìˆœí™˜ì´ ì¡´ì¬
                if i == n - 1:
                    return True
    return False

# ë²¨ë§Œ í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜í–‰
negative_cycle = bf(1) # 1ë²ˆ ë…¸ë“œê°€ ì‹œì‘ ë…¸ë“œ

if negative_cycle:
    print("-1")
else:
    # 1ë²ˆ ë…¸ë“œë¥¼ ì œì™¸í•œ ë‹¤ë¥¸ ëª¨ë“  ë…¸ë“œë¡œ ê°€ê¸° ìœ„í•œ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì¶œë ¥
    for i in range(2, n + 1):
        # ë„ë‹¬í•  ìˆ˜ ì—†ëŠ” ê²½ìš°, -1ì„ ì¶œë ¥
        if distance[i] == INF:
            print("-1")
        # ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ê²½ìš° ê±°ë¦¬ë¥¼ ì¶œë ¥
        else:
            print(distance[i])
```

### **ğŸ“ ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ìë£Œêµ¬ì¡°:ë°”ì´ë„ˆë¦¬ ì¸ë±ìŠ¤ íŠ¸ë¦¬(Binary Indexed Tree), BIT, íœìœ… íŠ¸ë¦¬**

**ë°”ì´ë„ˆë¦¬ ì¸ë±ìŠ¤ íŠ¸ë¦¬(Binary Indexed Tree)**
- 2ì§„ë²• ì¸ë±ìŠ¤ êµ¬ì¡°ë¥¼ í™œìš©í•´ êµ¬ê°„ í•© ë¬¸ì œë¥¼ íš¨ê³¼ì ìœ¼ë¡œ í•´ê²°í•´ ì¤„ ìˆ˜ ìˆëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì˜ë¯¸í•¨
  - íœìœ… íŠ¸ë¦¬(fenwick tree)ë¼ê³ ë„ í•¨
- 0ì´ ì•„ë‹Œ ë§ˆì§€ë§‰ ë¹„íŠ¸ë¥¼ ì°¾ëŠ” ë°©ë²•
  - íŠ¹ì •í•œ ìˆ«ì kì˜ 0ì´ ì•„ë‹Œ ë§ˆì§€ë§‰ ë¹„íŠ¸ë¥¼ ì°¾ê¸° ìœ„í•´ì„œ K & -K ë¥¼ ê³„ì‚°í•˜ë©´ ë¨

**íŒŒì´ì¬ ì†ŒìŠ¤ì½”ë“œ**

```py
n = 8

for i in range(n + 1):
  print(i, "ì˜ ë§ˆì§€ë§‰ ë¹„íŠ¸:", (i & -i))
```

**ë°”ì´ë„ˆë¦¬ ì¸ë±ìŠ¤ íŠ¸ë¦¬(Binary Indexed Tree) íŒŒì´ì¬ ì†ŒìŠ¤ì½”ë“œ**

```py
import sys
input = sys.stdin.readline

# ë°ì´í„°ì˜ ê°œìˆ˜(n), ë³€ê²½ íšŸìˆ˜(m), êµ¬ê°„ í•© ê³„ì‚° íšŸìˆ˜(k)
n, m, k = map(int, input().split())

# ì „ì²´ ë°ì´í„°ì˜ ê°œìˆ˜ëŠ” ìµœëŒ€ 1,000,000ê°œ
arr = [0] * (n + 1)
tree = [0] * (n + 1)

# ië²ˆì§¸ ìˆ˜ê¹Œì§€ì˜ ëˆ„ì  í•©ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
def prefix_sum(i):
    result = 0
    while i > 0:
        result += tree[i]
        # 0ì´ ì•„ë‹Œ ë§ˆì§€ë§‰ ë¹„íŠ¸ë§Œí¼ ë¹¼ê°€ë©´ì„œ ì´ë™
        i -= (i & -i)
    return result

# ië²ˆì§¸ ìˆ˜ë¥¼ difë§Œí¼ ë”í•˜ëŠ” í•¨ìˆ˜
def update(i, dif):
    while i <= n:
        tree[i] += dif
        i += (i & -i)

# startë¶€í„° endê¹Œì§€ì˜ êµ¬ê°„ í•©ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
def interval_sum(start, end):
    return prefix_sum(end) - prefix_sum(start - 1)

for i in range(1, n + 1):
    x = int(input())
    arr[i] = x
    update(i, x)

for i in range(m + k):
    a, b, c = map(int, input().split())
    # ì—…ë°ì´íŠ¸(update) ì—°ì‚°ì¸ ê²½ìš°
    if a == 1:
        update(b, c - arr[b]) # ë°”ë€ í¬ê¸°(dif)ë§Œí¼ ì ìš©
        arr[b] = c
    # êµ¬ê°„ í•©(interval sum) ì—°ì‚°ì¸ ê²½ìš°
    else:
        print(interval_sum(b, c))
```

### **ğŸ“ ì´ì½”í…Œ 2021 ê°•ì˜ ëª°ì•„ë³´ê¸° ìµœì†Œ ê³µí†µ ì¡°ìƒ (Lowest Commin Ancestor)**

**ìµœì†Œ ê³µí†µ ì¡°ìƒ (Lowest Commin Ancestor)**
1. ëª¨ë“  ë…¸ë“œì— ëŒ€í•œ ê¹Šì´(depth)ë¥¼ ê³„ì‚°í•¨
2. ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ì„ ë‘ ë…¸ë“œë¥¼ í™•ì¸
   1. ë¨¼ì € ë‘ ë…¸ë“œì˜ ê¹Šì´(depth)ê°€ ë™ì¼ í•˜ë„ë¡ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°
   2. ì´í›„ì— ë¶€ëª¨ê°€ ê°™ì•„ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µì ìœ¼ë¡œ ë‘ ë…¸ë“œì˜ ë¶€ëª¨ ë°©í–¥ìœ¼ë¡œ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°
3. ëª¨ë“  LCA(a,b) ì—°ì‚°ì— ëŒ€í•˜ì—¬ 2ë²ˆì˜ ê³¼ì •ì„ ë°˜ë³µ

**ì—°ì‚° ê³¼ì •**
1. DFSë¥¼ ì´ìš©í•´ ëª¨ë“  ë…¸ë“œì— ëŒ€í•˜ì—¬ ê¹Šì´ë¥¼ ê³„ì‚°
2. ë‘ ë…¸ë“œì˜ ê¹Šì´ë¥¼ ë§ì¶¤
3. ì´í›„ì— ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°

**LCA ê¸°ë³¸ ì†ŒìŠ¤ì½”ë“œ**

```py
import sys
sys.setrecursionlimit(int(1e5)) # ëŸ°íƒ€ì„ ì˜¤ë¥˜ë¥¼ í”¼í•˜ê¸° ìœ„í•œ ì¬ê·€ ê¹Šì´ ì œí•œ ì„¤ì •

n = int(input())

parent = [0] * (n + 1) # ë¶€ëª¨ ë…¸ë“œ ì •ë³´
d = [0] * (n + 1) # ê° ë…¸ë“œê¹Œì§€ì˜ ê¹Šì´
c = [0] * (n + 1) # ê° ë…¸ë“œì˜ ê¹Šì´ê°€ ê³„ì‚°ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
graph = [[] for _ in range(n + 1)] # ê·¸ë˜í”„(graph) ì •ë³´

for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# ë£¨íŠ¸ ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬ ê¹Šì´(depth)ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜
def dfs(x, depth):
    c[x] = True
    d[x] = depth
    for y in graph[x]:
        if c[y]: # ì´ë¯¸ ê¹Šì´ë¥¼ êµ¬í–ˆë‹¤ë©´ ë„˜ê¸°ê¸°
            continue
        parent[y] = x
        dfs(y, depth + 1)

# Aì™€ Bì˜ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ëŠ” í•¨ìˆ˜
def lca(a, b):
    # ë¨¼ì € ê¹Šì´(depth)ê°€ ë™ì¼í•˜ë„ë¡
    while d[a] != d[b]:
        if d[a] > d[b]:
            a = parent[a]
        else:
            b = parent[b]
    # ë…¸ë“œê°€ ê°™ì•„ì§€ë„ë¡
    while a != b:
        a = parent[a]
        b = parent[b]
    return a

dfs(1, 0) # ë£¨íŠ¸ ë…¸ë“œëŠ” 1ë²ˆ ë…¸ë“œ

m = int(input())

for i in range(m):
    a, b = map(int, input().split())
    print(lca(a, b))
```
- ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì„ ì´ìš©í•´ ì‹œê°„ë³µì¡ë„ë¥¼ ê°œì„ í•  ìˆ˜ ìˆìŒ
  - ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ ì´ìš©í•˜ëŠ” ë°©ë²•ë„ ì¡´ì¬í•¨

**LCA ì‹¬í™” ì†ŒìŠ¤ì½”ë“œ**

```py
import sys
input = sys.stdin.readline # ì‹œê°„ ì´ˆê³¼ë¥¼ í”¼í•˜ê¸° ìœ„í•œ ë¹ ë¥¸ ì…ë ¥ í•¨ìˆ˜
sys.setrecursionlimit(int(1e5)) # ëŸ°íƒ€ì„ ì˜¤ë¥˜ë¥¼ í”¼í•˜ê¸° ìœ„í•œ ì¬ê·€ ê¹Šì´ ì œí•œ ì„¤ì •
LOG = 21 # 2^20 = 1,000,000

n = int(input())
parent = [[0] * LOG for _ in range(n + 1)] # ë¶€ëª¨ ë…¸ë“œ ì •ë³´
d = [0] * (n + 1) # ê° ë…¸ë“œê¹Œì§€ì˜ ê¹Šì´
c = [0] * (n + 1) # ê° ë…¸ë“œì˜ ê¹Šì´ê°€ ê³„ì‚°ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
graph = [[] for _ in range(n + 1)] # ê·¸ë˜í”„(graph) ì •ë³´

for _ in range(n - 1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# ë£¨íŠ¸ ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬ ê¹Šì´(depth)ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜
def dfs(x, depth):
    c[x] = True
    d[x] = depth
    for y in graph[x]:
        if c[y]: # ì´ë¯¸ ê¹Šì´ë¥¼ êµ¬í–ˆë‹¤ë©´ ë„˜ê¸°ê¸°
            continue
        parent[y][0] = x
        dfs(y, depth + 1)

# ì „ì²´ ë¶€ëª¨ ê´€ê³„ë¥¼ ì„¤ì •í•˜ëŠ” í•¨ìˆ˜
def set_parent():
    dfs(1, 0) # ë£¨íŠ¸ ë…¸ë“œëŠ” 1ë²ˆ ë…¸ë“œ
    for i in range(1, LOG):
        for j in range(1, n + 1):
            parent[j][i] = parent[parent[j][i - 1]][i - 1]

# Aì™€ Bì˜ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ëŠ” í•¨ìˆ˜
def lca(a, b):
    # bê°€ ë” ê¹Šë„ë¡ ì„¤ì •
    if d[a] > d[b]:
        a, b = b, a
    # ë¨¼ì € ê¹Šì´(depth)ê°€ ë™ì¼í•˜ë„ë¡
    for i in range(LOG - 1, -1, -1):
        if d[b] - d[a] >= (1 << i):
            b = parent[b][i]
    # ë¶€ëª¨ê°€ ê°™ì•„ì§€ë„ë¡
    if a == b:
        return a;
    for i in range(LOG - 1, -1, -1):
        # ì¡°ìƒì„ í–¥í•´ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ê¸°
        if parent[a][i] != parent[b][i]:
            a = parent[a][i]
            b = parent[b][i]
    # ì´í›„ì— ë¶€ëª¨ê°€ ì°¾ê³ ì í•˜ëŠ” ì¡°ìƒ
    return parent[a][0]

set_parent()

m = int(input())

for i in range(m):
    a, b = map(int, input().split())
    print(lca(a, b))
```

# ğŸ“Œì°¸ì¡°ë§í¬
>**ë‚˜ë™ë¹ˆ ë‹˜ íŒŒì´ì¬ ì•Œê³ ë¦¬ì¦˜** ìœ íŠœë¸Œ ë§í¬ - [https://www.youtube.com/watch?v=2zjoKjt97vQ&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=2](https://www.youtube.com/watch?v=2zjoKjt97vQ&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=2)