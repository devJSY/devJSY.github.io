---
published: true
title:  "C/C++ 강의 내용 정리"
excerpt: ""

categories:
  - C++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-07-22
last_modified_at: 2022-07-22
---

# 🤔 학습목표
- C/C++ 강의 내용 간략하게 정리

# 📃 학습내용

## 📍 **C/C++ 강의 Prologue. C++ 공부이유와 공부법**

- C++ 는 JAVA 나 C# 과 같이 가상머신을 통하지 않고 바로 메모리관리를 하기때문에 속도에 있어 유리함
- 위와같은 이유로 게임프로그래밍에선 C++ 이 유리함 다만 개발속도가 느린편

**공부 방향**

1. C++ 기초문법, 자료구조(데이터)
2. winapi 게임제작 ( CPU 만 사용하여 게임 제작 )
3. Direct X 게임제작 ( 그래픽 카드 제어 )
4. 게임엔진 게임제작

## 📍 **C/C++ 강의 1화. 프로젝트 생성 및 주석**

- 컴퓨터 언어또한 "언어" 이므로 일정 수준이상 수월하게 사용하기 위해선 암기가 필연적이다.
- 공부한것을 블로그등에 정리해놓으면 시간이 지나면서 구멍이뚫린 기억을 메꾸는데 도움이된다

___

**주석**
- `//` 이나 `/**/` 을 사용해서 사용가능
- 내가 작성해둔 코드가 어떤 역할을 하는지 필요한 내용들을 설명하는 용도로 사용

## 📍 **C/C++ 강의 2화. 자료형**

```cpp
int main()
{
	int i = 0;

	return 0;
}
```

- int : 자료형
- i : 변수명

___

**자료형 (크기 단위, byte)**
- 정수형: char(1), short(2), int(4), long(4), long long(8)
- 실수형: float(4), double(8)

<br><br/>

- 자료형이란 변수가 어떠한 자료의 형태를 나타내는지 표현해주는 것
- 자료형으로 **표현 방식** 과 **크기 단위(byte)** 를 알수있음

___

**데이터의 단위**

**1 Byte = 8 bit**
- 1 bit 는 값이 있다 없다를 표현해주는 데이터의 최소값을 나타냄

- 데이터 단위는 **2^10 = 1024묶음** 단위로 byte - kb - mb - gb - tb 순으로 표현함

___

**경우의 수**

- **2^8 = 256** 8비트로는 **0~255까지 256가지**의 상태를 표현할수있음
 
___

**unsigned**

- 정수형 자료형 앞에 붙이면 양의 정수만 표현가능한 정수형 자료형을 만들수있음
- **unsigned char** 에 256값을 넣게되면 0이 나오게됨
  - 255까지만 넣을수 있는 공간에 256이라는 초과된 값을 넣으면 잘려서 못들어감

___

**변수의 선언 위치**

**올바른 선언** 
```cpp
int main()
{
  char c = 0;

  c = 256;

  return 0;
}
```

**올바르지 못한 선언** 
```cpp
int main()
{
  c = 256;

  char c = 0;

  return 0;
}
```

- 변수를 자료형과 함께 선언한 후 아래에서 사용가능함

___

- `=` 대입 연산자
  - 왼쪽의 값을 오른쪽의 값에 넣어 주는 연산자
- `==` 비교 연산자
  - 양쪽이 균등한지 물어보는 연산자

## 📍 **C/C++ 강의 3화. 정수형 자료형**

- 양수를 표현하는 자료형 앞에는 **signed** 키워드가 숨겨져있음
  - 굳이 안적어줘도 상관없음

**unsigned**
- 1 바이트로 양수만 표현
  - 256가지 -> 0 ~ 255

**signed**
- 1 바이트로 양수, 음수 둘다 표현
  - 256가지 -> -128 ~ 0 ~ 127 
  - **MSB (most significant bit) 최상위 비트**
    - 맨앞의 숫자가 0 일때 양수 로 표현 
    - 맨앞의 숫자가 1 일때 음수 로 표현

**음수의 동작방식**

- 2진수끼리의 덧셈
  - 각각의 두숫자의 자릿수의 합하여 올림
- 컴퓨터에서는 뺄셈이 없고 음수의 덧셈이라고 생각함
- `signed 기준)` 0111 1111(127) + 1000 0001(-127) = 0
- `signed 기준)` 0000 0001(1) + 1111 1111(-1) = 0

```cpp

unsigned char c;
c1 = 255 // 255 가 입력됨

char c1;
c1 = 255 // -1 이 입력됨
```

- 255가 2진수상으로 1111 1111 이 들어가고 signed 기준으로 이 값은 -1임으로 c1 에 -1이 입력됨
- c와 c1의 메모리 공간의 상태는 1111 1111로 똑같음!
  - 최상위 비트 를 사용한다 안한다의 차이

___

**음수값 찾는법**
- **2의 보수법**
  - 양수와 음수를 더했을때 0 이 나오는 수를 찾는것
  - 0을 1로 1을 0으로 바꾸고 1을 더해주면됨
  - 0000 0010 의 음수값은 1111 1110

**C++ 2진수 표기**

```cpp
int main()
{
	char c,d,k;

	c = 0b0000'0011; // 3
	d = 0b1111'1101; // -3

	k = c + d; // 0

	return 0;
}
```

- **"0b숫자(2진수)"** 
- **"0숫자(8진수)"**
- **"0x숫자(16진수)"**

- 자릿수 표기법  
  - 숫자 사이사이에 `'` 를 넣어주면됨

___

**값의 표현 범위**

- byte 가 늘어날수록 기하급수적으로 값의 표현 범위가 늘어감
- 1 Byte (2^8) 256 가지 → 2 Byte (2^16) 65536가지 → 4Byte (2^32) 4,294,967,296 가지 

## 📍 **C/C++ 강의 4화. 실수형 자료형**

- 정수형, 실수형데이터를 나누는 이유는 **처리하는 방식**자체가 다르기때문
- 정수형데이터는 비트라는 한정적 공간안에서 2진수로 대응되는 숫자로 표현함 
  - 경우의 수 자체가 한정적임
- 실수는 무한으로 만들어 낼수 있기때문에 한정적으로 비트값을 대응 시킬수 없음 
  - 부동 소수점이라는 표현방식을 사용함

- 정수 4 와 실수 4.0 는 컴퓨터에서 저장되는 방식은 완전히 다름 
  - `int a = 4 + 4.0` 4.0 이 4로 형변환 연산이 들어간뒤 계산됨
  - 정수, 실수의 혼합된 계산방식은 의도치않은 상황이 발생될수 있기 때문에 피하는것이 좋음

**부동소수점**
- float 보다 double 이 정밀도가 더 좋음
  - 4비트의 float 보다 8비트의 double 이 더 가까운값을 표현할수 있기때문임 

- 컴퓨터에서의 부동소수점 방식
  - 소수점 뒷자리는 2^-1(1/2) → 2^-2(1/4) → 2^-3(1/8) 이런식으로 내려감 
  - 0.8125(10진법) → 11010(2진법) 으로 변환할수 있음
    - 11010 이라는 비트를 정규화 시키기위해서 2^5(101)을 곱해줌

- 부호비트,지수 파트,가수 파트로 나늘수 있음
  - 부호비트: 맨첫째 자리로 양,음 을 구분하는 용도로 사용
  - 지수 파트: 소수점을 정규화 시킬때 곱해준 비트를 표현
  - 가수 파트: 정규화 시킨 파트의 비트

___

**명시적 형변환**
- 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 연산자가 연산될 경우 명시적으로 변환하자
  - `float f = 10-.2415f + (float)20;`

## 📍 **C/C++ 강의 5화. 산술 연산자**

- `;` : 컴파일러가 컴파일할때 문장의 마감을 표현해줌 
- 산술 연산자
  - `+` 
  - `-`
  - `*`
  - `/`
  - `%` (모듈러스, 나머지)
    - 피연산자가 모두 정수인경우 사용가능

- 증감 연산자
  - `++`
  - `--`

- 대입 연산자
  - `=`

- **연산자 우선순위**
  - 연산자들이 나열되었을때 연산자 우선순위에 따라 연산순서를 정함

___

```cpp
int data = data + 20; // 1
data += 20 // 2
```

- 1과 2는 동일하게 작동함

___

- 피연산자: 연산의 대상이 되는 데이터
- 나누기 연산시 피연산자가 정수인지 실수였는지에 따라 두가지 결과가 발생함
  - 실수가 끼어있는 `%` 연산은 문법오류가 발생함
  - 정수끼리의 나머지 연산시에는 경고가 발생할수 있음
    - 대입연산시 상수값이 잘리기때문에 경고가 발생함 따라서 형변환을 해주는것이 좋음

___

```cpp
float data = 20.f; 
double data = 20. ;
```

- float 은 숫자뒤에 `.f` 를 붙여주고 double은 `.`을 붙여줌
- 실수를 상수로 적을 경우 소수점 뒤에 f 를 붙이면 float 자료형으로, f 를 붙이지 않으면 double 자료형으로 간주한다.

## 📍 **C/C++ 강의 6화. 증감 연산자**

- 증감 연산자
  - `++`
  - `--`

- 다음단계로 증감해주는 연산자
- 일반적인 숫자타입에선 +1 -1 증감

```cpp
int data;
++data // 전위(전치)
data++ // 후위(후치)
```
- 위치에따라 연산되는 순서가 달라짐
- 연산자 우선순위가 달라짐
  - **후위로 갔을경우 모든 연산자 우선순위 최하위가 되어 제일 나중에 수행됨**
- data라는 변수안에 실제값이 증가함
  - 다른 메모리 공간에서 data + 1 이 되어 대입되는 것이아님!
- 특별한사유가 없는한 전위 연산자로 사용하는것이 좋음
  - 연산자 오버로딩때 클래스나 구조체의 오퍼레이터라는 함수를 실수로 호출할수 있음

## 📍 **C/C++ 강의 7화. 논리 연산자**

- 참(true), 거짓(false)
  - 0 이 아닌 모든수를 참으로봄
    - 다만 컴퓨터에 true을 요청하면 1이 나옴
  - 대표적으로 1을 참이라고 봄
  - c++ 에서 true나 false 를 키워드로 줌
- `!`
  - 역
  - 참을 거짓으로, 거짓을 참으로 바꿔줌
- `&&`
  - 곱 ( and )
  - 둘다 참이면 참, 둘 중 하나라도 거짓이면 거짓
- `||`
  - 합 ( or )
  - 둘다 거짓이면 거짓, 둘 중 하나라도 참이면 참

___

**bool 자료형**
- 1 byte 자료형
- true나 false 만 나타내는 자료형
- 굳이 따지자면 정수형 자료형에 속함

## 📍 **C/C++ 강의 8화. if / else 구문**

**비교연산자**
- `==`
  - 왼쪽 값 과 오른쪽 값이 같은지 물어보는 연산자
- `!=`
  - 왼쪽 값 과 오른쪽 값이 다른지 물어보는 연산자 
- `<`
  - 왼쪽값이 오른쪽 값보다 작은지 물어보는 연산자
- `>`
  - 오른값이 왼쪽 값보다 작은지 물어보는 연산자
- `<=`
  - 왼쪽값이 오른쪽 값보다 작거나 같은지 물어보는 연산자 
- `>=`
  - 오른값이 왼쪽 값보다 작거나 같은지 물어보는 연산자

___

```cpp
int data;
if(조건식) // 조건식 true or false 가 들어옴
{
  // () 안에 값이 참이라면 실행됨
}
else if () // if 가 false 라면 실행됨
else
{
  // () 안에 값이 거짓이라면 실행됨
}
```

- `if()`
  - () 안에 값이 true 면 {} 안에 구문이 실행됨
  - 수행안될 구문은 컴파일러가 삭제시켜줌
- `else if` 
  - if 안에 값이 거짓이면 확인하는 구문
  - else if 구문으로는 동시입력을 받을수 없기때문에 캐릭터 입력등은 if 문 여러개로 짜야함
- `else`
  - if 나 else if 구문중 아무것도 걸리지 않았을 경우 실행되는 구문
  - 없어도 상관없음

## 📍 **C/C++ 강의 9화. switch 구문/ 삼항 연산자**

```cpp
switch(10)
{
  case 10:
    // 실행
    break;

  case 20:

    break;

  case 30:

   break;

  default: 
    break;
}
```

- switch(): () 안에 조건과 case 앞에 조건을 비교하여 맞는 조건을 실행시켜줌

- case 구문중 맞는게 없는경우 default 가 실행됨

- 문법적으로 if 문과 거의 다르지않음
  - switch-case문은 변수나 특정값을 넣어주는 경우 표현이 힘든경우가 있음
  - if 문은 코드 가독성이 떨어지는 경우가있음

- break 가 없으면 밑에있는 구문까지 break를 만나는 라인까지 실행시켜줌
  - 공통적으로 똑같은 조건에서 실행시키고 싶은 경우가 있기 때문에 문법오류로 안잡아줌

___

```cpp
int iTest = 10;
if(1 || iTest == 20 || iTest == 30)
{

}
```

- 위와같이 `||` 연산자 연산중 앞에 1이 발견되어 조건이 참인경우 `iTest == 20 || iTest == 30` 는 실행되지 않음

___

**삼항 연산자**

```cpp
iTest == 20 ? iTest = 100 : iTest = 200;
```

- iTest 가 20 이라면 100을 넣고 20이 아니라면 200을 넣는 코드
- ? 왼쪽값에 참인지 물어보고 참이면 왼쪽이 실행 거짓이면 오른쪽이 실행
- 가독성이 떨어짐

```cpp
if(iTest == 20)
{
  iTest = 100;
}
else
{
  iTest = 200;
}
```

- 삼항 연산자코드를 if else 문 으로 바꾼 코드
  
## 📍 **C/C++ 강의 10화. define / 비트 연산자 (1)**

```cpp
unsigned char byte = 1;
byte <<= 3; // 8
```

- **비트 연산자:** 비트단위로 연산이 진행될때 사용되는 연산자
- 비트 쉬프트
  - 비트를 화살표가 가르키는 방향으로 한칸씩 밈
  - `>>`
  - `<<`

- 2진수에서 한칸 올라간다는것은 2배가 올라간다는것과 같음

**홀수의 비트쉬프트**

```cpp
unsigned char byte = 13;
byte >>= 1; // 6
```

- 홀수를 나누면 몫만 취하게됨
- 나머지는 오른쪽으로 밀리면서 소실됨

___

**비트 단위 연산**

- 비트 자리대로 비트끼리 연산하는 것

- **비트 곱(`&`)**
  - 비트 단위 기준 둘다 1일경우 1이 나옴
- **비트 합(`|`)**
  - 비트 단위 기준 둘중 하나라도 1일경우 1이 나옴
- **xor(`^`)**
  - 비트 단위 기준 둘다 같으면 0, 다르면 1이 나옴
- **반전(`~`)**
  - 1은 0으로 0은 1로 반전시켜줌

___

**전처리기**

- `#` 이 붙은 모든 구문을 컴파일 시 제일 먼저 처리해줌
- `#defind`
  - 내가 지정한 구문을 특정 숫자로 치환해줌

**#defind 예제**

```cpp
#define HUNGRY 1

int main()
{
	int iStatus = HUNGRY;

	return 0;
}
```

**전처리기의 장점**
- 가독성이 좋아짐
- 코드 유지보수가 좋아짐

## 📍 **C/C++ 강의 11화. 비트 연산자 (2)**

- 비트 연산으로 상태를 표현할수 있음
  - 겹치지 않는 자리로 상태를 나타낼수있음 즉 8비트 = 32가지상태를 나타낼수 있음

```cpp
#define HUNGRY 1
#define THIRSTY 2
#define TIRED 4

int main()
{
	unsigned int iStatus = 0;

	// 상태 삽입
	iStatus |= HUNGRY;
	iStatus |= THIRSTY;
	iStatus |= TIRED;

	if (iStatus & THIRSTY) // 상태확인
	{

	}

	//특정 자리 비트제거
	iStatus &= ~THIRSTY;

	return 0;
}
```
___

**16진수**

```cpp
#define HUNGRY  0x001 // 1
#define THIRSTY 0x002 // 2
#define TIRED   0x004 // 4
#define FIRE    0x008 // 8

#define COLD    0x010 // 16
#define POISON  0x020 // 32
#define POISON1  0x040 // 64
#define POISON2  0x080 // 128

#define POISON3  0x100 // 256
#define POISON4  0x200 // 512
#define POISON5  0x400 // 1024
#define POISON6  0x800 // 2048
```

- 16진수의 각자리수를 2진수로 변환하고 10진수로 보면 편함
- 0x100 (16진수)
  - 0001 0000 0000 (2진수)
  - 256 (10진수)


## 📍 **C/C++ 강의 12화. 변수**

1. 지역변수
   - 함수안에 들어있는 변수를 지칭함
   - `{}` 안쪽에 선언되어있는 변수
2. 지역변수
   - 함수 바깥에 선언되어 있는 변수 
3. 정적변수
4. 외부변수

**함수**
- 하나의 기능을 정의해 놓는것
- 기능의 모듈화
  - 작은 기능들을 모아 큰 기능을 만드는 것
  - 하나의 기능을 명확하고 잘 쪼게놓아야함

```cpp
int Add(int left, int right)
{
	return left + right;
}

int main()
{
  data = Add(10, 20);
}
```

1. 반환 타입 작성
   - `int`
2. 함수 이름 정의
   - `Add`
3. 인자 설정
   - `int left, int right`   
   - 이 인자들도 Add 라는 함수 안의 지역변수임

___


**변수명 규칙**
- 이름을 하나 줬는데 똑같은이름으로 변수를 짓게되면 모호성이 생김 컴파일 에러 발생
  - 지역변수안에 똑같은 변수명을 짓게되면 지역변수안에 있는 변수를 우선으로 할당해줌
  - 쉽게 말해 범위가 작은 변수를 우선적으로 할당하게됨
  - 지역 변수는 자기 지역을 벗어나게되면 사라짐

```cpp
int main()
{
  int test = 0;

  {
    int test = 100;

    test // 100 짜리 test
  }

  test // 0 짜리 test
}
```

## 📍 **C/C++ 강의 13화. 함수 (1) / 반복문**


- 프로그램의 정체는 함수의 호출임 main 함수를 호출 시키는 것
- 반복문이 돌면서 main함수를 유지시키고 특정 조건이 만족되었을때 main함수가 종료되어 프로그램이 종료되는 것
- VS 에선 디버깅 모드에서는 중단점에 걸려 현재 진행중인 코드를 확인할수 있음

**반복문**
- 어떤 조건을 주고 충족될때까지 코드를 반복하는것

**for()**

```cpp
for (/*반복자 초기화*/ ; /*반복자 조건 체크*/; /*반복자 변경*/ )
{

}

for (int i = 0; i < 2; ++i)
{
  printf("Output Test\n");
}
```

- 반복자 초기화 구문: for문이 시작될때 한번만 실행되는 용도로 실행됨
- 반복자 조건 체크: true or flase 입력을받음 true 인 경우에만 구문이 실행됨
- 반복자 변경: for문 {} 구문 수행 후 실행되는 부분

**while()**

```cpp
while(/*조건 체크*/)
{

}

int i = 0;

while(i < 2)
{
  printf("Output Test\n");
  ++i;
}
```

**반복문 내부 키워드**
- for문 while 문 둘다 사용가능함
- `continue`
  - 구문 수행중 continue 를 만나게되면 이번 구문은 스킵하고 다음 구문으로 넘어가게 되는 키워드
- `break`
  - 구문 수행중 break 를 만나게되면 반복을 끝내고 탈출하게 됨

___

**입출력 함수**

- 내가 만든 함수가 아니기때문에 `#include <stdio.h>` 표준 입출력 함수를 참조해야함

```cpp
printf("Output Test\n");
```

- `printf();`
  - 문자열을 입력하고싶을땐 `""` 안에 텍스트를 적어 주면됨
  - `"\n"` 개행 문자로 커서가 다음칸으로 넘어가게됨
- `scanf();`

## 📍 **C/C++ 강의 14화. Visual Studio 단축키 및 편의 사항**

**단축키**
- VS 설정도구에서 커스터마이징 가능함

- 지정한 구문 주석
  - `Ctrl + k, c`
- 지정한 구문 주석 해제
  - `Ctrl + k, u`
- 최근의 했던 작업 되돌리기
  - `Ctrl + z`
- 원하는 부분만 선택할수 있음
  - `Alt + Drag`
- 함수의 선언 또는 정의로 이동
  - `함수 선택후 F12`

<br><br/>

**디버깅**

- 디버깅 시작
  - `F5`
  - **디버깅중, 다음 중단점까지 코드 실행**
- 중단점 생성, 삭제
  - `F9`
  - 중단점 부분 코드 직전에 멈춰줌
- 디버깅 중, 구문 수행
  - `F10`
  - main 함수의 한단계가 수행됨
  - 프로시저 단위 기능단위 라고도함
- 디버깅 중, 구문 수행(함수 진입)
  - `F11`
  - 아주 작은 단위에 코드씩 실행됨
  - 한 단계씩 코드 실행
- 디버깅중, 디버깅 종료하기
  - `Shift + F5`

<br><br/>

**디버깅 창**

- 로컬
  - 디버그 - 창(W) - 지역(L) 
  - 메인함수는 실핼될때 구문이 아직 실행되지 않아도 선언해놓은 지역 변수의 메모리는 미리 잡혀있음 
  - 현재 중단점이 걸려있는 메인함수의 지역 변수를 다 보여줌
  - 커서로 변수에 올려놔도 보임
  - 변수 초기화 전엔 쓰레기값이 들어가있음 
- 조사식
- 호출 스택
  - 디버그 - 창(W) - 호출 스택(C) 

<br><br/>

**윈도우 단축키**

- 복사
  - `Ctrl + c`
- 붙여넣기
  - `Ctrl + v`
- 잘라내기
  - `Ctrl + x`

## 📍 **C/C++ 강의 15화. printf / scanf 문자 입출력**

- 콘솔창
  - 콘솔: 입력, 출력 장치
  - 윈도우 기준 **명령 프롬프트** 창 os 마다 명칭이 다름
- vs 프로젝트 시작시 명령 프롬프트 창으로 실행 으로 설정하였기 때문에 
main 함수가 실행되면 명령 프롬프트 창이 열리게 되는 것

- `#include`
  - 컴파일 전에 다른 헤더파일을 포함하여 사용하겠다는 전처리기

- `printf()`
  - 콘솔창에 문자를 출력
  - `printf("abcdef\n");` `""` 안에 문자를 출력하고 `\n` 줄바꿈 하겠다는 구문
  - 치환문자 `printf("%d", 10);` 
    - 정수형 데이터 `%d` 치환문자 자리에 문자로 대체해주는 것
    - 실수형 데이터 `%f`

```cpp
int iInput = 0;
scanf_s("%d", &iInput);
```

- `scanf()`
  - 콘솔창으로 부터 입력을 받음
  - `scanf_s("%d", &iInput);` 
    - 입력받을 데이터 타입과 변수의 주소를 넘겨줘야함
  - scanf 내부에서 입력이 들어올때까지 무한루프를 돌고있는 것
  
## 📍 **C/C++ 강의 16화. 함수 (2)**

- 함수 안에서 함수를 호출하여 최종적으로 main함수로 돌아옴
  - 자료구조 스텍과 유사함
  - 이전에 호출한 함수가 종료되야 현재 함수가 종료될수있음


**자료구조 Data structure**
- 어떤 데이터를 관리함에 있어 어떠한 구조로 데이터를 효율적으로 관리 하고 처리하는지 연구하는 학문
- 스텍 : 후입 선출 구조
- 큐 : 선입 선출 구조

___

**함수가 사용하는 메모리 영역**
- **스택 메모리 영역**
  - main함수가 실행되는 순간 모든 변수들이 담길 공간을 마련함
     - main함수뿐 아니라 모든 함수에 적용되는 사항임 
  - main 함수실행에 필요한 데이터가 100Byte 라면 main함수 처음 실행시 100Byte 공간을 잡음 메인함수가 다른 함수를 호출하면 그 순간 다른 함수를 호출하면 그 함수에 필요한 데이터를 잡고 함수가 종료될때 데이터를 삭제함
 - 현재 지칭하는 함수명이 다르기때문에 함수별로 같은이름의 변수명을 지을수 있는 것임

___


**코드 != 메모리 영역**
- 코드는 명령어
- 함수는 명령어의 집합
- 메모리 영역은 코드를 수행했을때 수행되는 영역

## 📍 **C/C++ 강의 17화. 함수 (3)**

**계승 (Factorial)**
- `n!` 으로 표현
- 각 자리 숫자들의 최종 곱

**계승 코드**

```cpp
int main()
{
	int i = 4;

	int iValue = 1;

	for (int j = 0; j < i - 1; ++j)
	{
		iValue *= (j +2);

	}

	return 0;
}
```

- i 값만 바꾸면 특정 계승값을 알아낼수있음

**계승 코드의 모듈화**

```cpp
int Factorial(int _iNum)
{
	int iValue = 1;

	for (int j = 0; j < _iNum - 1; ++j)
	{
		iValue *= (j + 2);
	}

	return iValue;
}

int main()
{
	int iValue = Factorial(4);

	iValue = Factorial(10);

	return 0;
}
```

- 함수를 사용하는 이유
  - 하나의 기능 단위를 함수로 구현해놓고 계속 재활용 하기 위해서
- 행동집합을 하나만두고 필요할때마다 지침을 읽고 사용하는 것
- 복잡한 기능을 만들때 기존에 만들어둔 함수들의 조합으로 만들수 있음

## 📍 **C/C++ 강의 18화. 재귀 함수 (1)**

**재귀 함수**
- 함수안에서 자기 자신과 동일한 함수를 호출하는 것
- 무조건 **탈출 조건**이 필요함

**재귀 함수의 장점** 
- 가독성, 구현의 용이
- 계층구조 표현이 재귀 함수가 좋음

**재귀 함수의 단점** 
- 반복문 등으로 대체 표현이 가능하지면 반복문으로는 가독성, 구현이 좋지못함
- 실수할 여지가 있음
- 성능이 많이 떨어짐
  - 여러번의 함수를 호출해서 마치 변수처럼사용하기 때문에 호출, 회수 비용이 들기에 성능이 떨어짐


**디버깅 툴**
- **호출 스택:** 호출된 함수의 순서대로 보여줌 
  - **디버깅시 호출스택의 함수를 클릭하면 클릭한 함수의 상태를 확일할수 있음**
- **로컬:** 현재 호출된 함수의 지역변수들을 보여줌
- VS 의 호출 스택, 로컬, 조사식을 잘 사용하면 문제점을 발견할때에 문제를 찾기가 쉬움
- 지역 변수는 현재 호출된 함수가 사용될 메모리를 갖고있음
- 스택 메모리 영역: 함수가 사용하는 메모리영역

**함수 동작 순서**
- cpu에 레지스터라는 빠르게 접근할수있는 메모리 공간에 잠시 받아두고 함수메모리 해제하고 리턴값을 사용함 


**재귀 함수의 스택 메모리**
- 함수가 계속 실행되어 스택 메모리에 계속 호출되어 쌓이는 방식임
- 한계치에 도달하면 **스택 오버 플로우** 라는 에러가 발생함

## 📍 **C/C++ 강의 19화. 재귀 함수 (2)**

- C/C++ 처음 공부시 그림이나 펜으로 변수 메모리공간을 직접 구상화하면서 연습하는것이 좋음

- 재귀 (Recursion)
- 자료구조 등은 영어 단어로 찾아두는것이 좋음

**재귀 함수**

```cpp
int Factorial_Re(int _iNum)
{
	if (1 == _iNum)
	{
		return 1;
	}
	
	return _iNum * Factorial_Re(_iNum - 1);
}

int main()
{
	int iValue = 0;

	iValue = Factorial_Re(7);

	return 0;
}
```

- 10부터 시작해서 1이될때까지 호출을 계속하다가 1을만나면 1을 리턴하는 재귀함수 코드

<br><br/>

**Fibonacci sequence(피보나치 수열)**

- 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열

```cpp
// 1 1 2 3 5 8 13 21 34 55 89
int Fibonacci(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	int iPrev1 = 1;
	int iPrev2 = 1;
	int iValue = 0;

	for (int i = 0; i < _iNum - 2; ++i)
	{
		iValue = iPrev1 + iPrev2;
		iPrev1 = iPrev2;
		iPrev2 = iValue;
	}

	return iValue;
}

int main()
{
	int iValue = Fibonacci(10); 

	return 0;
}
```

1. 두 변수 공간에 iPrev1, iPrev2에 각각 1을 넣어두기
2. iPrev1 + iPrev2 값을 iValue 넣기
3. iPrev2 값을 iPrev1 에 넣기
4. iValue 값을 iPrev2 에 넣기

- 이런식으로 `_iNum - 2` 번 반복하면 `_iNum` 번째의 피보나치 수열을 구할수 있음 

**재귀 함수 버전 피보나치 수열**

- `f(n) == f(n - 1) + f(n - 2);`

```cpp
int Fibonacci_Re(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	return Fibonacci_Re(_iNum - 1) + Fibonacci_Re(_iNum - 2);
}

int main()
{
	int iValue = Fibonacci_Re(10); 

	return 0;
}
```

- 위 코드는 구현하기는 편하지만 성능이 매우떨어짐
  - 60번만 호출해도 2제곱승수로 호출이 늘어나기때문에 호출을 엄청많이하게됨
  - 꼬리 재귀 등으로 해결이 가능하긴함
- 피보나치 수열은 계층 구조를 표현할때 좋음
- 트리 자료구조 내부에 탐색, 후속자, 선행자를 찾을때 재귀 함수가 용이함

## 📍 **C/C++ 강의 20화. 배열**

- 배열을 제대로 알기위해선 포인터를 알아야함
- 포인터는 이해하는 것에 그치지 않고 많이 사용해봐야함

**배열 기본 문법**

```cpp
int main()
{
	int iArray[10] = {};

	return 0;
}
```

- `int iArray[10]` int 자료형 10묶음 의 이름은 iArray라고 지은것
- `{}` 각각 초기 요소들을 전부 0으로 초기화 하겠다는것

**인덱스 접근**

```cpp
int iArray[10] = {};
iArray[4] = 10;
```

- `[]` 안에값은 몇번째값이 아닌 **인덱스**임
- 최대 접근 가능 인덱스 는 **iArray[10]** 으로 초기화 했을때 **iArray[9]** 까지 가능함
- 배열의 범위를 초과하여 접근하는경우 에러가 발생할수도 안할수도있음 
- **배열은 메모리가 연속적인 구조**임

- 배열의 범위를 초과한다 == 내가 선언하지 않은 영역에 접근하는것과 같음
- 스택 메모리 영역에 배열의 범위를 초과된 부분이 다른 변수가 이미 할당받은 공간일경우 데이터가 덮어씌어질 위험성이 있음

## 📍 **C/C++ 강의 21화. 구조체**

**배열**
- 배열을 사용하는 이유는 동일한 자료형으로 변수를 한번에 여러개를 할당하고싶을때 한번에 묶어서 변수를 선언할수 있음
- 메모리구조가 연속적인 구조를 가짐
- 특정 요소로 접근할때 인덱스로 접근해서 값에 접근함
  - 초과된 값으로 접근할 경우 다른 변수가 갖고있던 영역에 침범할 가능성이 있음

**구조체 (user defined data type)**

- 사용자 정의 자료형
- **자료형:** 데이터 단위, 형태를 명시해주는것

```cpp
typedef struct _tagMyST
{
	int a;
	float f;
}MYST;

int main()
{
	MYST t;
	t.a = 10;        // 요소 접근
	t.f = 10.2312f;

	int iSize = sizeof(MYST); // 8

	return 0;
}
```

- int, float 을 묶어서 `MYST` 라는 이름으로 구조체를 만든것
- `sizeof()` () 안에 들어있는 변수나 자료형의 사이즈를 알려줌
  - `MYST`는 int, float 의 사이즈를 합쳐 8Byte 사이즈를 갖게됨
- int a, float f는 변수선언이 된것이 아닌 `MYST` 라는 사용자 정의 자료형의 형태를 알려준것임 
- `t.a` 을 찍어 접근할수 있음

___

**구조체의 확장**

```cpp
typedef struct _tagMyST
{
	int a;
	float f;
}MYST;

typedef struct _tagBig
{
	MYST k;
	int i;
	char c;
}BIG;

int main()
{
	MYST t;
	t.a = 10;
	t.f = 10.2312f;

	int iSize = sizeof(MYST); // 8

	return 0;
}
```

- 구조체가 다른 구조체를 갖고있는 형태로 확장될수 있음

**구조체의 구조**

**typedef** 

```cpp
typedef int INT;

int main()
{
    INT a;
}
```
 
- `typedef` 타입을 재정의 해주는 것
- 단순히 코드를 바꾸는 것이아닌 타입을 재정의 해주는 것이기 때문에 컴파일러가 INT 를 int로 봄 
- C++은 C에 기능이 추가되고 기존에있던 기능의 편리성이 추가되고 객체지향이 추가된것

___

**C 스타일의 구조체**

```cpp
struct NewStruct
{
	int a;
	short s;
};

int main()
{
	struct NewStruct a;

	return 0;
}
```

- C 에서는 구조체선언시 구조체 이름 뒤에 struct라는 키워드를 붙여줘야함
  - 구조체 들을 따로 모아두고 거기서 찾아서 사용하는 구조이기 때문임

**typedef 활용**

```cpp
typedef struct NewStruct
{
	int a;
	short s;
} NEWST;

int main()
{
	NEWST a;

	return 0;
}
```

- `struct NewStruct a;` 같이 문자가 길어지기 때문에 typedef 으로 NEWST 라는 새로운 이름을 지어주는 것


**C++ 스타일의 구조체**

```cpp
typedef struct NewStruct
{
	int a;
	short s;
} NEWST;

int main()
{
	NewStruct a;
  NEWST b;
  struct NewStruct c;

	return 0;
}
```

- C++ 에선 개선되어 NewStruct 만 써서 사용할수있음
- 윈도우 api 쪽 코드에선 대부분의 구조체들이 위와같은 형태로 구조체 선언이되어있음
  - C나 C++ 둘다 사용가능하게끔 범용성있게 짜놓은것

___

**구조체의 초기화**

```cpp
#include <stdio.h>

typedef struct _tagMyST
{
	int a;
	float f;
}MYST;


int main()
{
	int arr[10] = { 1,2,3,4,5,6,7 };
	MYST t = {1, 3.14f};

	return 0;
}
```

- 배열의 초기화 와 구조체의 초기화는 비슷함
  - 요소 하나하나 각각 초기화 해줄수 있음
  - `,` 이나 아무것도 안써줄경우 그 뒤에있는 요소들은 0 으로 초기화 됨

___

**VS 빌드제외**

- cpp 파일 우클릭 → 속성(R) → 구성 속성 → 일반 → 빌드에서 제외 → 예 체크
- 없는 파일로 취급됨

## 📍 **C/C++ 강의 22화. 지역 변수 / 전역 변수**

**변수의 종류**
1. 지역 변수 : 함수안에 선언된 변수
  - 해당 함수가 실행될때 스택메모리에 있다가 사라짐
2. 전역 변수 : 
  - 데이터 영역을 사용함
3. 정적 변수(static)
   - 데이터 영역을 사용함 
4. 외부 변수(extern)
   - 데이터 영역을 사용함

**데이터 영역**
- os 프로그램이 실행될때 부여하는 메모리영역을 개념적으로 지칭해서 나뉘는것
- os 등 마다 세분화해서 나뉠수 있음
- 가장 대표적으로 크게 분류하면 아래와같이 4가지로 나눌수 있음
- C++ 은 직접 메모리를 다루기때문에 자기가 작성하는코드의 메모리가 어떻게 사용되는지 정확히 알고 사용해야함

1. 스택 영역
   - 함수가 선언될때 사용되는 영역 
2. 데이터 영역
   - 전역 변수가 사용하는 영역
   - 프로그램이 시작 시 생성
   - 프로그램이 종료 시 해제  
   - main 함수와 다른함수 어디든 접근할수 있음
     - 함수의 호출과 해제와는 상관없이 프로그램 종료시까지 계속 존재하기 때문에 접근이 가능한것
3. 읽기 전용(코드, ROM)
4. 힙 영역

___

**전역 변수**

```cpp
int g_i;

void Test()
{
	++g_i;
}

int main()
{
	Test();
	Test();
	Test();

	return 0;
}
```

- 전역변수는 지역변수와 달리 스택메모리에 생겼다가 사라지는것이 아닌 데이터 영역에 존재하기 때문에 `Test()` 함수가 호출될때 마다 값을 누적하여 갖을수 있음 

## 📍 **C/C++ 강의 23화. 분할 구현**

- 함수의 반환타입이 없을때는 `void` 를 써줄수있음
- 다른파일에 구현해놓고 헤더 include 만 해놓으면 기능을 사용할수 있기 때문에 관리 하기 좋기때문에 분할 구현을 사용함
- 궁극적으로는 한파일에 몰아서 작업하는것이 성능이 더잘나옴
  - 링킹과정에서 성능이 떨어질수 밖에 없음
  - 사람이기때문에 한가지 파일에서 작업하는것은 현실적으로 불가능함

___

```cpp
int g_i;

int main()
{
	Test(); // 컴파일 에러
	Test(); // 컴파일 에러
	Test(); // 컴파일 에러

	return 0;
}

void Test()
{
	++g_i;
}
```

- 코드는 위에서 부터 순차적으로 분석을 함 
- 위 코드와 간이 Test 함수를 아래에 구현하게되면 찾을수 없어서 컴파일 에러를 발생하게 됨

**전방 선언**
```cpp
int g_i;

void Test(); // 전방선언

int main()
{
	Test(); 
	Test(); 
	Test(); 

	return 0;
}

void Test()
{
	++g_i;
}
```

- 나중에 컴파일 시 링크단계때 전방선언된 함수들의 바디 부분을 찾아서 잡아주기때문에 전방선언을 해놓으면 그 아래에서 해당 함수를 사용할수 있는 것
- 에러 이름중 C 로 시작하는것은 컴파일 에러
  - 문법 등이 틀리면 컴파일 단계에서 에러가 발생함
- 전방선언만 해놓고 실제 body 를 구현해 놓지 않으면 **LINK ERROR** 가 발생함
  - 컴파일단계에선 에러가 발생되지않고 링킹 단계에서 에러발생됨

___

**#include**

- 명시되어있는 파일을 현재 파일에 복붙하는 것


**func.h**
```cpp
#pragma once


int Add(int a, int b);
```

- Add 라는 이름을 가진 함수이며 반환타입은 int 이며 int형 자료형 두개를 인자로 받는 함수가 있다고 선언만 해준것
- 기능은 구현은 하지않음


**func.cpp**
```cpp
#include "func.h" // 전방 선언 되어있는 헤더 참조

int Add(int a, int b)
{
	return a + b;
}  
```

**main.cpp**
```cpp
#include <stdio.h>
#include "func.h" // Add 함수가 전방 선언 되어있는 헤더 참조

int main()
{
  Add(1, 2);

	return 0;
}
```

- main 함수에서 전방 선언되어있는 헤더파일만 참조해도 Add 함수 기능을 사용할수 있는 이유
  - **링크 과정에서 엮어주기 때문임**
  - Add함수의 기능부분은 func.cpp 파일 이외에 main.cpp 파일에서 구현해도 상관은 없음 

## 📍 **C/C++ 강의 24화. 분할 구현의 문제점**

**cpp 와 헤더파일을 구분하는 이유**
- 헤더파일에 기능까지 구현해버리면 `#include` 허는 파일마다 기능 까지 복붙 되기때문에 **중복 구현 컴파일 에러**가 발생할수 있음
  - 문법상 구현은 딱 한번만 해야함 
  - 그러므로 선언만 헤더파일에 적어놓고 cpp 파일에만 기능을 구현해놓는는것
  - 다른파일에서는 참조할때 헤더파일만 참조하여 컴파일 오류를 피하는 방식

<br><br/>

- 컴파일 → 링크 → exe 파일로 코드가 하나로 합쳐져 어셈블리 코드로 바이너리화 까지 되어 합쳐짐
- **obj 파일** 단위로 컴파일이 진행되고 **obj파일**을 합치는게 링크 과정 

___

- 분할구현을 하게되면 전역변수의 장점이 없어져버림
- 전연변수는 현재 **선언된 파일에서만** 적용됨
  - 다른 cpp 파일들에선 사용할수 없음
- 나중에 컴파일 후에는 데이터영역에 있는 전역 변수를 알수 있지만 컴파일러는 문법적으로 개발 단계에선 전역 변수의 존재를 알수 없음  

___

**분할 구현시 전역 변수의 문제점 해결하기**
- 헤더파일에 전역변수 선언하기 ❌
  - `#include` 시 참조된 모든 파일에서 전역변수가 다중 선언되어 링킹 단계에서 에러가 발생함
- 이를 해결하기 위해 정적변수, 외부 변수가 존재함

## 📍 **C/C++ 강의 25화. 정적 변수 & 외부 변수**

- **VS 단축키:** 함수를 선택하고 F12 을 누르면 선언또는 정의로 이동할수 있음

**문제점: 변수를 모든 cpp 파일에서 사용하고 싶은 상황**

**정적 변수(static)**
- 데이터 영역 사용
- 선언되는 위치에따라 차이가 있음
  - static 키워드가 의미하는 뜻 자체는 변하지 않음
- 정적 이다 == 움직이지 않는다 라는 뜻
  - c,cpp 에서 정적이다 라는 뜻은 내가 생성된,선언된 곳에서만 있다는 뜻
- 문법적으로 다른데 에서 사용하지 못하도록 제한을 건 기능
  - 전역 변수는 다른함수에서 다 사용할수 있음
  - 현재 함수에서만 사용 가능한 변수가 필요하기 때문에 만들어진 것

<br><br/>

**함수 밖에 static 변수가 선언되는 경우** 
- cpp 파일 자체에 선언 되었다는 뜻임
- 각자 파일에서만 인식되는 변수임
- 각자 파일로 지칭되어 구분할수 있기때문에 같은 이름의 static 변수라도 에러가 발생하지 않는것임 

<br><br/>

**함수 안에 static 변수가 선언되는 경우** 
- 현재 함수 안에 존재함
- 함수 안이라도 스택 메모리 영역이 아닌 **데이터 영역** 사용함
- 즉 호출 스택안에 포함이 되어있지않음
- 선언된 현재 함수안에서만 사용가능하고 데이터 영역에 남아있는 변수

- 한마디로 정리 해서, **현재 함수에서만 사용가능 하고 함수의 호출과 종료와 관계없이 프로그램 종료 시까지 데이터를 유지할수 있는 변수 가 필요할때 사용함**
  - 문법적으로는 접근 불가, 포인터등으로 접근할수있는 방법이 있긴함

___

**main.cpp**

```cpp
#include <stdio.h>
#include "func.h"

// 전역 변수
int g_i = 0;

// 정적 변수
static int g_iStatic = 0;

int main()
{
	g_iStatic = Add(1, 2);

	return 0;
}
```

**func.cpp**

```cpp
#include "func.h"

// 전역 변수
int g_i = 0; // ❌ 중복선언 링킹단계에서 에러 발생

// 정적 변수
static int g_iStatic = 0; // ✔️

int Add(int a, int b)

```

- 각각의 파일에서만 사용 가능한 동일한 이름의 정적 변수를 만든것임 

___

```cpp
int Test()
{
	static int i = 0; // 최초 한번만 실행됨

	++i;

	return i;
}

int main()
{
	Test();
	Test();
	Test();
	Test();
	int iCall = Test();

	printf("%d", iCall); // 5

	return 0;
}
```

- 함수안에 static 변수를 선언하게되면 **최초 한번만 초기화되고 여러번 초기화 되지않음**
  - 어셈블리어 까지 확인하면 조건 처리 되어있어 최초 1회만 초기화 하고 건너뛰게끔 되어있음

___

**파일 끼리의 Static  변수**

**common.h**

```cpp
#pragma once

static int i = 0;
```

**func.h**
```cpp
#include "func.h"
#include "common.h"

int return_i()
{
	++i;
	return i;
}
```

**main.h**

```cpp
#include <stdio.h>
#include "func.h"
#include "common.h"

int Test()
{
	++i;

	return i;
}

int main()
{
	Test();
	Test();
	Test();
	Test();
	i = Test();

	printf("%d", i); // 5 Test() 에서만 존재하는 i의 값

  i = return_i();

  printf("%d", i); // 1 return_i() 에서만 존재하는 i의 값

	return 0;
}
```

- 한 파일에 static 변수를 선언하고 다른파일이 `#include` 하여 사용
- 전체적으로 통용되는 변수가 아닌 각각의 파일에서만 존재하는 변수인것을 확인 할수 있음

___

**외부 변수(extern)**

- 전체파일에서 사용가능한 변수를 만들때 사용하는 것

**common.h**

```cpp
#pragma once

static int i = 0;
extern int g_iExtern; // 모든 cpp에서 참조 
int g_iExtern = 0; // 전역 변수 초기화
```

- 헤더에 배치할때 절대 초기화를 하면안됨
- `extern int g_iExtern;` 변수를 선언한게아닌 있을거다 라고 알려주는 것
  - 어떤파일이던 상관없이 초기값을 한번 전역 변수로 초기화 해줘야함
  - 컴파일시 초기화 한번을 해줌으로써 사용가능하게끔 하는것

## 📍 **C/C++ 강의 26화. 운영 체제**

- VS 가 솔루션을 생성 → 프로젝트 생성 → cpp,h파일 생성
- 프로젝트가 빌드되면 프로그램이 생성됨
- 플랫폼: 하나의 실행 기반
  - 윈도우, 안드로이드, ios, 스팀 등등...
- 솔루션 플랫폼
  - 32bit, 64bit **데이터를 처리하는 단위를 뜻함**
  - 32bit 버전
    - 이름이 x86 인이유 32비트 시절 cpu이름이 x86 이여서 이름이 굳어진것
  - 64bit 버전


**요즘 게임의 최소사양이 64bit 인 이유**

- 최근 사양의 게임들은 메모리 사용이 커지면서 32bit를 사용하면 즉, 데이터 처리 단위가 작아지면 메모리 처리가 문제가 생김 
- 32bit 를 사용한다는건 pc 성능이 좋아도 머리가 안좋은거랑 같음

## 📍 **C/C++ 강의 27화. 포인터**

- 포인터 : 주소를 가르키는 기능 
- 포인터 변수 : 주소를 가르키는, 저장하는 변수

```cpp
int* pInt = nullptr;
```

- `nullptr` 0 과 같음
  - 이 포인터가 아무것도 가르키지 않는다는 의미로 넣어줄때 사용
  - 실제 들어간 데이터는 0

```cpp
int i = 100;
int* pInt = &i;
```

- 자료형에 `*` 를 붙이면 해당 자료형을 가르키는 포인터 변수를 만들수있음
- 포인터 변수에 는 같은 자료형의 주소를 저장할수 있음

- **주소**
  - 메모리안에 데이터들을 개념적으로 구분하는 공간
  - 컴파일된 코드들은 특정 주소 위치에 값을 넣도록 명령어가 만들어짐 메모리의 위치를 지정하기 위해서임
  - 포인터는 저레벨의 기능임 주소를 가르키고 접근하고 값을 넣는 것 

**포인터 변수로 i값 수정하기**

```cpp
int i = 100;
int* pInt = &i;

// 주소로 접근
(*pInt) = 200; // i = 200;

```

- `*pInt` 포인터 변수앞에 `*` 를 붙이면 현재 저장되어있는 주소값을 **참조** 하겠다는 뜻

___

- 주소를 표현하는 방식은 **정수타입**임
  - byte 단위로 주소에 저장하기때문임
  - 100번지 - 101번지
    - 100.1 번지 ❌
- **주소의 단위**
  - 1 byte 단위로 존재함

___

```cpp
int main()
{
	int i = 100;
	float f = 3.1f;
	int* pInt = (int*)&f; // float 값을 int* 로 강제 형변환

	i = *pInt; // 1078355558

	return 0;
}
```

**포인터 변수앞에 자료형을 써주는 이유**

- **해당 포인터에게 전달된 주소를 해석하는 단위**

- 주소에 가서 int 형만큼의 사이즈 즉 4byte 만큼 접근하겠다는 뜻으로 int를 써주는 것임
- 정수형, 실수형 데이터 자료형을 구분하기 위함임
- `int*` 포인터 변수에 접근할때 해당 주소로 접근한뒤 **정수형 데이터 타입으로 값을 해석해서** 보겠다는 뜻
- `i = *pInt; // 1078355558` 부동 소수점으로 저장되어있는 실수형 데이터를 **int\* 포인터 이기때문에 정수형 데이터 타입으로 값을 해석**해서 이상한 값이 들어간것


**중요한 개념**
- 데이터는 메모리를 바라보는 해석에 관점에 따라 값이 다르게 나옴
  - `signed`, `unsigned` 
  - `int*`, `float*`

## 📍 **C/C++ 강의 28화. 포인터 배열**

- 포인터 변수
  - 변수이기때문에 무언가를 저장할수 있음
    - 주소를 저장함
  - 앞에 써져있는 자료형을 보고 접근한 주소의 데이터를 해당 자료형으로 보겠다는 것
    - 포인터 변수는 접근한 주소의 실제 데이터가 어떤 것이든 상관하지 않고 자기 앞에 써져있는 자료형으로 봄
  - `nullptr` 메모리상으로 0 를 뜻함
  - 컴파일러는 문법적으로 같은 자료형으로 맞춰주도록 도와줌

**포인터 변수의 크기**

- 포인터 변수의 크기는 고정이 아닌 플랫폼에 따라 가변적으로 설정됨
  - 32Byte 면 4Byte
  - 64Byte 면 8Byte
- 32bit 
  - 4Byte 단위로 데이터를 처리함
  - 4Byte 는 처리할수있는 데이터 단위가 2^32 으로 약 42억 가지 수 나옴
    - **4GB = 약 42억 가지수** 
- 64Bit
  - 8Byte 단위로 데이터를 처리함
  - 접근가능한 주소의 크기가 `2^64 bit` 라는 것 
    - `1.8446744e+19`
  - os 가 처리하는 최대 크기가 8Byte 임으로 포인터 변수의 크기가 8Byte 로 설정되는것

```cpp
int main()
{
	int* pInt = nullptr;
	char* pChar = nullptr;
	short* pShort = nullptr;
	

	return 0
```
- 위 세개의 포인터 변수는 **크기가 같음**
- 포인터 변수는 주소를 저장하는 변수로 용도가 다 같기때문에 크기는 똑같음

___

**주소의 증감 단위**

```cpp
#include <stdio.h>

int main()
{
	int* pInt = nullptr;
	char* pChar = nullptr;
	short* pShort = nullptr;

	int i = 0;
	pInt = &i; // 주소가 100번지라고 가정

	pInt += 1; // 104 번지
	

	return 0;
}
```

- `pInt += 1;` 주소를 하나 증가 하라는 뜻
  - 주소하나를 증가하라는건 절대적인값 1이 아닌 해당 자료형의 다음 주소로 가라는 것
- 주소의 증감 단위 는 해당 포인터 변수가 가르키려고하는 자료형 단위로 움직임
  - `int*` 이면 4Byte
  - `Char*` 이면 1Byte

<br><br/>

- **pInt 는 int* 변수 이기 때문에, 가리키는 곳을 int 로 해석한다.**
- **따라서 주소값을 1 증가하는 의미는 다음 int 위치로 접근하기 위해서 sizeof(int) 단위로 증가하게 된다**

___

**배열의 특징**
1. 메모리가 연속적인 구조이다.
2. 배열의 이름은 배열의 시작 주소이다.

```cpp
int main()
{
	int iArr[10] = {};
	
  // int 단위로 접근 1번째 칸에 10을 넣겠다는 뜻
	*(iArr + 0) = 10;
	// int 단위로 접근 2번째 칸에 10을 넣겠다는 뜻
	*(iArr + 1) = 10;

	return 0;
}
```

- `\*(변수 + x) = 변수[x]`
  - 배열의 특정인덱스 주소 접근의 정체는 포인터 주소의 증감으로 접근하는 것
- 배열의 처음 인덱스를 0으로 보는 이유가 위와 같은 이유임

## 📍 **C/C++ 강의 29화. 포인터 문제 풀이 & 해답**

```cpp
#include <stdio.h>

int main()
{
	// 포인터 이해 확인 문제
	// 문제 1.
	short sArr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	int* pI = (int*)sArr;

	int iData = *((short*)(pI + 2));

	printf("1번 문제 정답: %d", iData);

	// 문제 2.
	char cArr[2] = { 1,1 };

	short* pS = (short*)cArr;

	iData = *pS;

	printf("2번 문제 정답: %d\n", iData);


	return 0;
}
```

**문제 1번 풀이**

1. `short sArr[10] = { 1,2,3,4,5,6,7,8,9,10 };` Short 자료형 2Byte 크기를 10개 가진 배열 선언
2. `int* pI = (int*)sArr;` short 배열을 int 형으로 강제 캐스팅
3. `int iData = *((short*)(pI + 2));`
   1. `(pI + 2)`  강제캐스팅되어 int 형 자료형의 크기만큼인 4byte 만큼 2번의 주소만큼 이동하여 8byte 가 이동됨
   2. `(short*)` iData 에 넣기 전에 short 단위 크기로 넣어진 데이터를 가져오기 위해 다시 short 형으로 강제 캐스팅 
   3. `*()` short 크기로 강제 캐스팅된 주소를 참조하여 가져옴 
4. 8byte 만큼 이동된 위치에 있는 값인 5 가 출력되는 것

<br><br/>

**문제 2번 풀이**

1. `char cArr[2] = { 1,1 };`  char 자료형 1byte 의 크기를 2개 가진 배열이 생성됨
2. `short* pS = (short*)cArr;` short 형으로 강제 캐스팅
3. `iData = *pS;` 주소 접근시 short 형자료크기인 2byte 만큼의 크기를 참조하게됨
  - 비트로 표현 하게되면 `0000'0001 0000'0001` 을 한덩어리로 보게됨
4. `0000'0001 0000'0001` 를 1Byte 씩 보게 되면 각각 1이지만 2Byte 로 한꺼번에 보면 257 값임 으로 257이 출력되는 것

___

**함수에 변수 주소값 넘겨주기**

```cpp
#include <stdio.h>

void Test(int* a)
{
	*a = 500;
}

int main()
{
	int a = 100;

	Test(&a);

	printf("%d", a); // 500

	return 0;
}
```

- 기본적으로 함수에서 선언된 변수는 스택메모리에 생성되어 변수의 종료와 함께 사라짐
- 위 코드와 같이 main 함수의 존재하는 a라는 변수의 주소값을 Test() 함수에 넘겨주고 그 주소값에 포인터로 접근하게 값을 변경하게되면 main 함수에 있는 a의 값이 변경됨
  - a라는 변수의 메모리에 직접 접근하는 것이기 때문에 값이 변경되어 유지될수 있는것임

___

**scanf가 주소를 요구하는 이유**

```cpp
int a = 0;
scanf("%d", &a);
```

- 콘솔창에서 입력받은 값을 a라는 변수의 메모리에 직접 접근하여 저장하기 위해서 변수의 주소값을 인자로 받는 것
- `"%d"` 데이터 타입을 알려주는것

___

**컴퓨터의 데이터 저장 방식**

![image](https://user-images.githubusercontent.com/90514882/181777772-b981e46d-dc3b-4a7e-85f5-167f97357c71.png)

- 엔디언(Endianness)은 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 특히 바이트 순서(Byte order)라 한다.

- 엔디언은 보통 큰 단위가 앞에 나오는 **빅 엔디언(Big-endian)**과 작은 단위가 앞에 나오는 **리틀 엔디언(Little-endian)**으로 나눌 수 있으며, 두 경우에 속하지 않거나 둘을 모두 지원하는 것을 미들 엔디언(Middle-endian)이라 부르기도 한다.


## 📍 ***C/C++ 강의 30화. const*

```cpp
int main()
{
  // l-value : 변수
  // r-value : 상수
  const int cint = 100; 

  return 0;
}
```
- 변수앞에 const 키워드를 붙이게 되면 **상수화**가 됨
  - **상수화: 값을 바꿀수 없게 되는 것**
- 상수화 된 값을 r-value 라고함
- 바뀔수 있는 값들을 l-value 라고함

<br><br/>

- cint 는 main() 함수의 스택 메모리에 int 만큼의 공간을 할당받고 100이라는 값을 갖고 있으며 **값을 수정하는건 안된다고 문법적으로 막혀 있는상태**
  - 실제로 cint 라는 게 100으로 바뀐 것이 아님!

___

**const 포인터로 접근해서 값 바꾸기**

```cpp
#include <stdio.h>

int main()
{
	volatile const int cint = 100;

	int* pInt = (int*)&cint;
	*pInt = 300;

	printf("%d", cint); // 300

	return 0;
}
```

- `volatile` 레지스터 최적화 사용안함
  - 휘발성 이라는 뜻 
  - 레지스터를 활용하지말고 실제 값을 확인하라고 강제로 선언하라는 뜻

1. 컴파일러는 cint값에 100을 넣고 const 키워드가 붙었으니 상수 값이다 라고 판단함

2. 포인터로 강제접근해서 300으로 바꿈

3. cpu 가 빠르게 연산할때 사용하는 레지스터값 에 기존값 100이 저장되어 있음

4. 컴파일러가 상수 값이다 라고 판단해서 레지스터에서 100을 끌어다가 printf 에 사용한것

5. volatile 키워드로 최적화를 무시하게 하여 현재 메모리에 바뀐값 300을 출력하게 수정

## 📍 **C/C++ 강의 31화. const 포인터**

- const 키워드 는 상수라고 보면됨
  - 다만 포인터 등으로 값을 바꿀수도 있음 
  - 절대적으로 안바뀐다고 생각하면 안됨

___

**포인터 변수로 가능한 연산**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int* pInt = &a;

	*pInt = 1;
	pInt = nullptr; 

	return 0;
}
```

1. 현재 포인터 변수가 가르키고 있는 메모리 주소를 바꿀수 있음 
   - `pInt = nullptr;` 
2. 포인터 변수가 가르키고 있는 메모리 주소 안의 값을 바꿀수 있음
   - `*pInt = 1;` 

___

**포인터 변수에 const 키워드가 붙었을때 가능한 연산**

- `*` 을 기준으로 const 키워드의 기능이 나뉘게됨
- 아래 내용 요약
  - `const int*` **원본 값 상수화**
    - `int const*` 같은 뜻임
  - `int* const` **포인터 변수 상수화**

**const int\***

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;

	const int* pConstInt = &a;
	*pConstInt = 100; // ❌
	*pConstInt; // 접근은 가능함

	pConstInt = &b; // ✔️

	return 0;
}
```

- 현재 포인터 변수가 가르키고있는 메모리 주소 안의 값을 못바꾸게 막는 것
- 다른 메모리 주소를 바라보는건 가능함
- `int const*` 도 같은 의미임

**int \* const**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;

	int* const pConstInt = &a;
  pConstInt = &b; // ❌

	*pConstInt = 100; // a = 100; ✔️

	return 0;
}
```

- 현재 포인터 변수가 가르키고 있는 메모리 주소를 바꿀수 없게 막는 것
- 현재 바라보고 있는 메모리 주소 안의 값은 바꿀수 있음

**동시 상수화(const int* const)**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;

	const int* const pConstInt = &b;
	
	int c = *pConstInt;

	return 0;
}
```

- 값을 참조하는건 가능함
- 현재 바라보고 있는 메모리주소나 메모리주소 안의 값을 변경할순 없음

___

**착각하기 쉬운 사항**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;

	const int* pInt = &a;
	*pInt = 100; // ❌
	
	a = 100; // ✔️

	return 0;
}
```

- `const int* pInt = &a;` 은 `*` 의 기능은 const 로 제한 한것이며 a 변수의 원본값과는 아무 상관없음!

## 📍 **C/C++ 강의 32화. const 포인터 예시**

- 함수 파라메타로 값을 넘겨주게 되면 스택 메모리에 값이 복사되서 생성되고 삭제 됨
  - 데이터 크기가 크거나, 자주 호출되면 퍼포먼스가 떨어짐
- 나중에 라이브러리등 가져다 쓸때 다른사람의 코드는 바이너리화 되어 전방선언된 부분만 확인할수 있음
- **단축키 Ctrl + Shift + Space**
  - 함수 선언 원형이 뜸

___

```cpp
#include <stdio.h>

void Output(const int* pI)
{
	int i = *pI;
	*pI = 100; // ❌
}

int main()
{
	int a = 0;

	Output(&a);

	return 0;
}
```

- 내가 전달해준 값을 통해서 값을 읽어 보고만 싶을때 const 포인터를 사용하는 것

**const int\* 를 int\*로 강제 형변환**

```cpp
#include <stdio.h>

void Output(const int* pI)
{
	int* i = (int*)pI; // const int * 를 int* 로 강제 형변환
	*i = 1000;
}

int main()
{
	int a = 0;

	Output(&a);

	a; // 1000

	return 0;
}
```

- 억지로 강제 형변환해서 바꿔버릴수있음
- 이 함수를 만든 사람의 의도를 표시하는 용도로 const 를 써주는 것
- `const_cast` 등 const 를 일반 변수로 형변환 시켜주는 것 등이 있음

## 📍 **C/C++ 강의 33화. void**

- 함수 자료형 에 void 키워드를 써주면 return 할 필요가 없음
- 포인터 앞에 자료형
  - 역참조의 자료형을 보는 용도로 사용
  - 데이터 크기와 해당 데이터를 이런 데이터로 보겠다 라고알려주는 것

**void 포인터**

```cpp
#include <stdio.h>


int main()
{
	void* pVoid = nullptr;

	{
		int a = 0;
		float f = 0.f;
		double d = 0.;
		long long ll = 0;

		pVoid = &a;
		pVoid = &f;
		pVoid = &d;
		pVoid = &ll;

		pVoid + 1; // ❌

	}
	return 0;
}
```

- void 포인터: 주소를 저장하는 변수 지만 원본으로 접근했을때 어떤 자료형으로 볼껀지 정하지 않은 포인터

**void 포인터의 특징**
1. **원본의 자료형을 정하지 않음**
2. **어떤 주소든 다 받을수 있음**
   - 주소를 넣어줬을때 그 주소의 원형을 특정 데이터타입으로 해석을 하지 않기 때문임
3. **역참조가 불가능한 이유**
   - 참조를 할려면 데이터의 크기와 데이터의 타입을 알아야하는데 void는 정해진게 없기때문에 안되는 것
4. **주소 연산도 불가능함**
   - 몇 Byte 증가할지 정해진게 없기때문에 불가능함

___

**포인터의 핵심 원리**
- 원본 데이터가 어떻게 사용되는지는 포인터와 무관
- 선언된 시점대에 해당 포인터에 선언된 자료형타입에 따라 어떻게 접근할건지 어떻게 분석할지는 포인터에서 이미 정해져있는 것
- 메모리 공간에 데이터를 저장했을때 그 타입에 정확히 매칭되는 포인터로 조작을해야 문제가 없음

## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****


# 📌참조링크
어소트락 게임아카데미 강의 링크- [https://www.youtube.com/watch?v=-h_uxJiiiqg&list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&index=2](https://www.youtube.com/watch?v=-h_uxJiiiqg&list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&index=2)