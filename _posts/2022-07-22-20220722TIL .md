---
published: true
title:  "C/C++ 강의 내용 정리"
excerpt: ""

categories:
  - C++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-07-22
last_modified_at: 2022-07-22
---

# 🤔 학습목표
- C/C++ 강의 내용 간략하게 정리

# 📃 학습내용

## 📍 **C/C++ 강의 Prologue. C++ 공부이유와 공부법**

- C++ 는 JAVA 나 C# 과 같이 가상머신을 통하지 않고 바로 메모리관리를 하기때문에 속도에 있어 유리함
- 위와같은 이유로 게임프로그래밍에선 C++ 이 유리함 다만 개발속도가 느린편

**공부 방향**

1. C++ 기초문법, 자료구조(데이터)
2. winapi 게임제작 ( CPU 만 사용하여 게임 제작 )
3. Direct X 게임제작 ( 그래픽 카드 제어 )
4. 게임엔진 게임제작

## 📍 **C/C++ 강의 1화. 프로젝트 생성 및 주석**

- 컴퓨터 언어또한 "언어" 이므로 일정 수준이상 수월하게 사용하기 위해선 암기가 필연적이다.
- 공부한것을 블로그등에 정리해놓으면 시간이 지나면서 구멍이뚫린 기억을 메꾸는데 도움이된다

___

**주석**
- `//` 이나 `/**/` 을 사용해서 사용가능
- 내가 작성해둔 코드가 어떤 역할을 하는지 필요한 내용들을 설명하는 용도로 사용

## 📍 **C/C++ 강의 2화. 자료형**

```cpp
int main()
{
	int i = 0;

	return 0;
}
```

- int : 자료형
- i : 변수명

___

**자료형 (크기 단위, byte)**
- 정수형: char(1), short(2), int(4), long(4), long long(8)
- 실수형: float(4), double(8)

<br><br/>

- 자료형이란 변수가 어떠한 자료의 형태를 나타내는지 표현해주는 것
- 자료형으로 **표현 방식** 과 **크기 단위(byte)** 를 알수있음

___

**데이터의 단위**

**1 Byte = 8 bit**
- 1 bit 는 값이 있다 없다를 표현해주는 데이터의 최소값을 나타냄

- 데이터 단위는 **2^10 = 1024묶음** 단위로 byte - kb - mb - gb - tb 순으로 표현함

___

**경우의 수**

- **2^8 = 256** 8비트로는 **0~255까지 256가지**의 상태를 표현할수있음
 
___

**unsigned**

- 정수형 자료형 앞에 붙이면 양의 정수만 표현가능한 정수형 자료형을 만들수있음
- **unsigned char** 에 256값을 넣게되면 0이 나오게됨
  - 255까지만 넣을수 있는 공간에 256이라는 초과된 값을 넣으면 잘려서 못들어감

___

**변수의 선언 위치**

**올바른 선언** 
```cpp
int main()
{
  char c = 0;

  c = 256;

  return 0;
}
```

**올바르지 못한 선언** 
```cpp
int main()
{
  c = 256;

  char c = 0;

  return 0;
}
```

- 변수를 자료형과 함께 선언한 후 아래에서 사용가능함

___

- `=` 대입 연산자
  - 왼쪽의 값을 오른쪽의 값에 넣어 주는 연산자
- `==` 비교 연산자
  - 양쪽이 균등한지 물어보는 연산자

## 📍 **C/C++ 강의 3화. 정수형 자료형**

- 양수를 표현하는 자료형 앞에는 **signed** 키워드가 숨겨져있음
  - 굳이 안적어줘도 상관없음

**unsigned**
- 1 바이트로 양수만 표현
  - 256가지 -> 0 ~ 255

**signed**
- 1 바이트로 양수, 음수 둘다 표현
  - 256가지 -> -128 ~ 0 ~ 127 
  - **MSB (most significant bit) 최상위 비트**
    - 맨앞의 숫자가 0 일때 양수 로 표현 
    - 맨앞의 숫자가 1 일때 음수 로 표현

**음수의 동작방식**

- 2진수끼리의 덧셈
  - 각각의 두숫자의 자릿수의 합하여 올림
- 컴퓨터에서는 뺄셈이 없고 음수의 덧셈이라고 생각함
- `signed 기준)` 0111 1111(127) + 1000 0001(-127) = 0
- `signed 기준)` 0000 0001(1) + 1111 1111(-1) = 0

```cpp

unsigned char c;
c1 = 255 // 255 가 입력됨

char c1;
c1 = 255 // -1 이 입력됨
```

- 255가 2진수상으로 1111 1111 이 들어가고 signed 기준으로 이 값은 -1임으로 c1 에 -1이 입력됨
- c와 c1의 메모리 공간의 상태는 1111 1111로 똑같음!
  - 최상위 비트 를 사용한다 안한다의 차이

___

**음수값 찾는법**
- **2의 보수법**
  - 양수와 음수를 더했을때 0 이 나오는 수를 찾는것
  - 0을 1로 1을 0으로 바꾸고 1을 더해주면됨
  - 0000 0010 의 음수값은 1111 1110

**C++ 2진수 표기**

```cpp
int main()
{
	char c,d,k;

	c = 0b0000'0011; // 3
	d = 0b1111'1101; // -3

	k = c + d; // 0

	return 0;
}
```

- **"0b숫자(2진수)"** 
- **"0숫자(8진수)"**
- **"0x숫자(16진수)"**

- 자릿수 표기법  
  - 숫자 사이사이에 `'` 를 넣어주면됨

___

**값의 표현 범위**

- byte 가 늘어날수록 기하급수적으로 값의 표현 범위가 늘어감
- 1 Byte (2^8) 256 가지 → 2 Byte (2^16) 65536가지 → 4Byte (2^32) 4,294,967,296 가지 

## 📍 **C/C++ 강의 4화. 실수형 자료형**

- 정수형, 실수형데이터를 나누는 이유는 **처리하는 방식**자체가 다르기때문
- 정수형데이터는 비트라는 한정적 공간안에서 2진수로 대응되는 숫자로 표현함 
  - 경우의 수 자체가 한정적임
- 실수는 무한으로 만들어 낼수 있기때문에 한정적으로 비트값을 대응 시킬수 없음 
  - 부동 소수점이라는 표현방식을 사용함

- 정수 4 와 실수 4.0 는 컴퓨터에서 저장되는 방식은 완전히 다름 
  - `int a = 4 + 4.0` 4.0 이 4로 형변환 연산이 들어간뒤 계산됨
  - 정수, 실수의 혼합된 계산방식은 의도치않은 상황이 발생될수 있기 때문에 피하는것이 좋음

**부동소수점**
- float 보다 double 이 정밀도가 더 좋음
  - 4비트의 float 보다 8비트의 double 이 더 가까운값을 표현할수 있기때문임 

- 컴퓨터에서의 부동소수점 방식
  - 소수점 뒷자리는 2^-1(1/2) → 2^-2(1/4) → 2^-3(1/8) 이런식으로 내려감 
  - 0.8125(10진법) → 11010(2진법) 으로 변환할수 있음
    - 11010 이라는 비트를 정규화 시키기위해서 2^5(101)을 곱해줌

- 부호비트,지수 파트,가수 파트로 나늘수 있음
  - 부호비트: 맨첫째 자리로 양,음 을 구분하는 용도로 사용
  - 지수 파트: 소수점을 정규화 시킬때 곱해준 비트를 표현
  - 가수 파트: 정규화 시킨 파트의 비트

___

**명시적 형변환**
- 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 연산자가 연산될 경우 명시적으로 변환하자
  - `float f = 10-.2415f + (float)20;`

## 📍 **C/C++ 강의 5화. 산술 연산자**

- `;` : 컴파일러가 컴파일할때 문장의 마감을 표현해줌 
- 산술 연산자
  - `+` 
  - `-`
  - `*`
  - `/`
  - `%` (모듈러스, 나머지)
    - 피연산자가 모두 정수인경우 사용가능

- 증감 연산자
  - `++`
  - `--`

- 대입 연산자
  - `=`

- **연산자 우선순위**
  - 연산자들이 나열되었을때 연산자 우선순위에 따라 연산순서를 정함

___

```cpp
int data = data + 20; // 1
data += 20 // 2
```

- 1과 2는 동일하게 작동함

___

- 피연산자: 연산의 대상이 되는 데이터
- 나누기 연산시 피연산자가 정수인지 실수였는지에 따라 두가지 결과가 발생함
  - 실수가 끼어있는 `%` 연산은 문법오류가 발생함
  - 정수끼리의 나머지 연산시에는 경고가 발생할수 있음
    - 대입연산시 상수값이 잘리기때문에 경고가 발생함 따라서 형변환을 해주는것이 좋음

___

```cpp
float data = 20.f; 
double data = 20. ;
```

- float 은 숫자뒤에 `.f` 를 붙여주고 double은 `.`을 붙여줌
- 실수를 상수로 적을 경우 소수점 뒤에 f 를 붙이면 float 자료형으로, f 를 붙이지 않으면 double 자료형으로 간주한다.

## 📍 **C/C++ 강의 6화. 증감 연산자**

- 증감 연산자
  - `++`
  - `--`

- 다음단계로 증감해주는 연산자
- 일반적인 숫자타입에선 +1 -1 증감

```cpp
int data;
++data // 전위(전치)
data++ // 후위(후치)
```
- 위치에따라 연산되는 순서가 달라짐
- 연산자 우선순위가 달라짐
  - **후위로 갔을경우 모든 연산자 우선순위 최하위가 되어 제일 나중에 수행됨**
- data라는 변수안에 실제값이 증가함
  - 다른 메모리 공간에서 data + 1 이 되어 대입되는 것이아님!
- 특별한사유가 없는한 전위 연산자로 사용하는것이 좋음
  - 연산자 오버로딩때 클래스나 구조체의 오퍼레이터라는 함수를 실수로 호출할수 있음

## 📍 **C/C++ 강의 7화. 논리 연산자**

- 참(true), 거짓(false)
  - 0 이 아닌 모든수를 참으로봄
    - 다만 컴퓨터에 true을 요청하면 1이 나옴
  - 대표적으로 1을 참이라고 봄
  - c++ 에서 true나 false 를 키워드로 줌
- `!`
  - 역
  - 참을 거짓으로, 거짓을 참으로 바꿔줌
- `&&`
  - 곱 ( and )
  - 둘다 참이면 참, 둘 중 하나라도 거짓이면 거짓
- `||`
  - 합 ( or )
  - 둘다 거짓이면 거짓, 둘 중 하나라도 참이면 참

___

**bool 자료형**
- 1 byte 자료형
- true나 false 만 나타내는 자료형
- 굳이 따지자면 정수형 자료형에 속함

## 📍 **C/C++ 강의 8화. if / else 구문**

**비교연산자**
- `==`
  - 왼쪽 값 과 오른쪽 값이 같은지 물어보는 연산자
- `!=`
  - 왼쪽 값 과 오른쪽 값이 다른지 물어보는 연산자 
- `<`
  - 왼쪽값이 오른쪽 값보다 작은지 물어보는 연산자
- `>`
  - 오른값이 왼쪽 값보다 작은지 물어보는 연산자
- `<=`
  - 왼쪽값이 오른쪽 값보다 작거나 같은지 물어보는 연산자 
- `>=`
  - 오른값이 왼쪽 값보다 작거나 같은지 물어보는 연산자

___

```cpp
int data;
if(조건식) // 조건식 true or false 가 들어옴
{
  // () 안에 값이 참이라면 실행됨
}
else if () // if 가 false 라면 실행됨
else
{
  // () 안에 값이 거짓이라면 실행됨
}
```

- `if()`
  - () 안에 값이 true 면 {} 안에 구문이 실행됨
  - 수행안될 구문은 컴파일러가 삭제시켜줌
- `else if` 
  - if 안에 값이 거짓이면 확인하는 구문
  - else if 구문으로는 동시입력을 받을수 없기때문에 캐릭터 입력등은 if 문 여러개로 짜야함
- `else`
  - if 나 else if 구문중 아무것도 걸리지 않았을 경우 실행되는 구문
  - 없어도 상관없음

## 📍 **C/C++ 강의 9화. switch 구문/ 삼항 연산자**

```cpp
switch(10)
{
  case 10:
    // 실행
    break;

  case 20:

    break;

  case 30:

   break;

  default: 
    break;
}
```

- switch(): () 안에 조건과 case 앞에 조건을 비교하여 맞는 조건을 실행시켜줌

- case 구문중 맞는게 없는경우 default 가 실행됨

- 문법적으로 if 문과 거의 다르지않음
  - switch-case문은 변수나 특정값을 넣어주는 경우 표현이 힘든경우가 있음
  - if 문은 코드 가독성이 떨어지는 경우가있음

- break 가 없으면 밑에있는 구문까지 break를 만나는 라인까지 실행시켜줌
  - 공통적으로 똑같은 조건에서 실행시키고 싶은 경우가 있기 때문에 문법오류로 안잡아줌

___

```cpp
int iTest = 10;
if(1 || iTest == 20 || iTest == 30)
{

}
```

- 위와같이 `||` 연산자 연산중 앞에 1이 발견되어 조건이 참인경우 `iTest == 20 || iTest == 30` 는 실행되지 않음

___

**삼항 연산자**

```cpp
iTest == 20 ? iTest = 100 : iTest = 200;
```

- iTest 가 20 이라면 100을 넣고 20이 아니라면 200을 넣는 코드
- ? 왼쪽값에 참인지 물어보고 참이면 왼쪽이 실행 거짓이면 오른쪽이 실행
- 가독성이 떨어짐

```cpp
if(iTest == 20)
{
  iTest = 100;
}
else
{
  iTest = 200;
}
```

- 삼항 연산자코드를 if else 문 으로 바꾼 코드
  
## 📍 **C/C++ 강의 10화. define / 비트 연산자 (1)**

```cpp
unsigned char byte = 1;
byte <<= 3; // 8
```

- **비트 연산자:** 비트단위로 연산이 진행될때 사용되는 연산자
- 비트 쉬프트
  - 비트를 화살표가 가르키는 방향으로 한칸씩 밈
  - `>>`
  - `<<`

- 2진수에서 한칸 올라간다는것은 2배가 올라간다는것과 같음

**홀수의 비트쉬프트**

```cpp
unsigned char byte = 13;
byte >>= 1; // 6
```

- 홀수를 나누면 몫만 취하게됨
- 나머지는 오른쪽으로 밀리면서 소실됨

___

**비트 단위 연산**

- 비트 자리대로 비트끼리 연산하는 것

- **비트 곱(`&`)**
  - 비트 단위 기준 둘다 1일경우 1이 나옴
- **비트 합(`|`)**
  - 비트 단위 기준 둘중 하나라도 1일경우 1이 나옴
- **xor(`^`)**
  - 비트 단위 기준 둘다 같으면 0, 다르면 1이 나옴
- **반전(`~`)**
  - 1은 0으로 0은 1로 반전시켜줌

___

**전처리기**

- `#` 이 붙은 모든 구문을 컴파일 시 제일 먼저 처리해줌
- `#defind`
  - 내가 지정한 구문을 특정 숫자로 치환해줌

**#defind 예제**

```cpp
#define HUNGRY 1

int main()
{
	int iStatus = HUNGRY;

	return 0;
}
```

**전처리기의 장점**
- 가독성이 좋아짐
- 코드 유지보수가 좋아짐

## 📍 **C/C++ 강의 11화. 비트 연산자 (2)**

- 비트 연산으로 상태를 표현할수 있음
  - 겹치지 않는 자리로 상태를 나타낼수있음 즉 8비트 = 32가지상태를 나타낼수 있음

```cpp
#define HUNGRY 1
#define THIRSTY 2
#define TIRED 4

int main()
{
	unsigned int iStatus = 0;

	// 상태 삽입
	iStatus |= HUNGRY;
	iStatus |= THIRSTY;
	iStatus |= TIRED;

	if (iStatus & THIRSTY) // 상태확인
	{

	}

	//특정 자리 비트제거
	iStatus &= ~THIRSTY;

	return 0;
}
```
___

**16진수**

```cpp
#define HUNGRY  0x001 // 1
#define THIRSTY 0x002 // 2
#define TIRED   0x004 // 4
#define FIRE    0x008 // 8

#define COLD    0x010 // 16
#define POISON  0x020 // 32
#define POISON1  0x040 // 64
#define POISON2  0x080 // 128

#define POISON3  0x100 // 256
#define POISON4  0x200 // 512
#define POISON5  0x400 // 1024
#define POISON6  0x800 // 2048
```

- 16진수의 각자리수를 2진수로 변환하고 10진수로 보면 편함
- 0x100 (16진수)
  - 0001 0000 0000 (2진수)
  - 256 (10진수)


## 📍 **C/C++ 강의 12화. 변수**

1. 지역변수
   - 함수안에 들어있는 변수를 지칭함
   - `{}` 안쪽에 선언되어있는 변수
2. 지역변수
   - 함수 바깥에 선언되어 있는 변수 
3. 정적변수
4. 외부변수

**함수**
- 하나의 기능을 정의해 놓는것
- 기능의 모듈화
  - 작은 기능들을 모아 큰 기능을 만드는 것
  - 하나의 기능을 명확하고 잘 쪼게놓아야함

```cpp
int Add(int left, int right)
{
	return left + right;
}

int main()
{
  data = Add(10, 20);
}
```

1. 반환 타입 작성
   - `int`
2. 함수 이름 정의
   - `Add`
3. 인자 설정
   - `int left, int right`   
   - 이 인자들도 Add 라는 함수 안의 지역변수임

___


**변수명 규칙**
- 이름을 하나 줬는데 똑같은이름으로 변수를 짓게되면 모호성이 생김 컴파일 에러 발생
  - 지역변수안에 똑같은 변수명을 짓게되면 지역변수안에 있는 변수를 우선으로 할당해줌
  - 쉽게 말해 범위가 작은 변수를 우선적으로 할당하게됨
  - 지역 변수는 자기 지역을 벗어나게되면 사라짐

```cpp
int main()
{
  int test = 0;

  {
    int test = 100;

    test // 100 짜리 test
  }

  test // 0 짜리 test
}
```

## 📍 **C/C++ 강의 13화. 함수 (1) / 반복문**


- 프로그램의 정체는 함수의 호출임 main 함수를 호출 시키는 것
- 반복문이 돌면서 main함수를 유지시키고 특정 조건이 만족되었을때 main함수가 종료되어 프로그램이 종료되는 것
- VS 에선 디버깅 모드에서는 중단점에 걸려 현재 진행중인 코드를 확인할수 있음

**반복문**
- 어떤 조건을 주고 충족될때까지 코드를 반복하는것

**for()**

```cpp
for (/*반복자 초기화*/ ; /*반복자 조건 체크*/; /*반복자 변경*/ )
{

}

for (int i = 0; i < 2; ++i)
{
  printf("Output Test\n");
}
```

- 반복자 초기화 구문: for문이 시작될때 한번만 실행되는 용도로 실행됨
- 반복자 조건 체크: true or flase 입력을받음 true 인 경우에만 구문이 실행됨
- 반복자 변경: for문 {} 구문 수행 후 실행되는 부분

**while()**

```cpp
while(/*조건 체크*/)
{

}

int i = 0;

while(i < 2)
{
  printf("Output Test\n");
  ++i;
}
```

**반복문 내부 키워드**
- for문 while 문 둘다 사용가능함
- `continue`
  - 구문 수행중 continue 를 만나게되면 이번 구문은 스킵하고 다음 구문으로 넘어가게 되는 키워드
- `break`
  - 구문 수행중 break 를 만나게되면 반복을 끝내고 탈출하게 됨

___

**입출력 함수**

- 내가 만든 함수가 아니기때문에 `#include <stdio.h>` 표준 입출력 함수를 참조해야함

```cpp
printf("Output Test\n");
```

- `printf();`
  - 문자열을 입력하고싶을땐 `""` 안에 텍스트를 적어 주면됨
  - `"\n"` 개행 문자로 커서가 다음칸으로 넘어가게됨
- `scanf();`

## 📍 **C/C++ 강의 14화. Visual Studio 단축키 및 편의 사항**

**단축키**
- VS 설정도구에서 커스터마이징 가능함

- 지정한 구문 주석
  - `Ctrl + k, c`
- 지정한 구문 주석 해제
  - `Ctrl + k, u`
- 최근의 했던 작업 되돌리기
  - `Ctrl + z`
- 원하는 부분만 선택할수 있음
  - `Alt + Drag`
- 함수의 선언 또는 정의로 이동
  - `함수 선택후 F12`
- 함수 `()` 부분에 **단축키 Ctrl + Shift + Space**
  - 함수 선언 원형이 뜸
- 함수를 선택하고 F12 을 누르면 선언또는 정의로 이동할수 있음
- 전방 선언 함수에 `Ctrl + . → 선언/정의 만들기(c)` 누르면 cpp파일에 바디를 만들수있음

<br><br/>

**디버깅**

- 디버깅 시작
  - `F5`
  - **디버깅중, 다음 중단점까지 코드 실행**
- 중단점 생성, 삭제
  - `F9`
  - 중단점 부분 코드 직전에 멈춰줌
- 디버깅 중, 구문 수행
  - `F10`
  - main 함수의 한단계가 수행됨
  - 프로시저 단위 기능단위 라고도함
- 디버깅 중, 구문 수행(함수 진입)
  - `F11`
  - 아주 작은 단위에 코드씩 실행됨
  - 한 단계씩 코드 실행
- 디버깅중, 디버깅 종료하기
  - `Shift + F5`

<br><br/>

**디버깅 창**

- 로컬
  - 디버그 - 창(W) - 지역(L) 
  - 메인함수는 실핼될때 구문이 아직 실행되지 않아도 선언해놓은 지역 변수의 메모리는 미리 잡혀있음 
  - 현재 중단점이 걸려있는 메인함수의 지역 변수를 다 보여줌
  - 커서로 변수에 올려놔도 보임
  - 변수 초기화 전엔 쓰레기값이 들어가있음 
- 조사식
- 호출 스택
  - 디버그 - 창(W) - 호출 스택(C) 

<br><br/>

**윈도우 단축키**

- 복사
  - `Ctrl + c`
- 붙여넣기
  - `Ctrl + v`
- 잘라내기
  - `Ctrl + x`

## 📍 **C/C++ 강의 15화. printf / scanf 문자 입출력**

- 콘솔창
  - 콘솔: 입력, 출력 장치
  - 윈도우 기준 **명령 프롬프트** 창 os 마다 명칭이 다름
- vs 프로젝트 시작시 명령 프롬프트 창으로 실행 으로 설정하였기 때문에 
main 함수가 실행되면 명령 프롬프트 창이 열리게 되는 것

- `#include`
  - 컴파일 전에 다른 헤더파일을 포함하여 사용하겠다는 전처리기

- `printf()`
  - 콘솔창에 문자를 출력
  - `printf("abcdef\n");` `""` 안에 문자를 출력하고 `\n` 줄바꿈 하겠다는 구문
  - 치환문자 `printf("%d", 10);` 
    - 정수형 데이터 `%d` 치환문자 자리에 문자로 대체해주는 것
    - 실수형 데이터 `%f`

```cpp
int iInput = 0;
scanf_s("%d", &iInput);
```

- `scanf()`
  - 콘솔창으로 부터 입력을 받음
  - `scanf_s("%d", &iInput);` 
    - 입력받을 데이터 타입과 변수의 주소를 넘겨줘야함
  - scanf 내부에서 입력이 들어올때까지 무한루프를 돌고있는 것
  
## 📍 **C/C++ 강의 16화. 함수 (2)**

- 함수 안에서 함수를 호출하여 최종적으로 main함수로 돌아옴
  - 자료구조 스텍과 유사함
  - 이전에 호출한 함수가 종료되야 현재 함수가 종료될수있음


**자료구조 Data structure**
- 어떤 데이터를 관리함에 있어 어떠한 구조로 데이터를 효율적으로 관리 하고 처리하는지 연구하는 학문
- 스텍 : 후입 선출 구조
- 큐 : 선입 선출 구조

___

**함수가 사용하는 메모리 영역**
- **스택 메모리 영역**
  - main함수가 실행되는 순간 모든 변수들이 담길 공간을 마련함
     - main함수뿐 아니라 모든 함수에 적용되는 사항임 
  - main 함수실행에 필요한 데이터가 100Byte 라면 main함수 처음 실행시 100Byte 공간을 잡음 메인함수가 다른 함수를 호출하면 그 순간 다른 함수를 호출하면 그 함수에 필요한 데이터를 잡고 함수가 종료될때 데이터를 삭제함
 - 현재 지칭하는 함수명이 다르기때문에 함수별로 같은이름의 변수명을 지을수 있는 것임

___


**코드 != 메모리 영역**
- 코드는 명령어
- 함수는 명령어의 집합
- 메모리 영역은 코드를 수행했을때 수행되는 영역

## 📍 **C/C++ 강의 17화. 함수 (3)**

**계승 (Factorial)**
- `n!` 으로 표현
- 각 자리 숫자들의 최종 곱

**계승 코드**

```cpp
int main()
{
	int i = 4;

	int iValue = 1;

	for (int j = 0; j < i - 1; ++j)
	{
		iValue *= (j +2);

	}

	return 0;
}
```

- i 값만 바꾸면 특정 계승값을 알아낼수있음

**계승 코드의 모듈화**

```cpp
int Factorial(int _iNum)
{
	int iValue = 1;

	for (int j = 0; j < _iNum - 1; ++j)
	{
		iValue *= (j + 2);
	}

	return iValue;
}

int main()
{
	int iValue = Factorial(4);

	iValue = Factorial(10);

	return 0;
}
```

- 함수를 사용하는 이유
  - 하나의 기능 단위를 함수로 구현해놓고 계속 재활용 하기 위해서
- 행동집합을 하나만두고 필요할때마다 지침을 읽고 사용하는 것
- 복잡한 기능을 만들때 기존에 만들어둔 함수들의 조합으로 만들수 있음

## 📍 **C/C++ 강의 18화. 재귀 함수 (1)**

**재귀 함수**
- 함수안에서 자기 자신과 동일한 함수를 호출하는 것
- 무조건 **탈출 조건**이 필요함

**재귀 함수의 장점** 
- 가독성, 구현의 용이
- 계층구조 표현이 재귀 함수가 좋음

**재귀 함수의 단점** 
- 반복문 등으로 대체 표현이 가능하지면 반복문으로는 가독성, 구현이 좋지못함
- 실수할 여지가 있음
- 성능이 많이 떨어짐
  - 여러번의 함수를 호출해서 마치 변수처럼사용하기 때문에 호출, 회수 비용이 들기에 성능이 떨어짐


**디버깅 툴**
- **호출 스택:** 호출된 함수의 순서대로 보여줌 
  - **디버깅시 호출스택의 함수를 클릭하면 클릭한 함수의 상태를 확일할수 있음**
- **로컬:** 현재 호출된 함수의 지역변수들을 보여줌
- VS 의 호출 스택, 로컬, 조사식을 잘 사용하면 문제점을 발견할때에 문제를 찾기가 쉬움
- 지역 변수는 현재 호출된 함수가 사용될 메모리를 갖고있음
- 스택 메모리 영역: 함수가 사용하는 메모리영역

**함수 동작 순서**
- cpu에 레지스터라는 빠르게 접근할수있는 메모리 공간에 잠시 받아두고 함수메모리 해제하고 리턴값을 사용함 


**재귀 함수의 스택 메모리**
- 함수가 계속 실행되어 스택 메모리에 계속 호출되어 쌓이는 방식임
- 한계치에 도달하면 **스택 오버 플로우** 라는 에러가 발생함

## 📍 **C/C++ 강의 19화. 재귀 함수 (2)**

- C/C++ 처음 공부시 그림이나 펜으로 변수 메모리공간을 직접 구상화하면서 연습하는것이 좋음

- 재귀 (Recursion)
- 자료구조 등은 영어 단어로 찾아두는것이 좋음

**재귀 함수**

```cpp
int Factorial_Re(int _iNum)
{
	if (1 == _iNum)
	{
		return 1;
	}
	
	return _iNum * Factorial_Re(_iNum - 1);
}

int main()
{
	int iValue = 0;

	iValue = Factorial_Re(7);

	return 0;
}
```

- 10부터 시작해서 1이될때까지 호출을 계속하다가 1을만나면 1을 리턴하는 재귀함수 코드

<br><br/>

**Fibonacci sequence(피보나치 수열)**

- 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열

```cpp
// 1 1 2 3 5 8 13 21 34 55 89
int Fibonacci(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	int iPrev1 = 1;
	int iPrev2 = 1;
	int iValue = 0;

	for (int i = 0; i < _iNum - 2; ++i)
	{
		iValue = iPrev1 + iPrev2;
		iPrev1 = iPrev2;
		iPrev2 = iValue;
	}

	return iValue;
}

int main()
{
	int iValue = Fibonacci(10); 

	return 0;
}
```

1. 두 변수 공간에 iPrev1, iPrev2에 각각 1을 넣어두기
2. iPrev1 + iPrev2 값을 iValue 넣기
3. iPrev2 값을 iPrev1 에 넣기
4. iValue 값을 iPrev2 에 넣기

- 이런식으로 `_iNum - 2` 번 반복하면 `_iNum` 번째의 피보나치 수열을 구할수 있음 

**재귀 함수 버전 피보나치 수열**

- `f(n) == f(n - 1) + f(n - 2);`

```cpp
int Fibonacci_Re(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	return Fibonacci_Re(_iNum - 1) + Fibonacci_Re(_iNum - 2);
}

int main()
{
	int iValue = Fibonacci_Re(10); 

	return 0;
}
```

- 위 코드는 구현하기는 편하지만 성능이 매우떨어짐
  - 60번만 호출해도 2제곱승수로 호출이 늘어나기때문에 호출을 엄청많이하게됨
  - 꼬리 재귀 등으로 해결이 가능하긴함
- 피보나치 수열은 계층 구조를 표현할때 좋음
- 트리 자료구조 내부에 탐색, 후속자, 선행자를 찾을때 재귀 함수가 용이함

## 📍 **C/C++ 강의 20화. 배열**

- 배열을 제대로 알기위해선 포인터를 알아야함
- 포인터는 이해하는 것에 그치지 않고 많이 사용해봐야함

**배열 기본 문법**

```cpp
int main()
{
	int iArray[10] = {};

	return 0;
}
```

- `int iArray[10]` int 자료형 10묶음 의 이름은 iArray라고 지은것
- `{}` 각각 초기 요소들을 전부 0으로 초기화 하겠다는것

**인덱스 접근**

```cpp
int iArray[10] = {};
iArray[4] = 10;
```

- `[]` 안에값은 몇번째값이 아닌 **인덱스**임
- 최대 접근 가능 인덱스 는 **iArray[10]** 으로 초기화 했을때 **iArray[9]** 까지 가능함
- 배열의 범위를 초과하여 접근하는경우 에러가 발생할수도 안할수도있음 
- **배열은 메모리가 연속적인 구조**임

- 배열의 범위를 초과한다 == 내가 선언하지 않은 영역에 접근하는것과 같음
- 스택 메모리 영역에 배열의 범위를 초과된 부분이 다른 변수가 이미 할당받은 공간일경우 데이터가 덮어씌어질 위험성이 있음

## 📍 **C/C++ 강의 21화. 구조체**

**배열**
- 배열을 사용하는 이유는 동일한 자료형으로 변수를 한번에 여러개를 할당하고싶을때 한번에 묶어서 변수를 선언할수 있음
- 메모리구조가 연속적인 구조를 가짐
- 특정 요소로 접근할때 인덱스로 접근해서 값에 접근함
  - 초과된 값으로 접근할 경우 다른 변수가 갖고있던 영역에 침범할 가능성이 있음

**구조체 (user defined data type)**

- 사용자 정의 자료형
- **자료형:** 데이터 단위, 형태를 명시해주는것

```cpp
typedef struct _tagMyST
{
	int a;
	float f;
}MYST;

int main()
{
	MYST t;
	t.a = 10;        // 요소 접근
	t.f = 10.2312f;

	int iSize = sizeof(MYST); // 8

	return 0;
}
```

- int, float 을 묶어서 `MYST` 라는 이름으로 구조체를 만든것
- `sizeof()` () 안에 들어있는 변수나 자료형의 사이즈를 알려줌
  - `MYST`는 int, float 의 사이즈를 합쳐 8Byte 사이즈를 갖게됨
- int a, float f는 변수선언이 된것이 아닌 `MYST` 라는 사용자 정의 자료형의 형태를 알려준것임 
- `t.a` 을 찍어 접근할수 있음

___

**구조체의 확장**

```cpp
typedef struct _tagMyST
{
	int a;
	float f;
}MYST;

typedef struct _tagBig
{
	MYST k;
	int i;
	char c;
}BIG;

int main()
{
	MYST t;
	t.a = 10;
	t.f = 10.2312f;

	int iSize = sizeof(MYST); // 8

	return 0;
}
```

- 구조체가 다른 구조체를 갖고있는 형태로 확장될수 있음

**구조체의 구조**

**typedef** 

```cpp
typedef int INT;

int main()
{
    INT a;
}
```
 
- `typedef` 타입을 재정의 해주는 것
- 단순히 코드를 바꾸는 것이아닌 타입을 재정의 해주는 것이기 때문에 컴파일러가 INT 를 int로 봄 
- C++은 C에 기능이 추가되고 기존에있던 기능의 편리성이 추가되고 객체지향이 추가된것

___

**C 스타일의 구조체**

```cpp
struct NewStruct
{
	int a;
	short s;
};

int main()
{
	struct NewStruct a;

	return 0;
}
```

- C 에서는 구조체선언시 구조체 이름 뒤에 struct라는 키워드를 붙여줘야함
  - 구조체 들을 따로 모아두고 거기서 찾아서 사용하는 구조이기 때문임

**typedef 활용**

```cpp
typedef struct NewStruct
{
	int a;
	short s;
} NEWST;

int main()
{
	NEWST a;

	return 0;
}
```

- `struct NewStruct a;` 같이 문자가 길어지기 때문에 typedef 으로 NEWST 라는 새로운 이름을 지어주는 것


**C++ 스타일의 구조체**

```cpp
typedef struct NewStruct
{
	int a;
	short s;
} NEWST;

int main()
{
	NewStruct a;
  NEWST b;
  struct NewStruct c;

	return 0;
}
```

- C++ 에선 개선되어 NewStruct 만 써서 사용할수있음
- 윈도우 api 쪽 코드에선 대부분의 구조체들이 위와같은 형태로 구조체 선언이되어있음
  - C나 C++ 둘다 사용가능하게끔 범용성있게 짜놓은것

___

**구조체의 초기화**

```cpp
#include <stdio.h>

typedef struct _tagMyST
{
	int a;
	float f;
}MYST;


int main()
{
	int arr[10] = { 1,2,3,4,5,6,7 };
	MYST t = {1, 3.14f};

	return 0;
}
```

- 배열의 초기화 와 구조체의 초기화는 비슷함
  - 요소 하나하나 각각 초기화 해줄수 있음
  - `,` 이나 아무것도 안써줄경우 그 뒤에있는 요소들은 0 으로 초기화 됨

___

**VS 빌드제외**

- cpp 파일 우클릭 → 속성(R) → 구성 속성 → 일반 → 빌드에서 제외 → 예 체크
- 없는 파일로 취급됨

## 📍 **C/C++ 강의 22화. 지역 변수 / 전역 변수**

**변수의 종류**
1. 지역 변수 : 함수안에 선언된 변수
  - 해당 함수가 실행될때 스택메모리에 있다가 사라짐
2. 전역 변수 : 
  - 데이터 영역을 사용함
3. 정적 변수(static)
   - 데이터 영역을 사용함 
4. 외부 변수(extern)
   - 데이터 영역을 사용함

**데이터 영역**
- os 프로그램이 실행될때 부여하는 메모리영역을 개념적으로 지칭해서 나뉘는것
- os 등 마다 세분화해서 나뉠수 있음
- 가장 대표적으로 크게 분류하면 아래와같이 4가지로 나눌수 있음
- C++ 은 직접 메모리를 다루기때문에 자기가 작성하는코드의 메모리가 어떻게 사용되는지 정확히 알고 사용해야함

1. 스택 영역
   - 함수가 선언될때 사용되는 영역 
2. 데이터 영역
   - 전역 변수가 사용하는 영역
   - 프로그램이 시작 시 생성
   - 프로그램이 종료 시 해제  
   - main 함수와 다른함수 어디든 접근할수 있음
     - 함수의 호출과 해제와는 상관없이 프로그램 종료시까지 계속 존재하기 때문에 접근이 가능한것
3. 읽기 전용(코드, ROM)
4. 힙 영역

___

**전역 변수**

```cpp
int g_i;

void Test()
{
	++g_i;
}

int main()
{
	Test();
	Test();
	Test();

	return 0;
}
```

- 전역변수는 지역변수와 달리 스택메모리에 생겼다가 사라지는것이 아닌 데이터 영역에 존재하기 때문에 `Test()` 함수가 호출될때 마다 값을 누적하여 갖을수 있음 

## 📍 **C/C++ 강의 23화. 분할 구현**

- 함수의 반환타입이 없을때는 `void` 를 써줄수있음
- 다른파일에 구현해놓고 헤더 include 만 해놓으면 기능을 사용할수 있기 때문에 관리 하기 좋기때문에 분할 구현을 사용함
- 궁극적으로는 한파일에 몰아서 작업하는것이 성능이 더잘나옴
  - 링킹과정에서 성능이 떨어질수 밖에 없음
  - 사람이기때문에 한가지 파일에서 작업하는것은 현실적으로 불가능함

___

```cpp
int g_i;

int main()
{
	Test(); // 컴파일 에러
	Test(); // 컴파일 에러
	Test(); // 컴파일 에러

	return 0;
}

void Test()
{
	++g_i;
}
```

- 코드는 위에서 부터 순차적으로 분석을 함 
- 위 코드와 간이 Test 함수를 아래에 구현하게되면 찾을수 없어서 컴파일 에러를 발생하게 됨

**전방 선언**
```cpp
int g_i;

void Test(); // 전방선언

int main()
{
	Test(); 
	Test(); 
	Test(); 

	return 0;
}

void Test()
{
	++g_i;
}
```

- 나중에 컴파일 시 링크단계때 전방선언된 함수들의 바디 부분을 찾아서 잡아주기때문에 전방선언을 해놓으면 그 아래에서 해당 함수를 사용할수 있는 것
- 에러 이름중 C 로 시작하는것은 컴파일 에러
  - 문법 등이 틀리면 컴파일 단계에서 에러가 발생함
- 전방선언만 해놓고 실제 body 를 구현해 놓지 않으면 **LINK ERROR** 가 발생함
  - 컴파일단계에선 에러가 발생되지않고 링킹 단계에서 에러발생됨

___

**#include**

- 명시되어있는 파일을 현재 파일에 복붙하는 것


**func.h**
```cpp
#pragma once


int Add(int a, int b);
```

- Add 라는 이름을 가진 함수이며 반환타입은 int 이며 int형 자료형 두개를 인자로 받는 함수가 있다고 선언만 해준것
- 기능은 구현은 하지않음


**func.cpp**
```cpp
#include "func.h" // 전방 선언 되어있는 헤더 참조

int Add(int a, int b)
{
	return a + b;
}  
```

**main.cpp**
```cpp
#include <stdio.h>
#include "func.h" // Add 함수가 전방 선언 되어있는 헤더 참조

int main()
{
  Add(1, 2);

	return 0;
}
```

- main 함수에서 전방 선언되어있는 헤더파일만 참조해도 Add 함수 기능을 사용할수 있는 이유
  - **링크 과정에서 엮어주기 때문임**
  - Add함수의 기능부분은 func.cpp 파일 이외에 main.cpp 파일에서 구현해도 상관은 없음 

## 📍 **C/C++ 강의 24화. 분할 구현의 문제점**

**cpp 와 헤더파일을 구분하는 이유**
- 헤더파일에 기능까지 구현해버리면 `#include` 허는 파일마다 기능 까지 복붙 되기때문에 **중복 구현 컴파일 에러**가 발생할수 있음
  - 문법상 구현은 딱 한번만 해야함 
  - 그러므로 선언만 헤더파일에 적어놓고 cpp 파일에만 기능을 구현해놓는는것
  - 다른파일에서는 참조할때 헤더파일만 참조하여 컴파일 오류를 피하는 방식

<br><br/>

- 컴파일 → 링크 → exe 파일로 코드가 하나로 합쳐져 어셈블리 코드로 바이너리화 까지 되어 합쳐짐
- **obj 파일** 단위로 컴파일이 진행되고 **obj파일**을 합치는게 링크 과정 

___

- 분할구현을 하게되면 전역변수의 장점이 없어져버림
- 전연변수는 현재 **선언된 파일에서만** 적용됨
  - 다른 cpp 파일들에선 사용할수 없음
- 나중에 컴파일 후에는 데이터영역에 있는 전역 변수를 알수 있지만 컴파일러는 문법적으로 개발 단계에선 전역 변수의 존재를 알수 없음  

___

**분할 구현시 전역 변수의 문제점 해결하기**
- 헤더파일에 전역변수 선언하기 ❌
  - `#include` 시 참조된 모든 파일에서 전역변수가 다중 선언되어 링킹 단계에서 에러가 발생함
- 이를 해결하기 위해 정적변수, 외부 변수가 존재함

## 📍 **C/C++ 강의 25화. 정적 변수 & 외부 변수**

- **VS 단축키:** 함수를 선택하고 F12 을 누르면 선언또는 정의로 이동할수 있음

**문제점: 변수를 모든 cpp 파일에서 사용하고 싶은 상황**

**정적 변수(static)**
- 데이터 영역 사용
- 선언되는 위치에따라 차이가 있음
  - static 키워드가 의미하는 뜻 자체는 변하지 않음
- 정적 이다 == 움직이지 않는다 라는 뜻
  - c,cpp 에서 정적이다 라는 뜻은 내가 생성된,선언된 곳에서만 있다는 뜻
- 문법적으로 다른데 에서 사용하지 못하도록 제한을 건 기능
  - 전역 변수는 다른함수에서 다 사용할수 있음
  - 현재 함수에서만 사용 가능한 변수가 필요하기 때문에 만들어진 것

<br><br/>

**함수 밖에 static 변수가 선언되는 경우** 
- cpp 파일 자체에 선언 되었다는 뜻임
- 각자 파일에서만 인식되는 변수임
- 각자 파일로 지칭되어 구분할수 있기때문에 같은 이름의 static 변수라도 에러가 발생하지 않는것임 

<br><br/>

**함수 안에 static 변수가 선언되는 경우** 
- 현재 함수 안에 존재함
- 함수 안이라도 스택 메모리 영역이 아닌 **데이터 영역** 사용함
- 즉 호출 스택안에 포함이 되어있지않음
- 선언된 현재 함수안에서만 사용가능하고 데이터 영역에 남아있는 변수

- 한마디로 정리 해서, **현재 함수에서만 사용가능 하고 함수의 호출과 종료와 관계없이 프로그램 종료 시까지 데이터를 유지할수 있는 변수 가 필요할때 사용함**
  - 문법적으로는 접근 불가, 포인터등으로 접근할수있는 방법이 있긴함

___

**main.cpp**

```cpp
#include <stdio.h>
#include "func.h"

// 전역 변수
int g_i = 0;

// 정적 변수
static int g_iStatic = 0;

int main()
{
	g_iStatic = Add(1, 2);

	return 0;
}
```

**func.cpp**

```cpp
#include "func.h"

// 전역 변수
int g_i = 0; // ❌ 중복선언 링킹단계에서 에러 발생

// 정적 변수
static int g_iStatic = 0; // ✔️

int Add(int a, int b)

```

- 각각의 파일에서만 사용 가능한 동일한 이름의 정적 변수를 만든것임 

___

```cpp
int Test()
{
	static int i = 0; // 최초 한번만 실행됨

	++i;

	return i;
}

int main()
{
	Test();
	Test();
	Test();
	Test();
	int iCall = Test();

	printf("%d", iCall); // 5

	return 0;
}
```

- 함수안에 static 변수를 선언하게되면 **최초 한번만 초기화되고 여러번 초기화 되지않음**
  - 어셈블리어 까지 확인하면 조건 처리 되어있어 최초 1회만 초기화 하고 건너뛰게끔 되어있음

___

**파일 끼리의 Static  변수**

**common.h**

```cpp
#pragma once

static int i = 0;
```

**func.h**
```cpp
#include "func.h"
#include "common.h"

int return_i()
{
	++i;
	return i;
}
```

**main.h**

```cpp
#include <stdio.h>
#include "func.h"
#include "common.h"

int Test()
{
	++i;

	return i;
}

int main()
{
	Test();
	Test();
	Test();
	Test();
	i = Test();

	printf("%d", i); // 5 Test() 에서만 존재하는 i의 값

  i = return_i();

  printf("%d", i); // 1 return_i() 에서만 존재하는 i의 값

	return 0;
}
```

- 한 파일에 static 변수를 선언하고 다른파일이 `#include` 하여 사용
- 전체적으로 통용되는 변수가 아닌 각각의 파일에서만 존재하는 변수인것을 확인 할수 있음

___

**외부 변수(extern)**

- 전체파일에서 사용가능한 변수를 만들때 사용하는 것

**common.h**

```cpp
#pragma once

static int i = 0;
extern int g_iExtern; // 모든 cpp에서 참조 
int g_iExtern = 0; // 전역 변수 초기화
```

- 헤더에 배치할때 절대 초기화를 하면안됨
- `extern int g_iExtern;` 변수를 선언한게아닌 있을거다 라고 알려주는 것
  - 어떤파일이던 상관없이 초기값을 한번 전역 변수로 초기화 해줘야함
  - 컴파일시 초기화 한번을 해줌으로써 사용가능하게끔 하는것

## 📍 **C/C++ 강의 26화. 운영 체제**

- VS 가 솔루션을 생성 → 프로젝트 생성 → cpp,h파일 생성
- 프로젝트가 빌드되면 프로그램이 생성됨
- 플랫폼: 하나의 실행 기반
  - 윈도우, 안드로이드, ios, 스팀 등등...
- 솔루션 플랫폼
  - 32bit, 64bit **데이터를 처리하는 단위를 뜻함**
  - 32bit 버전
    - 이름이 x86 인이유 32비트 시절 cpu이름이 x86 이여서 이름이 굳어진것
  - 64bit 버전


**요즘 게임의 최소사양이 64bit 인 이유**

- 최근 사양의 게임들은 메모리 사용이 커지면서 32bit를 사용하면 즉, 데이터 처리 단위가 작아지면 메모리 처리가 문제가 생김 
- 32bit 를 사용한다는건 pc 성능이 좋아도 머리가 안좋은거랑 같음

## 📍 **C/C++ 강의 27화. 포인터**

- 포인터 : 주소를 가르키는 기능 
- 포인터 변수 : 주소를 가르키는, 저장하는 변수

```cpp
int* pInt = nullptr;
```

- `nullptr` 0 과 같음
  - 이 포인터가 아무것도 가르키지 않는다는 의미로 넣어줄때 사용
  - 실제 들어간 데이터는 0

```cpp
int i = 100;
int* pInt = &i;
```

- 자료형에 `*` 를 붙이면 해당 자료형을 가르키는 포인터 변수를 만들수있음
- 포인터 변수에 는 같은 자료형의 주소를 저장할수 있음

- **주소**
  - 메모리안에 데이터들을 개념적으로 구분하는 공간
  - 컴파일된 코드들은 특정 주소 위치에 값을 넣도록 명령어가 만들어짐 메모리의 위치를 지정하기 위해서임
  - 포인터는 저레벨의 기능임 주소를 가르키고 접근하고 값을 넣는 것 

**포인터 변수로 i값 수정하기**

```cpp
int i = 100;
int* pInt = &i;

// 주소로 접근
(*pInt) = 200; // i = 200;

```

- `*pInt` 포인터 변수앞에 `*` 를 붙이면 현재 저장되어있는 주소값을 **참조** 하겠다는 뜻

___

- 주소를 표현하는 방식은 **정수타입**임
  - byte 단위로 주소에 저장하기때문임
  - 100번지 - 101번지
    - 100.1 번지 ❌
- **주소의 단위**
  - 1 byte 단위로 존재함

___

```cpp
int main()
{
	int i = 100;
	float f = 3.1f;
	int* pInt = (int*)&f; // float 값을 int* 로 강제 형변환

	i = *pInt; // 1078355558

	return 0;
}
```

**포인터 변수앞에 자료형을 써주는 이유**

- **해당 포인터에게 전달된 주소를 해석하는 단위**

- 주소에 가서 int 형만큼의 사이즈 즉 4byte 만큼 접근하겠다는 뜻으로 int를 써주는 것임
- 정수형, 실수형 데이터 자료형을 구분하기 위함임
- `int*` 포인터 변수에 접근할때 해당 주소로 접근한뒤 **정수형 데이터 타입으로 값을 해석해서** 보겠다는 뜻
- `i = *pInt; // 1078355558` 부동 소수점으로 저장되어있는 실수형 데이터를 **int\* 포인터 이기때문에 정수형 데이터 타입으로 값을 해석**해서 이상한 값이 들어간것


**중요한 개념**
- 데이터는 메모리를 바라보는 해석에 관점에 따라 값이 다르게 나옴
  - `signed`, `unsigned` 
  - `int*`, `float*`

## 📍 **C/C++ 강의 28화. 포인터 배열**

- 포인터 변수
  - 변수이기때문에 무언가를 저장할수 있음
    - 주소를 저장함
  - 앞에 써져있는 자료형을 보고 접근한 주소의 데이터를 해당 자료형으로 보겠다는 것
    - 포인터 변수는 접근한 주소의 실제 데이터가 어떤 것이든 상관하지 않고 자기 앞에 써져있는 자료형으로 봄
  - `nullptr` 메모리상으로 0 를 뜻함
  - 컴파일러는 문법적으로 같은 자료형으로 맞춰주도록 도와줌

**포인터 변수의 크기**

- 포인터 변수의 크기는 고정이 아닌 플랫폼에 따라 가변적으로 설정됨
  - 32bit 면 4Byte
  - 64Bit 면 8Byte
- 32bit 
  - 4Byte 단위로 데이터를 처리함
  - 4Byte 는 처리할수있는 데이터 단위가 2^32 으로 약 42억 가지 수 나옴
    - **4GB = 약 42억 가지수** 
- 64Bit
  - 8Byte 단위로 데이터를 처리함
  - 접근가능한 주소의 크기가 `2^64 bit` 라는 것 
    - `1.8446744e+19`
  - os 가 처리하는 최대 크기가 8Byte 임으로 포인터 변수의 크기가 8Byte 로 설정되는것

```cpp
int main()
{
	int* pInt = nullptr;
	char* pChar = nullptr;
	short* pShort = nullptr;
	

	return 0
```
- 위 세개의 포인터 변수는 **크기가 같음**
- 포인터 변수는 주소를 저장하는 변수로 용도가 다 같기때문에 크기는 똑같음

___

**주소의 증감 단위**

```cpp
#include <stdio.h>

int main()
{
	int* pInt = nullptr;
	char* pChar = nullptr;
	short* pShort = nullptr;

	int i = 0;
	pInt = &i; // 주소가 100번지라고 가정

	pInt += 1; // 104 번지
	

	return 0;
}
```

- `pInt += 1;` 주소를 하나 증가 하라는 뜻
  - 주소하나를 증가하라는건 절대적인값 1이 아닌 해당 자료형의 다음 주소로 가라는 것
- 주소의 증감 단위 는 해당 포인터 변수가 가르키려고하는 자료형 단위로 움직임
  - `int*` 이면 4Byte
  - `Char*` 이면 1Byte

<br><br/>

- **pInt 는 int* 변수 이기 때문에, 가리키는 곳을 int 로 해석한다.**
- **따라서 주소값을 1 증가하는 의미는 다음 int 위치로 접근하기 위해서 sizeof(int) 단위로 증가하게 된다**

___

**배열의 특징**
1. 메모리가 연속적인 구조이다.
2. 배열의 이름은 배열의 시작 주소이다.

```cpp
int main()
{
	int iArr[10] = {};
	
  // int 단위로 접근 1번째 칸에 10을 넣겠다는 뜻
	*(iArr + 0) = 10;
	// int 단위로 접근 2번째 칸에 10을 넣겠다는 뜻
	*(iArr + 1) = 10;

	return 0;
}
```

- `\*(변수 + x) = 변수[x]`
  - 배열의 특정인덱스 주소 접근의 정체는 포인터 주소의 증감으로 접근하는 것
- 배열의 처음 인덱스를 0으로 보는 이유가 위와 같은 이유임

## 📍 **C/C++ 강의 29화. 포인터 문제 풀이 & 해답**

```cpp
#include <stdio.h>

int main()
{
	// 포인터 이해 확인 문제
	// 문제 1.
	short sArr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	int* pI = (int*)sArr;

	int iData = *((short*)(pI + 2));

	printf("1번 문제 정답: %d", iData);

	// 문제 2.
	char cArr[2] = { 1,1 };

	short* pS = (short*)cArr;

	iData = *pS;

	printf("2번 문제 정답: %d\n", iData);


	return 0;
}
```

**문제 1번 풀이**

1. `short sArr[10] = { 1,2,3,4,5,6,7,8,9,10 };` Short 자료형 2Byte 크기를 10개 가진 배열 선언
2. `int* pI = (int*)sArr;` short 배열을 int 형으로 강제 캐스팅
3. `int iData = *((short*)(pI + 2));`
   1. `(pI + 2)`  강제캐스팅되어 int 형 자료형의 크기만큼인 4byte 만큼 2번의 주소만큼 이동하여 8byte 가 이동됨
   2. `(short*)` iData 에 넣기 전에 short 단위 크기로 넣어진 데이터를 가져오기 위해 다시 short 형으로 강제 캐스팅 
   3. `*()` short 크기로 강제 캐스팅된 주소를 참조하여 가져옴 
4. 8byte 만큼 이동된 위치에 있는 값인 5 가 출력되는 것

<br><br/>

**문제 2번 풀이**

1. `char cArr[2] = { 1,1 };`  char 자료형 1byte 의 크기를 2개 가진 배열이 생성됨
2. `short* pS = (short*)cArr;` short 형으로 강제 캐스팅
3. `iData = *pS;` 주소 접근시 short 형자료크기인 2byte 만큼의 크기를 참조하게됨
  - 비트로 표현 하게되면 `0000'0001 0000'0001` 을 한덩어리로 보게됨
4. `0000'0001 0000'0001` 를 1Byte 씩 보게 되면 각각 1이지만 2Byte 로 한꺼번에 보면 257 값임 으로 257이 출력되는 것

___

**함수에 변수 주소값 넘겨주기**

```cpp
#include <stdio.h>

void Test(int* a)
{
	*a = 500;
}

int main()
{
	int a = 100;

	Test(&a);

	printf("%d", a); // 500

	return 0;
}
```

- 기본적으로 함수에서 선언된 변수는 스택메모리에 생성되어 변수의 종료와 함께 사라짐
- 위 코드와 같이 main 함수의 존재하는 a라는 변수의 주소값을 Test() 함수에 넘겨주고 그 주소값에 포인터로 접근하게 값을 변경하게되면 main 함수에 있는 a의 값이 변경됨
  - a라는 변수의 메모리에 직접 접근하는 것이기 때문에 값이 변경되어 유지될수 있는것임

___

**scanf가 주소를 요구하는 이유**

```cpp
int a = 0;
scanf("%d", &a);
```

- 콘솔창에서 입력받은 값을 a라는 변수의 메모리에 직접 접근하여 저장하기 위해서 변수의 주소값을 인자로 받는 것
- `"%d"` 데이터 타입을 알려주는것

___

**컴퓨터의 데이터 저장 방식**

![image](https://user-images.githubusercontent.com/90514882/181777772-b981e46d-dc3b-4a7e-85f5-167f97357c71.png)

- 엔디언(Endianness)은 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 특히 바이트 순서(Byte order)라 한다.

- 엔디언은 보통 큰 단위가 앞에 나오는 **빅 엔디언(Big-endian)**과 작은 단위가 앞에 나오는 **리틀 엔디언(Little-endian)**으로 나눌 수 있으며, 두 경우에 속하지 않거나 둘을 모두 지원하는 것을 미들 엔디언(Middle-endian)이라 부르기도 한다.


## 📍 ***C/C++ 강의 30화. const*

```cpp
int main()
{
  // l-value : 변수
  // r-value : 상수
  const int cint = 100; 

  return 0;
}
```
- 변수앞에 const 키워드를 붙이게 되면 **상수화**가 됨
  - **상수화: 값을 바꿀수 없게 되는 것**
- 상수화 된 값을 r-value 라고함
- 바뀔수 있는 값들을 l-value 라고함

<br><br/>

- cint 는 main() 함수의 스택 메모리에 int 만큼의 공간을 할당받고 100이라는 값을 갖고 있으며 **값을 수정하는건 안된다고 문법적으로 막혀 있는상태**
  - 실제로 cint 라는 게 100으로 바뀐 것이 아님!

___

**const 포인터로 접근해서 값 바꾸기**

```cpp
#include <stdio.h>

int main()
{
	volatile const int cint = 100;

	int* pInt = (int*)&cint;
	*pInt = 300;

	printf("%d", cint); // 300

	return 0;
}
```

- `volatile` 레지스터 최적화 사용안함
  - 휘발성 이라는 뜻 
  - 레지스터를 활용하지말고 실제 값을 확인하라고 강제로 선언하라는 뜻

1. 컴파일러는 cint값에 100을 넣고 const 키워드가 붙었으니 상수 값이다 라고 판단함

2. 포인터로 강제접근해서 300으로 바꿈

3. cpu 가 빠르게 연산할때 사용하는 레지스터값 에 기존값 100이 저장되어 있음

4. 컴파일러가 상수 값이다 라고 판단해서 레지스터에서 100을 끌어다가 printf 에 사용한것

5. volatile 키워드로 최적화를 무시하게 하여 현재 메모리에 바뀐값 300을 출력하게 수정

## 📍 **C/C++ 강의 31화. const 포인터**

- const 키워드 는 상수라고 보면됨
  - 다만 포인터 등으로 값을 바꿀수도 있음 
  - 절대적으로 안바뀐다고 생각하면 안됨

___

**포인터 변수로 가능한 연산**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int* pInt = &a;

	*pInt = 1;
	pInt = nullptr; 

	return 0;
}
```

1. 현재 포인터 변수가 가르키고 있는 메모리 주소를 바꿀수 있음 
   - `pInt = nullptr;` 
2. 포인터 변수가 가르키고 있는 메모리 주소 안의 값을 바꿀수 있음
   - `*pInt = 1;` 

___

**포인터 변수에 const 키워드가 붙었을때 가능한 연산**

- `*` 을 기준으로 const 키워드의 기능이 나뉘게됨
- 아래 내용 요약
  - `const int*` **원본 값 상수화**
    - `int const*` 같은 뜻임
  - `int* const` **포인터 변수 상수화**

**const int\***

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;

	const int* pConstInt = &a;
	*pConstInt = 100; // ❌
	*pConstInt; // 접근은 가능함

	pConstInt = &b; // ✔️

	return 0;
}
```

- 현재 포인터 변수가 가르키고있는 메모리 주소 안의 값을 못바꾸게 막는 것
- 다른 메모리 주소를 바라보는건 가능함
- `int const*` 도 같은 의미임

**int \* const**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;

	int* const pConstInt = &a;
  pConstInt = &b; // ❌

	*pConstInt = 100; // a = 100; ✔️

	return 0;
}
```

- 현재 포인터 변수가 가르키고 있는 메모리 주소를 바꿀수 없게 막는 것
- 현재 바라보고 있는 메모리 주소 안의 값은 바꿀수 있음

**동시 상수화(const int* const)**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;

	const int* const pConstInt = &b;
	
	int c = *pConstInt;

	return 0;
}
```

- 값을 참조하는건 가능함
- 현재 바라보고 있는 메모리주소나 메모리주소 안의 값을 변경할순 없음

___

**착각하기 쉬운 사항**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;

	const int* pInt = &a;
	*pInt = 100; // ❌
	
	a = 100; // ✔️

	return 0;
}
```

- `const int* pInt = &a;` 은 `*` 의 기능은 const 로 제한 한것이며 a 변수의 원본값과는 아무 상관없음!

## 📍 **C/C++ 강의 32화. const 포인터 예시**

- 함수 파라메타로 값을 넘겨주게 되면 스택 메모리에 값이 복사되서 생성되고 삭제 됨
  - 데이터 크기가 크거나, 자주 호출되면 퍼포먼스가 떨어짐
- 나중에 라이브러리등 가져다 쓸때 다른사람의 코드는 바이너리화 되어 전방선언된 부분만 확인할수 있음
- 함수 `()` 부분에 **단축키 Ctrl + Shift + Space**
  - 함수 선언 원형이 뜸

___

```cpp
#include <stdio.h>

void Output(const int* pI)
{
	int i = *pI;
	*pI = 100; // ❌
}

int main()
{
	int a = 0;

	Output(&a);

	return 0;
}
```

- 내가 전달해준 값을 통해서 값을 읽어 보고만 싶을때 const 포인터를 사용하는 것

**const int\* 를 int\*로 강제 형변환**

```cpp
#include <stdio.h>

void Output(const int* pI)
{
	int* i = (int*)pI; // const int * 를 int* 로 강제 형변환
	*i = 1000;
}

int main()
{
	int a = 0;

	Output(&a);

	a; // 1000

	return 0;
}
```

- 억지로 강제 형변환해서 바꿔버릴수있음
- 이 함수를 만든 사람의 의도를 표시하는 용도로 const 를 써주는 것
- `const_cast` 등 const 를 일반 변수로 형변환 시켜주는 것 등이 있음

## 📍 **C/C++ 강의 33화. void**

- 함수 자료형 에 void 키워드를 써주면 return 할 필요가 없음
- 포인터 앞에 자료형
  - 역참조의 자료형을 보는 용도로 사용
  - 데이터 크기와 해당 데이터를 이런 데이터로 보겠다 라고알려주는 것

**void 포인터**

```cpp
#include <stdio.h>


int main()
{
	void* pVoid = nullptr;

	{
		int a = 0;
		float f = 0.f;
		double d = 0.;
		long long ll = 0;

		pVoid = &a;
		pVoid = &f;
		pVoid = &d;
		pVoid = &ll;

		pVoid + 1; // ❌

	}
	return 0;
}
```

- void 포인터: 주소를 저장하는 변수 지만 원본으로 접근했을때 어떤 자료형으로 볼껀지 정하지 않은 포인터

**void 포인터의 특징**
1. **원본의 자료형을 정하지 않음**
2. **어떤 주소든 다 받을수 있음**
   - 주소를 넣어줬을때 그 주소의 원형을 특정 데이터타입으로 해석을 하지 않기 때문임
3. **역참조가 불가능한 이유**
   - 참조를 할려면 데이터의 크기와 데이터의 타입을 알아야하는데 void는 정해진게 없기때문에 안되는 것
4. **주소 연산도 불가능함**
   - 몇 Byte 증가할지 정해진게 없기때문에 불가능함

___

**포인터의 핵심 원리**
- 원본 데이터가 어떻게 사용되는지는 포인터와 무관
- 선언된 시점대에 해당 포인터에 선언된 자료형타입에 따라 어떻게 접근할건지 어떻게 분석할지는 포인터에서 이미 정해져있는 것
- 메모리 공간에 데이터를 저장했을때 그 타입에 정확히 매칭되는 포인터로 조작을해야 문제가 없음

## 📍 **C/C++ 강의 34화. 문자**

**메모리 영역**

1. 스택
2. 데이터 
3. 힙
4. ROM(코드)
   - Read only memory 

___

**문자**

**char**
   - 정수형 1Byte
   - character 의 약자 
   - 문자를 나타내는데에 특화된 자료형

```cpp
#include <stdio.h>


int main()
{
	char c = 1;	// 1`\x1`
	bool b = 1; // true

	return 0;
}
```
- char 는 IntelliSense가 숫자에 대응하는 문자도 같이 보여줌
- bool 은 1을 ture로 봄

**2Byte 문자**

```cpp
#include <stdio.h>

int main()
{
	wchar_t wc = 65; // 65`A`
	short s = 65; // 65

	return 0;
}
```

- wchar_t는 IntelliSense가 아스키코드로 65에 대응되는 문자 `A`을 표현해줌

___

- 문자 이미지를 저장해놓은 표가 있음
- 문자의 그림형태를 메모리에 저장해놓고 특정 숫자가 보이면 그 숫자에 대응되는 문자를 보여줌
- a 는 2진수로 97이라는 값으로 저장이됨

___

```cpp
char c = 1; // 1`\x1`
c = '1'; // 49'1'
```

- 메모리에서 1이라는 값이랑 문자로써 1 이라는 값은 다른값임
- 문자로 '1' 이라는 값은 아스키코드로 49이 대응되기때문에 49값이 저장되는 것

___

```cpp
#include <stdio.h>

int main()
{
	wchar_t wc = 459; 
	"459"; 

	return 0;
}
```

- `wchar_t wc = 459;`
  - 2Byte 공간에 459라는 숫자가 2진수로 저장되어 있는 것
- `"459";`
  - 문자열이라는 뜻으로 `""` 을 사용함
  - 각각 한자리수 마다 아스키코드로 값이 저장되어있음
  - 한자리당 255 내외로 저장이 가능하니 1Byte씩 차지해서 넣음
- **문자열의 끝을 알려주는 용도로 0을 넣어줘야함**
  - NUL 문자라고 함
- 스페이스 한칸을 띄우면 32라는 아스키코드값이 메모리에 저장되어있는 것

## 📍 **C/C++ 강의 35화. 문자열 (1)**

**문자 전용 자료형**
- char(1), wchar(2)

- 표현방식은 정수형이지만 그 정수에 대응하는 문자를 IntelliSense가 보여줌
- 1Byte 로 표현가능한 가지수는 128가지 
  - 맨 앞의 비트수는 뒤에있는 글자가 몇 Byte 인지 확인해야해서 0 ~ 127 까지 사용 하는 것
  - 아스키코드도 0~127까지씀

___

**문자열**

```cpp
#include <stdio.h>

int main()
{
	char a = 'a';
	wchar_t wc = L'a';

	char szChar[10] = "abcdef";
	wchar_t swChar[10] = L"abcdef";
  wchar_t swChar2[10] = { 97,98,99,100,101,102, }; // 위 코드랑 똑같이 작동함

  char szChar3[6] = L"abcdef"; // Error Nul 문자가 들어갈 공간이 없음

  short arrShort = L"abcdef"; // Error short 로는 문자열로 초기화를 허용해 주지 않음

	return 0;
}
```

- 1Byte에 문자를 사용할때는 `' '` 를 사용함
- 2Byte단위로 문자를 사용하겠는 뜻으로 `L' '` 를 사용함
  - 저장하고있는 문자 단위 하나하나가 2Byte라는 것을 알려주는 의미
- 문자열은 끝에 NUL 문자가 포함될 공간도 필요함
- short 는 문자열로 초기화를 허용해주지않음

<br><br/>

**문자열 과 문자열 포인터의 차이**

```cpp
#include <stdio.h>

int main()
{
	wchar_t swChar[10] = L"abcdef";
	const wchar_t* pChar = L"abcdef";

	swChar[1] = 'z'; // b를 z로 바꾸겠다는것
  // pChar[1] = 'z' == *(pChar + 1) = 'z'; // const 임으로 접근불가 Error

	return 0;
}
```
- `wchar_t swChar[10] = L"abcdef";` 
  - 20Byte 만큼의 배열을 잡고 문자 하나하나를 복사해서 저장하는 것
- `swChar[1] = 'z';`
  - main 함수 스택 메모리에 저장되어있는 배열에 저장되어있는 1번지 메모리의 b값을 z로 바꾸겠다는 것

<br><br/>

- `const wchar_t* pChar = L"abcdef";`
  - 다이렉트로 문자열을 가르키고 있음 
  - 포인터 변수로 문자열의 시작 주소를 가르키고 있는 것
- 문자열의 정체가 **주소값**임으로 포인터에 넣을수 있는 것
- 2Byte 정수 문자 단위로 저장하기 때문에 wchar_t 로 맞춰준것
- `pChar[1] = 'z' == *(pChar + 1) = 'z';`
  - `L"abcdef";` **원본 코드** 자체에 접근하려는 것
    - 이러한 원본 코드는 ROM 에 저장되어있어 코드가 수정되지않게 보호되어있음
- 문자열들은 ROM 에 따로 저장되어있고 여러번 접근해서 사용하는 방식
  - 이러한 수정 불가능한 **원본 코드** 데이터를 사용하기위해 const 포인터로 받아오는 것
- **문자열의 반환타입이 const wchar_t\* 임** 
- 옛날컴파일러는 일반 포인터 였음
  - 지금도 강제 캐스팅하면 받아올수있음
  - 프로그램 실행중 **코드 데이터**를 수정하게되면 프로그램이 터짐 컴파일러 단계에서 잡을수 없는 런타임 에러임

## 📍 **C/C++ 강의 36화. 문자열 (2)**

**multi byte character set**

- **multi byte character set: 특정문자는 1Byte로 표현하고 2Byte로 표현하는 문자는 2Byte 로 표현하는 방식**
- 문자에따라 가변길이로 대응하는것

```cpp
#include <stdio.h>

int main()
{
	int a = 0;

	char szTest[10] = "abc한글";

	return 0;
}
```

- `한글` 이라는 문자는 매칭되는 인덱스 숫자가 굉장히 큼
- `abc` 까지는 1Byte로 문자가 저장되고 `한`,`글` 이라는 문자는 각각 2Byte씩으로 문자에 저장됨

**multi byte character set의 문제점**

- MS Windows 에서만 사용하는 기능임
  - 이전 Windows 호환성때문에 유지중인기능
- **표준 기능이 아님**
- 인코딩으로 넘어갈때 요즘 많이 사용하는 것은 UTF-8 이라는 문자 인코딩방식 이 있음
- multi byte character set은 UTF-8과의 호환성때문에 2Byte 방식으로 넘어간뒤 인코딩해야 하기 때문에 잘 사용되지 않음
- 문자가 나열되어있을때 문자열의 갯수가 애매모호 해짐
  - 1Byte 인지 2Byte로 저정될지 확정적이지 않음
- 2Byte 문자의 뒷 숫자의 bit값을 확인 해보면 110으로 시작됨
  - Ex) `글` 이라는 문자는 `177 219` 로 저장됨
  - (177) 0111 0101 / (219) 1101 1011
    - 219 의 시작 부분이 110으로 시작됨

___

**Wide Byte Character Set**

```cpp
#include <stdio.h>

int main()
{
	int a = 0;

	char szTest[10] = "abc한글"; // multi byte character set

	wchar_t szTestW[10] = L"abc한글"; // Wide Byte Character Set

	return 0;
}
```

- **Wide Byte Character Set: 모든 문자를 2Byte로 표현하는 방식**
- **유니코드** 라고도함

- VS 솔루션 디폴트 값도 유니코드로 되어있음
  - 솔루션 - 속성 - 고급 속성 - 고급 - 문자 집합 - 유니코드 문자 집합 사용
  - 이설정의 의미하는 바는 전처리기가 조건부 컴파일
- multi byte 와 Wide byte 두가지를 동시에 혼용하여 사용하는 경우도 있기때문에 전처리기 라고해서 저 옵션으로 조건부 컴파일된 함수들을 사용할때 나눠서 컴파일해줌
  - 보통 이름에 t가 붙은 함수임 
  - 멀티 바이트로 사용하면 멀티 바이트 함수로 바꿔서 컴파일
  - 유니코드로 사용하면 2Byte 기준 문자열 함수로 바꿔서 컴파일 해줌

___

**문자열 안의 문자 갯수 세기 wcslen()**

```cpp
#include <stdio.h>
#include <wchar.h> // wcslen() 를 사용하기 위해 헤더 참조


int main()
{
	wchar_t szName[10] = L"Raimond";

	int iLen = wcslen(szName); // 7

	return 0;
}
```

- `#include <wchar.h>` 헤더사용
- **wcslen(); 함수**
  - **문자열의 길이를 확인하는 함수**
  - 인자로 `const wchar *` 를 요구함 
    - 주소를 전달하면 원본데이터가 수정될 위험이 있기 때문에 cosnt 로 인자를 받음
  - 범용적으로 함수를 사용하기 위해 어떤 문자열을 전달해주더라도 길이가 잘 나와야함
    - 따라서 **문자열의 시작주소**를 넘겨줘야하는 것
- 문자열은 엄밀히 말하면 코드 영역이 아닌 **데이터 초기화 영역**에 존재함
  - ROM 내부에 코드, 데이터 초기화 영역이 존재함
  - **데이터 초기화영역: 초기화 데이터를 저장해놓는 영역**
  - **문자열은 ROM 에 저장된다**

## 📍 **C/C++ 강의 37화. 문자열 (3)**

**wcslen() 직접 구현하기**

- 배열의 길이를 알려주는 코드를 직접 구현해보자
- 문자열의 끝에는 NUL 문자가 있기 때문에 이런 특징을 이용
- NUL 문자는 `'\0'` 으로 표현하고 **아스키코드로 0에 대응됨**

<br><br/>

```cpp
#include <stdio.h>
#include <wchar.h>

unsigned int GetLength(const wchar_t* _pStr)
{
	// 문자 개수 체크 용도
	int i = 0;

	while (true)
	{
		wchar_t c = *(_pStr + i); // _pStr[i]; 와 같음

		if ('\0' == c)
		{
			break;
		}

		++i;
	}

	return i;
}


int main()
{
	wchar_t szName[10] = L"Raimond";

	int iLen = GetLength(szName); // 7

	return 0;
}
```

- 반환타입으로 글자의 갯수를 알려줘야함
  - 갯수가 음수일 경우는 없으니 `unsigned int` 설정 
- 2Byte 문자 배열 의 길이를 알려주는 함수 임으로 **const wchar_t *** 로 주소값을 받아오기
  - 원본 데이터가 수정이 안된다는 의미로 const 키워드를 붙여줌

___

**while 문 조건 간단하게 바꾸기**

```cpp
#include <stdio.h>
#include <wchar.h>

unsigned int GetLength(const wchar_t* _pStr)
{
	// 문자 개수 체크 용도
	int i = 0;

	while ('\0' != _pStr[i]){ ++i;}

	return i;
}


int main()
{
	wchar_t szName[10] = L"Raimond";

	int iLen = GetLength(szName); // 7

	return 0;
}
```

- `'\0'` 이 아닐때까지 계속 i++ 해서 문자의 갯수를 세는것
- **비교연산시 왼쪽에 상수를 배치하는 습관 들이기**
  - 실수로 `==`을 `=` 으로쓰는경우 `변수 = 상수` 면 변수에 상수값이 들어간다음 참,거짓 체크를 하게 되니 `상수 == 변수` 형태로 써주는 것

___

**문자열 이어 붙이는 함수 wcscat_s();**

- 첫번째 인자로 붙임 당할 배열, 두번째 인자로 붙일 배열 을받음
  - 첫번째 인자의 배열은 수정이되야 함으로 const가 붙지않음
  - 두번째 인자의 배열은 값만 읽을 용도로 const가 붙음

## 📍 **C/C++ 강의 38화. 문자열 (4)**

**문자열 이어 붙이는 함수 wcscat_s();**

- 오버로딩 되어있어 함수가 두개가 존재함


**함수 오버로딩**

```cpp
#include <stdio.h>
#include <wchar.h>

void Test(int a)
{

}

void Test(float a)
{

}

void Test(int a, int b)
{

}

int main()
{

	return 0;
}
```

- **함수 오버로딩:** 같은 이름의 함수의 인자 값의 데이터 타입이나 인자의 갯수가 다르면 동일한 이름의 함수를 여러개 만들수 있는 기능

___

**문자열 이어 붙이는 함수 wcscat_s();**

**wcscat_s(); 매개변수**
- `strDestination`: Null 종료 대상 문자열 버퍼입니다.
- `numberOfElements`: 대상 문자열 버퍼의 크기입니다.
- `strSource` : null 종료 소스 문자열 버퍼입니다.

```cpp
#include <stdio.h>
#include <wchar.h>


int main()
{
	wchar_t szString[100] = L"abc";

	wcscat_s(szString, 100, L"def");



	return 0;
}
```

- 세번째 인자로 `L"def"` 를 넣어줘도 상관없는이유
  - 매개변수로 문자열의 주소값을 넣어주면되기때문에 **문자열은 ROM 메모리 영역에 const char_t \*** 형태로 저장되기때문에 사용할수 있는 것

- `wcscat_s();` 함수 두번째 인자로 첫번째 배열의 길이값을 받아가는 이유
  - 문자열을 합칠때 범위를 초과하는지 체크하기위함
  - 실제 첫번째 배열의 값과 다른값을 적어도 컴파일 에러는 발생되지 않음

- `wcscat_s();` 첫번째 함수는 템플릿 버전임
  - 배열의 크기를 템플릿으로 받아가서 자동으로 인식하는 방식

___

**wcscat_s(); 직접 구현하기**

- `#include <assert.h>`
  - 매크로 함수로 특정함수를 호출하도록 코드가 바뀜
    - `_wassert()`
  - 코드를 중단시키고 문제를 발생시켜서 인자에 따라서 원하는 메세지를 띄울수 있음 

<br><br/>

- 코드 작업시 머리로만 코드를 짜지말고 뭘 해야할지 리스트로 적어놓고 하나씩 작업하기
  - 리스트를 적어놓으면 내용 전달에도 용이함
- 코드는 고민을 오래하고 실제로 코드를 짜는 시간은 많지않음

<br><br/>

1. **에외 처리** 첫번째 배열 길이 + 두번째 배열 길이 + 1 와 두번쩨 인자의 크기 비교 
   - 1은 `'\0'` 이 들어갈 공간 
2. Dest 문자열의 끝을 확인( 문자열이 이어 붙을 시작 위치)
3. 반복적으로 Src 문자열을 Dest 끝 위치에 복사하기
4. Src 문자열의 끝을 만나면 반복 종료

<br><br/>

**완성 코드**

```cpp
#include <stdio.h>
#include <wchar.h>
#include <assert.h> // 예외 처리 

unsigned int GetLength(const wchar_t* _pStr)
{
	// 문자 개수 체크 용도
	int i = 0;

	while ('\0' != _pStr[i]) { ++i; }

	return i;
}

void StrCat(wchar_t* _pDest, unsigned int _iBufferSize, const wchar_t* _pSrc)
{
	// 예외처리
	// 이어붙인 최종 문자열 길이가, Dest 저장 공간을 넘어서려는 경우
	int iDestLen = GetLength(_pDest);
	int iSrcLen = GetLength(_pSrc);

	if (_iBufferSize < iDestLen + iSrcLen + 1) // Null 문자 공간까지 계산
	{
		assert(nullptr);
	}

	// 문자열 이어 붙이기 
	// 1. Dest 문자열의 끝을 확인( 문자열이 이어 붙을 시작 위치)
	iDestLen; // Dest 문자열의 끝 인덱스
	 
	// 2. 반복적으로 Src 문자열을 Dest 끝 위치에 복사하기
	// 3. Src 문자열의 끝을 만나면 반복 종료
	for (int i = 0; i < iSrcLen + 1; ++i)
	{
		_pDest[iDestLen + i] = _pSrc[i];

	}
}


int main()
{
	wchar_t szString[10] = L"abc";

	StrCat(szString, 10, L"def");

	return 0;
}
```

___

**과제 `wcscmp();` 함수 구현하기**

```cpp
int main()
{
	int iRet = wcscmp(L"a", L"b"); // -1
	int iRet2 = wcscmp(L"b", L"a"); // 1
	int iRet3 = wcscmp(L"a", L"a"); // 0

	return 0;
}
```

- `wcscmp();`
  - 두개의 문자열을 전달받아 두 문자열의 상태를 확인하는 함수
  - 두 문자열이 일치하면 0 을 반환해줌
  - 두 문자열중 왼쪽 문자열이 우열이 높다면 -1 반대의 경우 -1을 반환
    - 우열이 높다: 사전에서의 순서의기준

**내 과제 풀이**

```cpp
#include <stdio.h>
#include <wchar.h>
#include <assert.h>

unsigned int GetLength(const wchar_t* _pStr)
{
	// 문자 개수 체크 용도
	int i = 0;

	while ('\0' != _pStr[i]) { ++i; }

	return i;
}

void StrCat(wchar_t* _pDest, unsigned int _iBufferSize, const wchar_t* _pSrc)
{
	// 예외처리
	// 이어붙인 최종 문자열 길이가, Dest 저장 공간을 넘어서려는 경우
	int iDestLen = GetLength(_pDest);
	int iSrcLen = GetLength(_pSrc);

	if (_iBufferSize < iDestLen + iSrcLen + 1) // Null 문자 공간까지 계산
	{
		assert(nullptr);
	}

	// 문자열 이어 붙이기 
	// 1. Dest 문자열의 끝을 확인( 문자열이 이어 붙을 시작 위치)
	iDestLen; // Dest 문자열의 끝 인덱스
	 
	// 2. 반복적으로 Src 문자열을 Dest 끝 위치에 복사하기
	// 3. Src 문자열의 끝을 만나면 반복 종료
	for (int i = 0; i < iSrcLen + 1; ++i)
	{
		_pDest[iDestLen + i] = _pSrc[i];

	}
}

int StrCompare(const wchar_t* _firStr, const wchar_t* _SecStr)
{
	// 1. int 변수 하나 초기값 0 으로 설정 후 둘 중 한배열의 끝까지 반복문 
	int flag = 0;
	int loopCnt = GetLength(_SecStr);
	
	for (int i = 0; i < loopCnt + 1; ++i)
	{
		// 2. 한 글자씩 배열 을 비교해서 같으면 continue 
		if (_firStr[i] == _SecStr[i]) continue;
		else 
		{
			// 3. 두배열이 다를경우 첫번째 배열이 클 경우 -1 값 두번째 배열이 클 경우 1을 변수에 넣고 함수 종료
			if (_firStr[i] < _SecStr[i]) flag = -1;
			else flag = 1;

			break;
		}
	}

	return flag;
}


int main()
{
	wchar_t szString[10] = L"abc";

	StrCat(szString, 10, L"def");
	int iRet = wcscmp(L"a", L"b"); // -1
	int iRet2 = wcscmp(L"b", L"a"); // 1
	int iRet3 = wcscmp(L"a", L"a"); // 0

	int iRet4 = StrCompare(L"a", L"b"); // -1
	int iRet5 = StrCompare(L"b", L"a"); // 1
	int iRet6 = StrCompare(L"a", L"a"); // 0


	return 0;
}
```

- flag 값을 설정하고 초기값을 0으로 초기화
- 두 배열의 문자을 하나씩 비교

**두 배열의 길이가 다를경우**
- 두 배열의 길이가 다르게 들어올경우는 대비하여 마지막 `'\0'` 와 값을 비교하도록 구성함
- 두번째 배열의 크기가 더 클경우를 대비해서 반복문에 +1 을 넣어서 첫번째 배열의 `'\0'` 까지 비교하게 구성 
- 첫번째 배열의 크기가 클경우 첫번째 배열의 값 과 아스키코드값 0 과 비교하게되어 flag에 1이 들어가게됨
  - 반대로 두번째 배열의 크기가 더 클경을 flag에 -1을 넣도록 구성

## 📍 **C/C++ 강의 39화. 문자열 문제 풀이**

- 구현할때 감도 안오고 어떻게 시작할지 모르는 상황에서 포기하지않고 검색하고 찾고 질문하고 시도하다보면 윤곽이 잡힘

- 길이가 다른 코드 끼리 비교할때 짧은 쪽이 우선순위가 더 높음 
  - 가 > 가나 

**과제 풀이 정답 코드**

```cpp
#include <stdio.h>
#include <wchar.h>
#include <assert.h>

unsigned int GetLength(const wchar_t* _pStr)
{
	// 문자 개수 체크 용도
	int i = 0;

	while ('\0' != _pStr[i]) { ++i; }

	return i;
}

int StrCmp(const wchar_t* _left, const wchar_t* _right)
{
	int leftLen = GetLength(_left);
	int rightLen = GetLength(_right);

	int iLoop = leftLen;
	int iReturn = 0;
	
	if (leftLen < rightLen)
	{
		iLoop = leftLen;
		iReturn = -1;
	}
	else if (leftLen > rightLen)
	{
		iLoop = rightLen;
		iReturn = 1;
	}

	for (int i = 0; i < iLoop; ++i)
	{
		if (_left[i] < _right[i])
		{
			return -1;
		}
		else if (_left[i] > _right[i])
		{
			return 1;
		}
	}

	return iReturn;
}

int main()
{
	wchar_t szString[10] = L"abc";

	StrCat(szString, 10, L"def");
	int iRet = wcscmp(L"a", L"b"); // -1
	int iRet2 = wcscmp(L"b", L"a"); // 1
	int iRet3 = wcscmp(L"abc", L"a"); // 0

	iRet = StrCmp(L"abc", L"abb");

	return 0;
}
```

## 📍 **C/C++ 강의 40화. 구조체 포인터**

**구조체**

```cpp
typedef struct _tagMyST
{
	int a; // 멤버
	float f;
}MYST;

int main()
{
	MYST s = {};
	MYST* pST = &s;
	pST + 1; // 8Byte 씩 메모리 이동
	(* pST).a = 100; // s 변수의 a멤버에 값에 100을 넣겠다는것
	(* pST).f = 3.14f // int 형 타입의 4Byte 만큼 떨어진 메모리 자리에 3.14f 값을 넣겠다는 뜻 

	// 역참조 요약
	pST->a = 100;; // (* pST).a = 100; 랑 동일함
	pST->f = 3.14f; // (* pST).f = 3.14f 랑 동일함
	return 0;
}
```

- 구조체: 내가 직접 만드는 자료형

- 메모리에 int타입의 4Byte만큼의 공간 a파트, float타입의 4Byte만큼의 공간 f파트가 잡혀 총 8Byte 공간이 생성됨 
  - a랑 f는 변수가 아닌 메모리 파트를 지칭하는 **멤버**임
    - `MYST s = {};` `s`가 변수임
  - 변수는 자료형으로 실체를 만드는것 스택 메모리에 메모리를 할당받아 자리를 잡는것

## 📍 **C/C++ 강의 41화. 동적할당 (1)**

**malloc();**

```cpp
#include <iostream>

// 변수
// 지역(스택)
// 전역, 정적, 외부(데이터)

// 메모리 영역
// 스택
// 데이터
// ROM
// 힙 영역(동적할당)

int main()
{
	int* pInt = (int*)malloc(100);


	return 0;
}
```

- `memory allocate` 메모리 할당함수임
 - 내가 지정한 사이즈만큼 힙영역에 공간을 만들고 그 공간의 시작주소를 리턴해주는 함수
  - 단위는 Byte임
  - 주소값을 리턴해주기때문에 포인터로 받아야함
- 반환 타입이 `void*` 임 
  - 주소만을 저장하기위한 데이터임
  - 사용할 포인터의 강제 캐스팅이 필요함
    - 힙영역을 무슨 영역으로 사용할지 포인터타입으로 정하는 것
  - 실시간 으로 생성 될수도 안될수도 있기때문에 메모리 시작 주소를 리턴 해주는 것
 
**힙 영역**

- 기존에는 데이터 영역들은 함수가 호출되는 순간 변수들이 메모리에 생성되어 존재함
- 변수는 이미 코드로 만들어 놓은 것
  - 변수라는건 애초에 정해져있는 것이기 때문에 힙영역을 사용이 불가능함

- 힙 영역은 프로그램 실행도중에 대응가능한 메모리임
  - 런타임 할당
  - 다이나믹 동적으로 할당

## 📍 **C/C++ 강의 42화. 동적할당 (2)**

```cpp
#include <iostream>

int main()
{
	float* pF = (float*)malloc(100);
	int* pI = (int*)pF;

	*pF = 2.4f;

	int i = *pI; // 부동소수점 방식으로 저장된 데이터를 정수형 데이터타입으로 해석하여 엄청큰 값이 나옴

	return 0;
}
```

- pF 와 pI 는 바라보고있는 주소값이 동일함

___

- 메모리 공간자체 는 목적이 없음 
- 기존 변수들은 자료형을 통해서 용도를 결정했다면 힙 메모리 동적할당은 내가 원하는만큼 공간을 할당하고 포인터타입을 통해서 용도를 결정하는것

**동적할당 중요한 점**
1. 런타임 중에 대응 가능
2. 사용자가 직접 메모리를 관리해야함(해제) 

```cpp
#include <iostream>

int main()
{
	int iInput = 0;
	scanf_s("%d", &iInput);

	int* pInt = nullptr;

	if (100 == iInput)
	{
		pInt = (int*)malloc(100);
	}

	if (nullptr != pInt)
	{
		free(pInt);
	}

	return 0;
}
```

- `free()` 주소를 전달해주면 그 주소가 가르키는곳을 해제 시켜주는 함수
  - 힙 메모리 이외에 스택 메모리, 전역변수 메모리 를 넣어주면 안됨 문제생김
- `pInt` 가 해제되는 것이아닌 그 안에 힙메모리를 해제해주는 함수임

___

- 내가 쓰던 메모리 공간을 해제를 안시켜놓고 프로그램이 종료되는것을 **메모리 누수** 라고함
  - 여러번 실행될수록 메모리가 쌓여감
  - os가 관리해주긴하지만 많이 누수되면 옛날에는 시스템 메모리 부족 현상이라고 하면서 컴퓨터를 재부팅 하라고함

- 디버깅 모드에서만 동작하는 메모리누수를 잡아주는 함수가 존재함

___

**쓰레기 수집(garbage collection)**
- 상황에따라서 지역변수로  처리될수도있고 내부적으로 동적할당으로 처리될수도 있음
- 사용자가 느낄수 없고 알아서 처리함
- `자바, C#` 등에서 사용됨 

- **가상 머신**
  - os 에서 해당언어 전용 프로그램 위에서 사용자가 작성한 프로그램이 실행됨
  - 가상머신 안에 동적할당이 발생해야하는 부분이 있으면 모아 놓고 해제해줌
  - 이러한 기반하에 동작하기때문에 메모리 관리를 신경을 덜쓸수 있는 것
  - 더 퍼포먼스를 올릴려고하면 오히려 더 어려울수있음

___

**함수의 메모리 할당과 해제**


**어셈블리어 코드**

```cpp
#include <iostream>

void Test(int a)
{
// 메모리 할당 영역
00007FF6E0FC1760  mov         dword ptr [rsp+8],ecx  
00007FF6E0FC1764  push        rbp  
00007FF6E0FC1765  push        rdi  
00007FF6E0FC1766  sub         rsp,0E8h  
00007FF6E0FC176D  lea         rbp,[rsp+20h]  
00007FF6E0FC1772  lea         rcx,[__600AB9A2_mian2@cpp (07FF6E0FD1066h)]  
00007FF6E0FC1779  call        __CheckForDebuggerJustMyCode (07FF6E0FC1352h)  
	printf("%d", a);
00007FF6E0FC177E  mov         edx,dword ptr [a]  
00007FF6E0FC1784  lea         rcx,[string "%d" (07FF6E0FC9BD8h)]  
00007FF6E0FC178B  call        printf (07FF6E0FC13B6h)  
}
// 메모리 해제 영역
00007FF6E0FC1790  lea         rsp,[rbp+0C8h]  
00007FF6E0FC1797  pop         rdi  
00007FF6E0FC1798  pop         rbp  
00007FF6E0FC1799  ret  
```

- 디버깅중 브레이크 포인트 잡고 함수에 마우스 우클릭 → 디스어셈블리어로 이동(Ctrl + K , G)

- 스택,데이터 영역 메모리의 함수나 변수는 실행될때 메모리 영역을 얼만큼 잡을지 정해져있기 때문에 프로그램이 종료될때 정해진 만큼 메모리를 해제 해주면 됨으로 따로 해제를 안해줘도됨


**원본 코드**

```cpp
#include <iostream>

void Test(int a)
{
	printf("%d", a);
}

int main()
{
	Test(10);

	return 0;
}
```

- 간단한코드도 기계어로 많은 구문이 생성되어 스택메모리 할당,해제도 컴파일러가 알아서해줌

## 📍 **C/C++ 강의 43화. 가변 배열 (1)**

```cpp
#include <iostream>

int g_i = 100;

typedef struct _tagST
{
	int iArr[g_i]; // Error
}ST;

int main()
{
	int a = 100;

	int arr[a] = {}; // Error

	return 0;
}
```

- 함수 가 실행될때 스택메모리 크기가 미리 계산되어있어야하는데 변수 배열을 만들려고 하게되면 런타임중 값이 변할수 있기 때문에 컴파일에러가 발생하는것
- 구조체도 자료형이기 때문에 스택도 안되고 자료형 파악도 안되기때문에 변수로 배열을 만들려하면 에러가 발생하는 것 
- 배열 개수를 선언할 때에는 변수를 사용 할 수 없다.
  
___

**객체(Instance)**
- `int a` 라고했을때 a를 객체라고함
- 객체란 내가 의도한 자료형의 실질적인 데이터를 뜻함

- 가변 배열을 만들수 있는 자료형을 만들예정
- 가변 배열이라는 기능을 하기위한 멤버들로 구성을해야함

## 📍 **C/C++ 강의 44화. 가변 배열 (2)**

**Arr.h**

```cpp
#pragma once

// int 형 가변 배열
typedef struct _tabArr
{
	int*	pInt;
	int		iCount;
	int		iMaxCount;

}tArr;
```

**가변 배열 필수 멤버 3가지**

1. 구조체 자체는 동적으로 할당되어 생성이 불가능함
  - 구조체 자체도 자료형 임으로 각 멤버의 사이즈와 크기 정해져있어야함
  - **따라서 첫번째 멤버로 힙 메모리의 시작 주소인 포인터가 필요한것임**
2. 현재 힙 메모리의 객체 갯수를 세주기 위해 두번째 멤버로 int 변수한개 생성
3. 힙 메모리의 최대값을 저장하기 위해 세번째 멤버로 int 변수 한개 선언
  - 최대치를 넘어가면 추가로 할당 받아야하기 위해 요청받은 값을 저장하는 것

___

**int 타입 가변 배열 설계**

- **단축키:** 전방 선언 함수에 `Ctrl + . → 선언/정의 만들기(c)` 누르면 cpp파일에 바디를 만들수있음

**void InitArr(tArr* _pArr)**

- **객체를 초기화 해주는 함수**
- 가변 배열의 객체에 힙메모리에 있는 값에 접근해야하기 때문에 함수 인자로 객체의 주소값을 전달 받음
- `sizeof(int)* 2` 이값도 결국 상수값임 8Byte 로 써줘도 되지만 이렇게 작성하면 int 자료형을 2개 쓰겠다는 의미가 표현됨으로 더 직관적임
- 객체가 지워지기 전에 힙메모리를 해제 해줘야함

**void ReleaseArr(tArr* _pArr)**

- **객체의 메모리 해제를 해주는 함수임**
- 어떤 객체의 메모리를 해제할건지 알아야하기 때문에 객체의 주소값을 인자로 받음
- free() 함수로 힙메모리 데이터를 초기화 해줌
- 해제되는 데이터 임으로 현재 요소 갯수와 최대 갯수를 0 으로 초기화

**void PushBack(tArr* _pArr, int _iData)**
- **객체에 데이터를 넣어주는 함수**
- 어떤 객체에 데이터를 넣을건지 알아야하기 때문에 객체의 주소값을 첫번째 인자로받음, 넣을 데이터를 두번째 인자로 받음

1. 데이터를 넣기전 힙영역 공간이 꽉찼는지 확인하고 꽉찼다면 재할당 요청
2. 객체에 데이터를 넣고 iCount 값을 증가 시켜주기

**void Reallocate(tArr* _pArr)**
- 힙영역의 공간이 곽차면 재할당 해주는 함수

___

**소스 코드**

**main.cpp**

```cpp
#include <iostream>
#include "Arr.h"

int main()
{
	tArr s1 = {};

	InitArr(&s1);

	for (int i = 0; i < 10; ++i)
	{
		PushBack(&s1, i);
	}

	ReleaseArr(&s1);

	return 0;
}
```

**Arr.cpp**

```cpp
#include "Arr.h"
#include <iostream>

void InitArr(tArr* _pArr)
{
	_pArr->pInt = (int*)malloc(sizeof(int)* 2); 
	_pArr->iCount = 0;
	_pArr->iMaxCount = 2;

}

void Reallocate(tArr* _pArr)
{
}

void PushBack(tArr* _pArr, int _iData)
{
	// 힙 영역에 할당한 공간이 다 참
	if (_pArr->iMaxCount <= _pArr->iCount)
	{
		// 재할당
		Reallocate(_pArr);
	}

	_pArr->pInt[_pArr->iCount++] = _iData;
}

void ReleaseArr(tArr* _pArr)
{
	free(_pArr->pInt);
	_pArr->iCount = 0;
	_pArr->iMaxCount = 0;
}
```

**Arr.h**

```cpp
#pragma once

// int 형 가변 배열
typedef struct _tabArr
{
	int*	pInt;
	int		iCount;
	int		iMaxCount;

}tArr;

// 배열 초기화 함수
void InitArr(tArr* _pArr);

// 데이터 추가 함수
void PushBack(tArr* _pArr, int _iData);

// 공간 추가 확장
void Reallocate(tArr* _pArr);

// 배열 메모리 해제 함수
void ReleaseArr(tArr* _pArr);
```

## 📍 **C/C++ 강의 45화. 가변 배열 (3)**

**malloc()**
- 내가 요청한 Byte 만큼의 힙영역을 잡아주고 그 위치의 시작주소값을 리턴해주는 함수
- 이때 잡히는 힙영역의 위치는 지정할수가 없음

___

**힙손상(heap corruption detected)**

- 힙영역에 잘못 접근하게되면 잡기가 굉장히 힘듬
  - 잘못 접근된 값을 사용할때 그 순간에 에러가 발생하기 때문에 나중에서야 발생하는 경우가 많음
- 내가 할당받지 않은 공간을 사용하는것도 문제가됨
  - os는 쓰이지 않는 공간이라고 생각했는데 그 위치에 접근하거나 하게되면 힙손상 이 발생함
- 힙손상은 결국 포인터를 잘못사용해서 발생하는 것

___

**void Reallocate(tArr* _pArr)**

- **힙영역의 공간이 곽차면 재할당 해주는 함수**
- 힙 영역은 기존 메모리에 연속해서 다음 위치를 지정해서 할당을 받을수 없기 때문에 한번에 많은 공간을 새로 받아야함
  - 기존 메모리가 40Byte 였다면 80Byte 같이 크게 새로 할당 받아야함

1. 기존 메모리의 2배만큼의 메모리 공간을 새롭게 동적할당 해줌
   - 현재 메모리 최대 사이즈 * 2 * int 데이터 사이즈 
   - 새로 할당받은 공간은 함수의 지역 변수로써 저장시켜줌
2. 기존 공간에 있던 데이터들을 새로 할당한 공간으로 복사시킨다.
3. 기존 공간은 메모리 해제
4. 배열이 새로 할당된 공간을 가리키게 한다.
5. MaxCount 변경점 적용

___

**Reallocate() 숨기기**
- 특정 기능을 cpp,h 묶어서 구현
- **자료형과 관련된 각종 함수들 외부에 공개하기 싫은것은 헤더에 추가 안하고 내부 cpp 파일에만 구현해서 사용**
- Reallocate() 함수는 힙 메모리가 꽉찼을때만 재할당 받을 용도로 만든함수인데 main 함수나 다른함수에서 뜬금없이 호출할수도 있음
- 헤더파일에 전방선언이 되어있고 참조되는 main 함수에서도 호출할수있음
- Arr.cpp 파일 안에서는 구현이 되어있기 때문에 사용가능 하며 굳이 헤더파일에 명시해서 참조되는 파일마다 보일 필요가 없으므로 헤더파일에서 전방선언된 부분 삭제 

___

- 가변 배열도 자료구조임
- 데이터를 계속해서 확장하며 넣는 구조를 가변 배열이라고함

___

**소스 코드**

**main.cpp**

```cpp
#include <iostream>
#include "Arr.h"


int main()
{
	tArr s1 = {};

	InitArr(&s1);

	// 힙 영역에 데이터 추가
	for (int i = 0; i < 10; ++i)
	{
		PushBack(&s1, i);
	}

	// 힙 영역 데이터 출력하기
	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.pInt[i]);
	}

	ReleaseArr(&s1);

	return 0;
}
```

**Arr.cpp**

```cpp
#include "Arr.h"
#include <iostream>

void InitArr(tArr* _pArr)
{
	_pArr->pInt = (int*)malloc(sizeof(int)* 2); 
	_pArr->iCount = 0;
	_pArr->iMaxCount = 2;

}

void Reallocate(tArr* _pArr)
{
	// 1. 2배 더 큰 공간을 동적할당 한다.
	int* pNew = (int*)malloc(_pArr->iMaxCount * 2 * sizeof(int));

	//2. 기존 공간에 있던 데이터들을 새로 할당한 공간으로 복사시킨다.
	for (int i = 0; i < _pArr->iCount; ++i)
	{
		pNew[i] = _pArr->pInt[i];
	}

	//3. 기존 공간은 메모리 해제
	free(_pArr->pInt);

	//4. 배열이 새로 할당된 공간을 가리키게 한다.
	_pArr->pInt = pNew;

	//5. MaxCount 변경점 적용
	_pArr->iMaxCount *= 2;
}

void PushBack(tArr* _pArr, int _iData)
{
	// 힙 영역에 할당한 공간이 다 참
	if (_pArr->iMaxCount <= _pArr->iCount)
	{
		// 재할당
		Reallocate(_pArr);
	}

	_pArr->pInt[_pArr->iCount++] = _iData;
}

void ReleaseArr(tArr* _pArr)
{
	free(_pArr->pInt);
	_pArr->iCount = 0;
	_pArr->iMaxCount = 0;
}
```

**Arr.h**

```cpp
#pragma once

// int 형 가변 배열
typedef struct _tabArr
{
	int*	pInt;
	int		iCount;
	int		iMaxCount;

}tArr;

// 배열 초기화 함수
void InitArr(tArr* _pArr);

// 데이터 추가 함수
void PushBack(tArr* _pArr, int _iData);

// 배열 메모리 해제 함수
void ReleaseArr(tArr* _pArr);
```

## 📍 **C/C++ 강의 46화. 리스트 (1)**

- 가변배열과 마찬가지로 데이터는 계속해서 추가할수있음
- 데이터를 관리하는 방식이 다름

**가변 배열**
- 가변 배열은 배열처럼 배열은 힙메모리에 공간을 계속 할당함
- 최종 할당된 힙 메모리 공간을 일렬로 저장된 배열을 포인터로 접근함

**연결형 리스트(Linked List)**
- 가변배열과 같은 힙메모리 공간을 사용하는데 데이터가 서로 떨어져있음
- 데이터를 추가할때마다 그때그때 공간을 할당해서 데이터를 저장함
- 메모리에 데이터와 다음 데이터의 주소를 보유하고있음
  - 서로가 다음데이터 자료의 주소를 알고있음
- 데이터를 저장하는 단위를 **노드** 라고함
- 객체 지향 프로그래밍: 특정 객체가 하나의 기능을 수행하도록 하는 것

___

**연결형 리스트 기본 구조**

**LinkedList.h**

```cpp
#pragma once

typedef struct _tagNode
{
	int		iData;
	tNode*	pNextNode;


}tNode;

typedef struct _tagList
{
	tNode*	pHeadNode;
	int		iCount;

}tLinkedList;
```

- `int iCount;` 데이터를 넣을 갯수
- 연결형 리스트는 데이터를 추가할때마다 매번 동적할당을 하기때문에 Max라는 개념이없으므로 MaxCount 등은 필요없음
- 각 객체는 **첫번째 노드**의 주소값을 알고있어야함

**만들어야 하는 함수**

- 객체 초기화
- 데이터 추가 함수
- 데이터 해제 함수

___

**과제**
1. 가변 배열 스스로 구현 가능하게 복습할 것
2. 가변배열 안에 넣은 데이터 정렬
   - 버블 정렬
   - 버블 정렬 함수하나 만들기
     - 오름차순, 내림차순 아무거나 상관없음  

___

**내 과제풀이**

- **가변 배열: 힙 메모리의 일렬로 데이터를 저장하는 배열, 데이터가 꽉차면 힙메모리를 재할당하여 공간을 늘림**
- **가변 배열 객체 필요 요소 3가지**
  1. 힙 메모리 주소
  2. 힙 메모리 현재 인덱스
  3. 힙 메모리 최대 크기
- **필요함수**
  1. 객체 초기화 함수
  2. 데이터 추가 함수
  3. 메모리 해제 함수
  4. 힙 메모리 재할당 함수
  5. 버블 정렬 함수

___

**코드 풀이**

**객체**
- 첫번째 멤버는 힙 메모리의 주소를 받을 용으로 int 포인터 변수 선언
- 두번째 멤버는 힙 메모리의 현재 인덱스를 카운트하는 용으로 int 변수 선언
- 세번째 멤버는 힙 메모리가 꽉찼을때 공간을 늘릴것을 확인하는 용도로 힙메모리의 최대 갯수를 저장하는 int 변수 선언

**객체 초기화 `(void JArrInit(JArr* _Arr);)`**
- 어떤 객체를 초기화 할지 알아야하기 때문에 인자로 가변배열의 주소를 받음
- 인자로 왜 그냥 객체가 아닌 포인터 객체로 받는지 의문이었는데 함수 인자로 객체를 넣으면 객체가 복사되서 성능이 떨어지기때문에 원본데이터를 수정하기 위해 포인터 객체로 받는 것
1. 힙 메모리의 처음 생성시 int형 자료 2개를 넣을 8Byte만큼의 데이터를 생성 하여 첫번째 멤버에 넣음
2. 현재 인덱스 카운터를 0으로 초기화
3. int형 데이터 2개만큼을 넣을수 있는 공간이므로 최대 크기를 2로 선언

**데이터 추가 `void JArrPushBack(JArr* _Arr, int _iData);`**
- 값을 추가할 객체와 추가할 값을 인자로 받음
1. 현재 인덱스와 Max 카운트 를 비교해서 꽉찼다면 메모리 재할당받기
2. 현재 인덱스에 입력받은 데이터를 넣고 iCount 값 1 증가시키기

**메모리 해제 `void JArrRelease(JArr* _Arr);`**
- free() 함수로 현재 객체의 힙 메모리 안의 값을 초기화
- 현재 메모리를 나중에 다시 사용할수도 있으니 현재 인덱스 카운트와 Max카운트를 초기화

**버블 정렬 `void JArrbubSort_Asc(JArr* _Arr);`**

- 오름차순 버블정렬을 할 객체를 인자로 받음
- **버블 정렬이란?:** 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
  - 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
- 마지막 원소는 비교할대상이 없으므로 검사할 필요가없으므로 `현재 원소 -1` 번 반복하는 것이 `1회전`
- 1 회전하게 되면 제일 큰(혹은 제일 작은) 자료가 맨 뒤로 이동하게됨
- 원소가 4개라면 9번 반복한다`(3*3)`
- 버블 정렬 장점
  - 구현이 간단함
- 단점
  - 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.
- 시간 복잡도 O(n^2) 

- 단순(구현 간단)하지만 비효율적인 방법
  - 삽입 정렬, 선택 정렬, 버블 정렬
- 복잡하지만 효율적인 방법
  - 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬

<br><br/>

**버블 정렬 코드 설명** 

- 정렬할 객체를 함수의 인자로 받음
- `현재 인덱스 - 1 번`만큼 1회전
- `현재 인덱스 - 1 번` * `현재 인덱스 - 1 번` 번 반복해야함으로 2중 for 문으로 작성
- 현재 인덱스의 값과 다음 인덱스의 값을 비교하여 현재 인덱스 값이 클경우 서로 값을 교환
1. tmp 라는 임시변수에 다음 인덱스 값을 저장
2. 다음 인덱스 에 현재 인덱스 값을 넣음
3. 현재 인덱스값에 저장해놓은 tmp 값을 넣음

**참조링크**
[알고리즘] 버블 정렬(bubble sort)이란- [https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)

___


**소스 코드**

**main.cpp**

```cpp
#include <iostream>
#include "MyArr.h"

int main()
{
	JArr s1 = {};

	JArrInit(&s1);

	for (int i = 125; i > 0; --i)
	{
		JArrPushBack(&s1, i);
	}

	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.heapAdress[i]);
	}

	printf("\n");

	JArrbubSort_Asc(&s1);

	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.heapAdress[i]);
	}


	JArrRelease(&s1);

	return 0;
}
```

**MyArr.h**

```cpp
#pragma once


typedef struct _jaggedArray
{
	int*	heapAdress;
	int		iCount;
	int		iMaxCount;

}JArr;

// 객체 초기화 
void JArrInit(JArr* _Arr);

// 데이터 추가
void JArrPushBack(JArr* _Arr, int _iData);

// 메모리 해제 
void JArrRelease(JArr* _Arr);

// 버블 정렬
void JArrbubSort_Asc(JArr* _Arr);
```

**MyArr.h**

```cpp
#include "MyArr.h"
#include <iostream>

void JArrInit(JArr* _Arr)
{
	_Arr->heapAdress = (int*)malloc(sizeof(int) * 2);
	_Arr->iCount = 0;
	_Arr->iMaxCount = 2; 
}

void JArrRealloc(JArr* _Arr)
{
	int* tmepAdr = (int*)malloc(_Arr->iMaxCount * sizeof(int) * 2);
	_Arr->iMaxCount *= 2;

	for (int i = 0; i < _Arr->iCount; ++i)
	{
		tmepAdr[i] = _Arr->heapAdress[i];
	}

	free(_Arr->heapAdress);

	_Arr->heapAdress = tmepAdr;
}

void JArrPushBack(JArr* _Arr, int _iData)
{
	if (_Arr->iMaxCount <= _Arr->iCount)
	{
		JArrRealloc(_Arr);
	}

	_Arr->heapAdress[_Arr->iCount++] = _iData;
}

void JArrRelease(JArr* _Arr)
{
	free(_Arr->heapAdress);
	_Arr->iCount = 0;
	_Arr->iMaxCount = 0;
}


void JArrbubSort_Asc(JArr* _Arr)
{
	for (int i = 0; i <_Arr->iCount - 1; ++i)
	{
		for (int j = 0; j < _Arr->iCount - 1; ++j)
		{
			if (_Arr->heapAdress[j] > _Arr->heapAdress[j+1])
			{
				int tmp = _Arr->heapAdress[j+1];
				_Arr->heapAdress[j+1] = _Arr->heapAdress[j];
				_Arr->heapAdress[j] = tmp;
			}
		}
	}
}
```

## 📍 **C/C++ 강의 47화. 과제 풀이 (정렬)**

- 정렬 알고리즘 무조건 시간을 투자해서 이론을 보고 직접 구현해보기
- **버블 정렬, 삽입 정렬, 선택 정렬, 합병 정렬, 쾌속 정렬, 힙 정렬**
  - 힙 자료 구조: 최소 최대 를 빠르게 찾아주는 알고리즘
    - 완전 이진트리 를 구현해야함
      - 배열로 구성되어있음

___

**rand()**

- `#include <time.h>` 를 참조 하여 사용
- 컴퓨터 에서의 난수라는 개념
  - 무작위로 설정되어있는 난수 페이지를 참조하는 방식
    - 완벽한 랜덤이 아닌 일정한 규칙이 있음
- `srand();`
  - 시드값을 통해서 난수의 여러 페이지를 변경 시켜주는것
  - 시드값에 시간 값을 넣어주기
    - 호출했을 당시 현재 시간값을 인자로 넣어줌

- 나중에 쉐이더에서는 이러한 방식을 사용하지 못함
  - 동일한 시간대의 난수가 필요함

- 난수의 기본값이 굉장히 큼 
  - 0 ~ 100 사이의 값을 사용하고 싶을때 값을 100으로 나누고 나머지 값을 사용
  - 50 ~ 100 사이의 값을 사용하고 싶을땐 100으로 나누고 나머지 값에 50을 더해서 사용

___

**버블 정렬 코드**

버블 정렬: 데이터 둘을 비교해서 둘중 더 큰 값을 오른쪽으로 이동
  - 역순일때 비교횟수가 가장많음

- 정렬할 값이 1개 이하면 정렬할 필요가없으므로 예외처리
- 두 데이터를 변환하기 전에 임시공간에 저장해놓고 변환
- 정렬될때 까지 while 문으로 정렬
  - 반복문 탈출 조건 용 bool 변수 한개 true 선언 1회전 시 마다 버블 정렬 조건일때는 false로 설정 정렬이 끝난후 변수체크하여 ture 면 반복문 탈출 

___

**소스 코드**

**main.cpp**
```cpp
#include <iostream>
#include <time.h>

#include "Arr.h"
#include "LinkedList.h"


int main()
{
	tArr s1 = {};

	InitArr(&s1);

	// 난수(랜덤)
	srand(time(nullptr));

	// 힙 영역에 데이터 추가
	for (int i = 0; i < 10; ++i)
	{
		int iRand = rand() % 100 + 1;

		PushBack(&s1, iRand);
	}

	printf("정렬 전\n");
	// 힙 영역 데이터 출력하기
	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.pInt[i]);
	}

	Sort(&s1);
	printf("\n");
	printf("정렬 후\n");
	// 정렬된 데이터 출력하기
	for (int i = 0; i < s1.iCount; ++i)
	{
		printf("%d\n", s1.pInt[i]);
	}



	ReleaseArr(&s1);


	return 0;
}
```

**Arr.cpp**

```cpp
#include "Arr.h"
#include <iostream>

void InitArr(tArr* _pArr)
{
	_pArr->pInt = (int*)malloc(sizeof(int)* 2); 
	_pArr->iCount = 0;
	_pArr->iMaxCount = 2;

}

void Reallocate(tArr* _pArr)
{
	// 1. 2배 더 큰 공간을 동적할당 한다.
	int* pNew = (int*)malloc(_pArr->iMaxCount * 2 * sizeof(int));

	//2. 기존 공간에 있던 데이터들을 새로 할당한 공간으로 복사시킨다.
	for (int i = 0; i < _pArr->iCount; ++i)
	{
		pNew[i] = _pArr->pInt[i];
	}

	//3. 기존 공간은 메모리 해제
	free(_pArr->pInt);

	//4. 배열이 새로 할당된 공간을 가리키게 한다.
	_pArr->pInt = pNew;

	//5. MaxCount 변경점 적용
	_pArr->iMaxCount *= 2;
}

void PushBack(tArr* _pArr, int _iData)
{
	// 힙 영역에 할당한 공간이 다 참
	if (_pArr->iMaxCount <= _pArr->iCount)
	{
		// 재할당
		Reallocate(_pArr);
	}

	_pArr->pInt[_pArr->iCount++] = _iData;
}

void ReleaseArr(tArr* _pArr)
{
	free(_pArr->pInt);
	_pArr->iCount = 0;
	_pArr->iMaxCount = 0;
}

void Sort(tArr* _pArr)
{
	// 데이터가 1개 이하면 정렬하지 않음
	if (_pArr->iCount <= 1)
		return;

	int iLoop = _pArr->iCount - 1;

	// 오름차순 정렬
	while (true)
	{	
		bool bFinish = true;

		for (int i = 0; i < iLoop; ++i)
		{
			if (_pArr->pInt[i] > _pArr->pInt[i + 1])
			{
				int iTemp = _pArr->pInt[i];
				_pArr->pInt[i] = _pArr->pInt[i + 1];
				_pArr->pInt[i + 1] = iTemp;

				bFinish = false;
			}
		}

		if (bFinish)
			break;
	}

}
```

**Arr.h**

```cpp
#pragma once

// int 형 가변 배열
typedef struct _tabArr
{
	int*	pInt;
	int		iCount;
	int		iMaxCount;

}tArr;

// 배열 초기화 함수
void InitArr(tArr* _pArr);

// 데이터 추가 함수
void PushBack(tArr* _pArr, int _iData);

// 배열 메모리 해제 함수
void ReleaseArr(tArr* _pArr);

// 데이터 정렬 함수
void Sort(tArr* _pArr);
```

## 📍 **C/C++ 강의 48화. 함수 포인터**

- 변수의 주소뿐만 아니라 함수의 주소를 가져올수 있음
- 내가 만든 기능을 인자로 전달하여 그 기능을 호출해서 내부 데이터를 정렬 하도록 만들어 보자
- Sort 함수는 하나이고 어떤 정렬을 할지 인자로 받기

___

**Sort 함수 범용적으로 변경하기** 

**변경 전**

```cpp
void Sort(tArr* _pArr)
{
	// 데이터가 1개 이하면 정렬하지 않음
	if (_pArr->iCount <= 1)
		return;

	int iLoop = _pArr->iCount - 1;

	// 오름차순 정렬
	while (true)
	{	
		bool bFinish = true;

		for (int i = 0; i < iLoop; ++i)
		{
			if (_pArr->pInt[i] > _pArr->pInt[i + 1])
			{
				int iTemp = _pArr->pInt[i];
				_pArr->pInt[i] = _pArr->pInt[i + 1];
				_pArr->pInt[i + 1] = iTemp;

				bFinish = false;
			}
		}

		if (bFinish)
			break;
	}

}
```

- 내가 만들었던 가변배열 만을 정렬 해주는 함수

**변경 후**

```cpp
#include <iostream>
#include <time.h>

#include "Arr.h"
#include "LinkedList.h"

void BubbleSort(int* _pData, int _Count)
{
	// 데이터가 1개 이하면 정렬하지 않음
	if (_Count <= 1)
		return;

	int iLoop = _Count - 1;

	// 오름차순 정렬
	while (true)
	{
		bool bFinish = true;

		for (int i = 0; i < iLoop; ++i)
		{
			if (_pData[i] > _pData[i + 1])
			{
				int iTemp = _pData[i];
				_pData[i] = _pData[i + 1];
				_pData[i + 1] = iTemp;

				bFinish = false;
			}
		}

		if (bFinish)
			break;
	}
}

int main()
{
	int iArr[10] = { 87,644,21,55,879,654,55,131, };
	BubbleSort(iArr, 10);

	return 0;
}
```

- main 함수에 구현
- 이전에 만든 BubbleSort 함수를 main 함수쪽으로빼내어 구현 하고 범용적으로 사용하도록 변경
  - 정렬해주고자 하는 데이터의 시작 주소를 첫번째 인자로 받음
  - 그곳에 들어있는 데이터 갯수를 두번째 인자로 받음
  - 가변 배열 상관없이 임의의 배열을 정렬해주는 함수로 변경한 것
- 이러한 기능을 정렬 기능을 인자로 전달해보자 

___

**함수 포인터**

- 함수 이름 앞에 `&` 를 붙여 주소를 표현할수있음
- 함수 이름자체가 주소로 인정되기때문에 이름만 적어줘도됨

```cpp

void Test(void) // (void) 괄호안에 void 생략가능
{

}

int main()
{
	// 함수 포인터 선언
	void(*pFunc)(void) = nullptr;

	pFunc = Test;

	pFunc(); // Test 함수 실행
}
```
- 반환타입이 void이고 인자가 void 이며 그 함수의 주소를 받겠다는 뜻으로 pFunc 가 함수 포인터가 됨

- `pFunc();` Test 함수를 호출하겠다는 뜻
- 함수 포인터는 선언당시 매칭이되는 함수의 주소만 받을수 있음

___

**Sort함수에 함수포인터 적용 시키기**

**Arr.h**

```cpp
void Sort(tArr* _pArr, void(*SortFunc)(int*, int));
```

- 두번째 인자로 어떤 정렬을할지 기능을 인자로 받음
  - 함수를 인자로 받아야 함으로 함수 포인터 형식으로 인자 설정
- void 타입 함수에 인자로 int* 와 int 를 갖고있는 함수의 주소를 받는 것


**Arr.cpp**

```cpp
void Sort(tArr* _pArr, void(*SortFunc)(int*, int))
{
	SortFunc(_pArr->pInt, _pArr->iCount);
}
```

- 현재 객체의 힙메모리의 시작 주소를 첫번째 인자로 넣어줌
- 현재 객체의 힙메모리의 현재 인덱스 값을 두번째 인자로 넣어줌

___

**함수 포인터를 사용하는 경우**

- **CallBack 해줄 함수를 받아가는 경우 사용**
  - 내가 어떤 기능을 만들고 다른 사람한테 줄때 CallBack 같은 기능을 만들어 놓고 nullptr 이면 실행을 안하고 함수포인터가 들어오면 실행 해주도록 구현할때 사용함
  - 내 함수의 기능 실행이 끝난뒤 다른사람이 원하는 함수가 실행 되고 싶을때 CallBack 함수를 사용함
- **분기 처리할때 사용**
  - 조건따라 함수를 호출하는것이 아닌 함수 포인터하나 두고 어떤 상태면 이 함수를 가르켜 라고 함수포인터에 설정 해놓고 함수 포인터를 호출 하기 
  - 상황에 맞는 함수가 설정되는것

## 📍 **C/C++ 강의 49화. 리스트 (2)**

**리스트 객체 에러 수정**

```cpp
typedef struct _tagNode
{
	int		iData;
	tNode*	pNextNode; // Error 발생


}tNode;
```
- 정의하는 과정중 아직 정의가 되지않은상태에서 사용할려 하여 에러가 발생하는 것
- 객체 멤버는 typedef 가 정의 된후에 사용할수 있기때문임 

```cpp
typedef struct _tagNode
{
	int		iData;
	struct _tagNode*	pNextNode;


}tNode;
```

- 구조체 이름으로 써주기
- `struct _tagNode` 나 `tNode` 는 정의된후 동일하게 동작함

___

- 노드: 데이터를 저장하는 기본단위
  - 데이터와 다음 노드의 주소를 갖고있음
    - 즉 노드끼리는 일렬로 연결되어있음
- 리스트는 첫번째 노드의 주소와 노드의 갯수 를 멤버로 가짐


**연결형 리스트 초기화 void InitList(tLinkedList* _pList);**
- 첫번째 멤버: 데이터가 들어올때마다 노드가 추가되는 것 이므로 초기화 시에는 nullptr 값을 넣어줌
- 두번째 멤버: iCount 값 또한 들어온 데이터가 없으니 0 으로 초기화

___


**연결형 리스트 데이터 추가 void PushBack(tLinkedList*, int _iData);**

```cpp
void PushBack(tLinkedList* _pList, int _iData)
{
	// 데이터를 저장할 노드 생성
	// 데이터 복사
	tNode* pNode = (tNode*)malloc(sizeof(tNode));
	pNode->iData = _iData;
	pNode->pNextNode = nullptr;

	// 추가한 데이터가 처음인지 아닌지
	if (0 == _pList->iCount)
	{
		_pList->pHeadNode = pNode;
	}
	else
	{
		// 현재 가장 마지막 노드를 찾아서,
		// 해당 노드의 pNext 를 생성시킨 노드의 주소로 채움
		tNode* pCurFinalNode = _pList->pHeadNode;
		while (pCurFinalNode->pNextNode)
		{
			pCurFinalNode = pCurFinalNode->pNextNode;
		}
		pCurFinalNode->pNextNode = pNode;
	}

	++_pList->iCount;
}
```

**노드 생성**

- 리스트는 노드 단위로 데이터를 관리함으로 노드 하나를 생성
  - 힙 메모리를 사용해야함
- 노드 단위로 데이터를 저장하고 읽어야함으로 받아온 힙메모리를 tNode*로 강제 캐스팅
- PushBack 함수 임으로 방금 만들어진 노드는 들어온데이터중 **가장 마지막에 넣음**
- 가장 마지막 데이터임 으로 다음 노드주소값으로 nullptr 을 넣음


**노드 위치 설정**

- 지금 들어온 데이터가 첫번째 인지 아닌지 확인해야함
  - List 객체의 iCount 나 pNextNode 둘중 아무거나 비교해도 상관없음

- 맨 처음 들어온 데이터였다면 List 의 첫번째 노드 주소값을 방금 만든 노드의 주소값으로 넣음

- 맨 처음 들어온 데이터가 아니었다면 현재 리스트 안에있는 맨 마지막 노드의 NextNode 주소값을 내가 방금 만든 노드의 주소값을 바라보게 해줘야 연결이됨

- 만약 양방향으로 만들면 쌍방향으로 접근할수 있음
- 리스트가 노드의 끝도 알고있었다면 추가하는것이 수월해짐

- 반복문으로 pNextNode 가 nullptr 일때까지 찾기
  - List의 pHeadNode 는 변경되면 안되므로 지역변수로 변수하나 선언

- 지역변수가 본인이 가르키고있는 다음 노드의 주소가 nullptr 일때까지 현재 지역변수의 Node를 다음 노드의 주소로 넣어서 찾음

- nullptr 자체가 0 이므로 while문 조건을 `pCurFinalNode->pNextNode` 로 물어봐서 데이터가있으면 반복 없으면 종료 조건으로 사용할수있음

___

**연결형 리스트 메모리 해제 void ReleaseList(tLinkedList* _pList);**
- 노드하나하나 찾아다니면서 메모리 해제를 해야함
  - 재귀함수, 반복문으로 해제함
  - 재귀함수는 효율이 안좋음 안에 노드갯수만큼 호출이 되어서 성능이 떨어짐

**재귀 함수로 메모리 해제 구현 void Release(tNode* _pNode)**

```cpp
void Release(tNode* _pNode) // cpp 파일에만 구현해서 비공개 처리
{
	if(nullptr == _pNode)
		return;

	Release(_pNode->pNextNode);

	free(_pNode );
}

void ReleaseList(tLinkedList* _pList)
{
	Release(_pList->pHeadNode);
}
```

- ReleaseList 는 들고있는 게 첫번째 노드 주소임으로 해제 하기전에 내부적으로 Release를 호출
- Release() 종료 조건으로 받은인자가 nullptr 라면 노드 끝이라는 뜻임으로 return 
- 종료 조건을 만나 돌아오면 free() 구문이 실행되면서 뒤에서부터 메모리 해제를 하면서옴 
- 함수가 너무많이 호출되서 효율이 좋지않음
  - 구현 아이디어 자체는 간단함
- 기본적으로 스택메모리가 그렇게 크지않음 4000개 정도 쌓이면 터짐

**반복문으로 메모리 해제 구현 void Release(tNode* _pNode)**

```cpp
void ReleaseList(tLinkedList* _pList)
{
	tNode* pDeletNode = _pList->pHeadNode;

	while (pDeletNode)
	{
		tNode* pNext = pDeletNode->pNextNode;
		free(pDeletNode);
		pDeletNode = pNext;
	}
}
```

- 삭제하기전에 다음 노드데이터를 지역변수로 따로 보존하는 방식으로 삭제할수있음
- 받아놓은 지역변수로 반복문 조건처리 nullptr 일경우 안에 데이터가 없다는 뜻이므로 반복문 실행안함

___


**과재**

- PushFront 함수 만들기
- 데이터가 앞으로 추가되는 함수

___

**내가 작성한 과제 void PushFront(tLinkedList* _pList, int _iData)**

```cpp
void PushFront(tLinkedList* _pList, int _iData)
{
	tNode* pNode = (tNode*)malloc(sizeof(tNode));

	pNode->iData = _iData;

	// 추가한 데이터가 처음인지 아닌지
	if (0 == _pList->iCount)
	{
		_pList->pHeadNode = pNode;
		pNode->pNextNode = nullptr;
	}
	else
	{
		pNode->pNextNode = _pList->pHeadNode;
		_pList->pHeadNode = pNode;
	}

	++_pList->iCount;
}
```

다음과 같은 순서로 작업 리스트 작성함

1. 노드 객체 생성 후 데이터 삽입
2. List 객체가 노드 객체를 갖고있지 않다면 생성한 노드의 주소를 가르킨뒤 다음 주소를 nullptr로 초기화
   - 다음 주소를 nullptr로 초기화를 안했더니 ReleaseList 단계에서 에러가 나서 추가
3. List 객체가 노드 객체를 갖고있다면 생성한 노드 객체의 다음주소를 List 객체의 첫번째 주소로 설정
   - 첫번째 였던 노드를 내가 생성한 노드 뒤로 설정한것
4. List 객체가 가르키는 첫 노드의 주소를 내가 생성한 노드로 설정
5. 리스트객체의 보유 노드갯수 1증가     

___

**유튜브 댓글에 질문 남김**

- 안녕하세요 강의 잘듣고있습니다 강의듣던 도중 궁금한 점이 한가지 생겨 질문드립니다 자기참조 구조체의 메모리 할당 방식이 궁금합니다 VS2022 에디터 사용하였고 64비트 환경에서 디버그 했습니다 	

```cpp
typedef struct _tagNode
{
	int		iData;
	struct _tagNode*	pNextNode;


}tNode; 

tLinkedList list = {};

int a = sizeof(list.pHeadNode); // 8
int b = sizeof(list.iCount); // 4
int c = sizeof(list); // 16
```

- 위와같이 구조체 멤버로 들고있는 데이터가 각각 8Byte, 4Byte 인데 구조체 객체의 사이즈는 12Byte가 아닌 16Byte로 뜨네요
헌데 32비트 환경에서 디버그 했을땐 각각 4Byte,  4Byte, 8Byte 로 나오네요 왜그런지 궁금합니다!

## 📍 **C/C++ 강의 50화. 리스트 (3)**

**빅오 표현법**

- **시간 복잡도:** 예를 들어 가변배열안에 데이터의 갯수가 n개일때 배열의 맨앞에 데이터를 넣을때 걸리는 시간 즉 가장 최악의 상황을 `O(n)` 라고 표현함
  - `빅오 의 n개` 라고 읽음
  - n과 무관하게 항상 고정시간 비용이들때 상수 `O(1)` **고정 시간** 이라고함
    - 거의 없는 취급합
    - 알고리즘을 수행하는데 가장빠른 속도임
- 빅오 표현법에서는 1/2 등 표현은 없고 n 으로 표기함

___

**리스트 자료구조의 장점**

- 리스트가 데이터를 앞쪽이나 중간에 끼워넣을때 유리한 자료구조임
- 데이터를 노드로 갖고있기때문에 데이터의 순번을 바꾸는데 용이함
  - 반면 가변 배열구조는 한 메모리에 데이터를 연속적으로 잡고있음
  - 데이터를 앞으로 넣을려면 기존데이터를을 뒤로 한칸씩 다 밀어야하는 비용이 생김 

**가변배열에 비해 리스트의 단점**

- 가변배열은 일렬로 데이터가 저장되어있음 주소연산으로 원하는 위치의 인덱스에 바로 접근할수 있음
- 반면 리스트는 서로서로가 연결되어있기 때문에 주소연산을 계속 찾아가는 비용이 듬

___

**PushFront 구현하기**

```cpp
void PushFront(tLinkedList* _pList, int _iData)
{
	// 새로 생성시킨 노드의 다음을 기존의 헤드로 지정한다.
	tNode* pNewNode = (tNode*)malloc(sizeof(tNode));
	pNewNode->iData = _iData;
	pNewNode->pNextNode = _pList->pHeadNode;

	// 리스트의 헤드노드 포인터를 갱신한다.
	_pList->pHeadNode = pNewNode;

	// 데이터 카운트 증가
	++_pList->iCount;
}
```

- 노드를 생성하고 다음 노드 주소를 현재 리스트가 갖고있던 첫번째 헤드 주소의 노드로 설정
- 리스트의 첫번째 헤드 노드 주소를 방금 생성한 노드로 설정 
- 기존 리스트는 insert 라고 중간 데이터를 넣고 삭제할수 있음

___

- 여태까지 C스타일로 생성한 가변배열, 리스트를 클래스 강의 이후 두 자료구조를 C++ 스타일로 클래스 버전으로 바꿀 예정

## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****




# 📌참조링크
어소트락 게임아카데미 강의 링크- [https://www.youtube.com/watch?v=-h_uxJiiiqg&list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&index=2](https://www.youtube.com/watch?v=-h_uxJiiiqg&list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&index=2)