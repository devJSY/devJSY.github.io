---
published: true
title:  "C/C++ 강의 내용 정리"
excerpt: ""

categories:
  - C++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-07-22
last_modified_at: 2022-07-22
---

# 🤔 학습목표
- C/C++ 강의 내용 간략하게 정리

# 📃 학습내용

## 📍 **C/C++ 강의 Prologue. C++ 공부이유와 공부법**

- C++ 는 JAVA 나 C# 과 같이 가상머신을 통하지 않고 바로 메모리관리를 하기때문에 속도에 있어 유리함
- 위와같은 이유로 게임프로그래밍에선 C++ 이 유리함 다만 개발속도가 느린편

**공부 방향**

1. C++ 기초문법, 자료구조(데이터)
2. winapi 게임제작 ( CPU 만 사용하여 게임 제작 )
3. Direct X 게임제작 ( 그래픽 카드 제어 )
4. 게임엔진 게임제작

## 📍 **C/C++ 강의 1화. 프로젝트 생성 및 주석**

- 컴퓨터 언어또한 "언어" 이므로 일정 수준이상 수월하게 사용하기 위해선 암기가 필연적이다.
- 공부한것을 블로그등에 정리해놓으면 시간이 지나면서 구멍이뚫린 기억을 메꾸는데 도움이된다

___

**주석**
- `//` 이나 `/**/` 을 사용해서 사용가능
- 내가 작성해둔 코드가 어떤 역할을 하는지 필요한 내용들을 설명하는 용도로 사용

## 📍 **C/C++ 강의 2화. 자료형**

```cpp
int main()
{
	int i = 0;

	return 0;
}
```

- int : 자료형
- i : 변수명

___

**자료형 (크기 단위, byte)**
- 정수형: char(1), short(2), int(4), long(4), long long(8)
- 실수형: float(4), double(8)

<br><br/>

- 자료형이란 변수가 어떠한 자료의 형태를 나타내는지 표현해주는 것
- 자료형으로 **표현 방식** 과 **크기 단위(byte)** 를 알수있음

___

**데이터의 단위**

**1 Byte = 8 bit**
- 1 bit 는 값이 있다 없다를 표현해주는 데이터의 최소값을 나타냄

- 데이터 단위는 **2^10 = 1024묶음** 단위로 byte - kb - mb - gb - tb 순으로 표현함

___

**경우의 수**

- **2^8 = 256** 8비트로는 **0~255까지 256가지**의 상태를 표현할수있음
 
___

**unsigned**

- 정수형 자료형 앞에 붙이면 양의 정수만 표현가능한 정수형 자료형을 만들수있음
- **unsigned char** 에 256값을 넣게되면 0이 나오게됨
  - 255까지만 넣을수 있는 공간에 256이라는 초과된 값을 넣으면 잘려서 못들어감

___

**변수의 선언 위치**

**올바른 선언** 
```cpp
int main()
{
  char c = 0;

  c = 256;

  return 0;
}
```

**올바르지 못한 선언** 
```cpp
int main()
{
  c = 256;

  char c = 0;

  return 0;
}
```

- 변수를 자료형과 함께 선언한 후 아래에서 사용가능함

___

- `=` 대입 연산자
  - 왼쪽의 값을 오른쪽의 값에 넣어 주는 연산자
- `==` 비교 연산자
  - 양쪽이 균등한지 물어보는 연산자

## 📍 **C/C++ 강의 3화. 정수형 자료형**

- 양수를 표현하는 자료형 앞에는 **signed** 키워드가 숨겨져있음
  - 굳이 안적어줘도 상관없음

**unsigned**
- 1 바이트로 양수만 표현
  - 256가지 -> 0 ~ 255

**signed**
- 1 바이트로 양수, 음수 둘다 표현
  - 256가지 -> -128 ~ 0 ~ 127 
  - **MSB (most significant bit) 최상위 비트**
    - 맨앞의 숫자가 0 일때 양수 로 표현 
    - 맨앞의 숫자가 1 일때 음수 로 표현

**음수의 동작방식**

- 2진수끼리의 덧셈
  - 각각의 두숫자의 자릿수의 합하여 올림
- 컴퓨터에서는 뺄셈이 없고 음수의 덧셈이라고 생각함
- `signed 기준)` 0111 1111(127) + 1000 0001(-127) = 0
- `signed 기준)` 0000 0001(1) + 1111 1111(-1) = 0

```cpp

unsigned char c;
c1 = 255 // 255 가 입력됨

char c1;
c1 = 255 // -1 이 입력됨
```

- 255가 2진수상으로 1111 1111 이 들어가고 signed 기준으로 이 값은 -1임으로 c1 에 -1이 입력됨
- c와 c1의 메모리 공간의 상태는 1111 1111로 똑같음!
  - 최상위 비트 를 사용한다 안한다의 차이

___

**음수값 찾는법**
- **2의 보수법**
  - 양수와 음수를 더했을때 0 이 나오는 수를 찾는것
  - 0을 1로 1을 0으로 바꾸고 1을 더해주면됨
  - 0000 0010 의 음수값은 1111 1110

**C++ 2진수 표기**

```cpp
int main()
{
	char c,d,k;

	c = 0b0000'0011; // 3
	d = 0b1111'1101; // -3

	k = c + d; // 0

	return 0;
}
```

- **"0b숫자(2진수)"** 
- **"0숫자(8진수)"**
- **"0x숫자(16진수)"**

- 자릿수 표기법  
  - 숫자 사이사이에 `'` 를 넣어주면됨

___

**값의 표현 범위**

- byte 가 늘어날수록 기하급수적으로 값의 표현 범위가 늘어감
- 1 Byte (2^8) 256 가지 → 2 Byte (2^16) 65536가지 → 4Byte (2^32) 4,294,967,296 가지 

## 📍 **C/C++ 강의 4화. 실수형 자료형**

- 정수형, 실수형데이터를 나누는 이유는 **처리하는 방식**자체가 다르기때문
- 정수형데이터는 비트라는 한정적 공간안에서 2진수로 대응되는 숫자로 표현함 
  - 경우의 수 자체가 한정적임
- 실수는 무한으로 만들어 낼수 있기때문에 한정적으로 비트값을 대응 시킬수 없음 
  - 부동 소수점이라는 표현방식을 사용함

- 정수 4 와 실수 4.0 는 컴퓨터에서 저장되는 방식은 완전히 다름 
  - `int a = 4 + 4.0` 4.0 이 4로 형변환 연산이 들어간뒤 계산됨
  - 정수, 실수의 혼합된 계산방식은 의도치않은 상황이 발생될수 있기 때문에 피하는것이 좋음

**부동소수점**
- float 보다 double 이 정밀도가 더 좋음
  - 4비트의 float 보다 8비트의 double 이 더 가까운값을 표현할수 있기때문임 

- 컴퓨터에서의 부동소수점 방식
  - 소수점 뒷자리는 2^-1(1/2) → 2^-2(1/4) → 2^-3(1/8) 이런식으로 내려감 
  - 0.8125(10진법) → 11010(2진법) 으로 변환할수 있음
    - 11010 이라는 비트를 정규화 시키기위해서 2^5(101)을 곱해줌

- 부호비트,지수 파트,가수 파트로 나늘수 있음
  - 부호비트: 맨첫째 자리로 양,음 을 구분하는 용도로 사용
  - 지수 파트: 소수점을 정규화 시킬때 곱해준 비트를 표현
  - 가수 파트: 정규화 시킨 파트의 비트

___

**명시적 형변환**
- 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 연산자가 연산될 경우 명시적으로 변환하자
  - `float f = 10-.2415f + (float)20;`

## 📍 **C/C++ 강의 5화. 산술 연산자**

- `;` : 컴파일러가 컴파일할때 문장의 마감을 표현해줌 
- 산술 연산자
  - `+` 
  - `-`
  - `*`
  - `/`
  - `%` (모듈러스, 나머지)
    - 피연산자가 모두 정수인경우 사용가능

- 증감 연산자
  - `++`
  - `--`

- 대입 연산자
  - `=`

- **연산자 우선순위**
  - 연산자들이 나열되었을때 연산자 우선순위에 따라 연산순서를 정함

___

```cpp
int data = data + 20; // 1
data += 20 // 2
```

- 1과 2는 동일하게 작동함

___

- 피연산자: 연산의 대상이 되는 데이터
- 나누기 연산시 피연산자가 정수인지 실수였는지에 따라 두가지 결과가 발생함
  - 실수가 끼어있는 `%` 연산은 문법오류가 발생함
  - 정수끼리의 나머지 연산시에는 경고가 발생할수 있음
    - 대입연산시 상수값이 잘리기때문에 경고가 발생함 따라서 형변환을 해주는것이 좋음

___

```cpp
float data = 20.f; 
double data = 20. ;
```

- float 은 숫자뒤에 `.f` 를 붙여주고 double은 `.`을 붙여줌
- 실수를 상수로 적을 경우 소수점 뒤에 f 를 붙이면 float 자료형으로, f 를 붙이지 않으면 double 자료형으로 간주한다.

## 📍 **C/C++ 강의 6화. 증감 연산자**

- 증감 연산자
  - `++`
  - `--`

- 다음단계로 증감해주는 연산자
- 일반적인 숫자타입에선 +1 -1 증감

```cpp
int data;
++data // 전위(전치)
data++ // 후위(후치)
```
- 위치에따라 연산되는 순서가 달라짐
- 연산자 우선순위가 달라짐
  - **후위로 갔을경우 모든 연산자 우선순위 최하위가 되어 제일 나중에 수행됨**
- data라는 변수안에 실제값이 증가함
  - 다른 메모리 공간에서 data + 1 이 되어 대입되는 것이아님!
- 특별한사유가 없는한 전위 연산자로 사용하는것이 좋음
  - 연산자 오버로딩때 클래스나 구조체의 오퍼레이터라는 함수를 실수로 호출할수 있음

## 📍 **C/C++ 강의 7화. 논리 연산자**

- 참(true), 거짓(false)
  - 0 이 아닌 모든수를 참으로봄
    - 다만 컴퓨터에 true을 요청하면 1이 나옴
  - 대표적으로 1을 참이라고 봄
  - c++ 에서 true나 false 를 키워드로 줌
- `!`
  - 역
  - 참을 거짓으로, 거짓을 참으로 바꿔줌
- `&&`
  - 곱 ( and )
  - 둘다 참이면 참, 둘 중 하나라도 거짓이면 거짓
- `||`
  - 합 ( or )
  - 둘다 거짓이면 거짓, 둘 중 하나라도 참이면 참

___

**bool 자료형**
- 1 byte 자료형
- true나 false 만 나타내는 자료형
- 굳이 따지자면 정수형 자료형에 속함

## 📍 **C/C++ 강의 8화. if / else 구문**

**비교연산자**
- `==`
  - 왼쪽 값 과 오른쪽 값이 같은지 물어보는 연산자
- `!=`
  - 왼쪽 값 과 오른쪽 값이 다른지 물어보는 연산자 
- `<`
  - 왼쪽값이 오른쪽 값보다 작은지 물어보는 연산자
- `>`
  - 오른값이 왼쪽 값보다 작은지 물어보는 연산자
- `<=`
  - 왼쪽값이 오른쪽 값보다 작거나 같은지 물어보는 연산자 
- `>=`
  - 오른값이 왼쪽 값보다 작거나 같은지 물어보는 연산자

___

```cpp
int data;
if(조건식) // 조건식 true or false 가 들어옴
{
  // () 안에 값이 참이라면 실행됨
}
else if () // if 가 false 라면 실행됨
else
{
  // () 안에 값이 거짓이라면 실행됨
}
```

- `if()`
  - () 안에 값이 true 면 {} 안에 구문이 실행됨
  - 수행안될 구문은 컴파일러가 삭제시켜줌
- `else if` 
  - if 안에 값이 거짓이면 확인하는 구문
  - else if 구문으로는 동시입력을 받을수 없기때문에 캐릭터 입력등은 if 문 여러개로 짜야함
- `else`
  - if 나 else if 구문중 아무것도 걸리지 않았을 경우 실행되는 구문
  - 없어도 상관없음

## 📍 **C/C++ 강의 9화. switch 구문/ 삼항 연산자**

```cpp
switch(10)
{
  case 10:
    // 실행
    break;

  case 20:

    break;

  case 30:

   break;

  default: 
    break;
}
```

- switch(): () 안에 조건과 case 앞에 조건을 비교하여 맞는 조건을 실행시켜줌

- case 구문중 맞는게 없는경우 default 가 실행됨

- 문법적으로 if 문과 거의 다르지않음
  - switch-case문은 변수나 특정값을 넣어주는 경우 표현이 힘든경우가 있음
  - if 문은 코드 가독성이 떨어지는 경우가있음

- break 가 없으면 밑에있는 구문까지 break를 만나는 라인까지 실행시켜줌
  - 공통적으로 똑같은 조건에서 실행시키고 싶은 경우가 있기 때문에 문법오류로 안잡아줌

___

```cpp
int iTest = 10;
if(1 || iTest == 20 || iTest == 30)
{

}
```

- 위와같이 `||` 연산자 연산중 앞에 1이 발견되어 조건이 참인경우 `iTest == 20 || iTest == 30` 는 실행되지 않음

___

**삼항 연산자**

```cpp
iTest == 20 ? iTest = 100 : iTest = 200;
```

- iTest 가 20 이라면 100을 넣고 20이 아니라면 200을 넣는 코드
- ? 왼쪽값에 참인지 물어보고 참이면 왼쪽이 실행 거짓이면 오른쪽이 실행
- 가독성이 떨어짐

```cpp
if(iTest == 20)
{
  iTest = 100;
}
else
{
  iTest = 200;
}
```

- 삼항 연산자코드를 if else 문 으로 바꾼 코드
  
## 📍 **C/C++ 강의 10화. define / 비트 연산자 (1)**

```cpp
unsigned char byte = 1;
byte <<= 3; // 8
```

- **비트 연산자:** 비트단위로 연산이 진행될때 사용되는 연산자
- 비트 쉬프트
  - 비트를 화살표가 가르키는 방향으로 한칸씩 밈
  - `>>`
  - `<<`

- 2진수에서 한칸 올라간다는것은 2배가 올라간다는것과 같음

**홀수의 비트쉬프트**

```cpp
unsigned char byte = 13;
byte >>= 1; // 6
```

- 홀수를 나누면 몫만 취하게됨
- 나머지는 오른쪽으로 밀리면서 소실됨

___

**비트 단위 연산**

- 비트 자리대로 비트끼리 연산하는 것

- **비트 곱(`&`)**
  - 비트 단위 기준 둘다 1일경우 1이 나옴
- **비트 합(`|`)**
  - 비트 단위 기준 둘중 하나라도 1일경우 1이 나옴
- **xor(`^`)**
  - 비트 단위 기준 둘다 같으면 0, 다르면 1이 나옴
- **반전(`~`)**
  - 1은 0으로 0은 1로 반전시켜줌

___

**전처리기**

- `#` 이 붙은 모든 구문을 컴파일 시 제일 먼저 처리해줌
- `#defind`
  - 내가 지정한 구문을 특정 숫자로 치환해줌

**#defind 예제**

```cpp
#define HUNGRY 1

int main()
{
	int iStatus = HUNGRY;

	return 0;
}
```

**전처리기의 장점**
- 가독성이 좋아짐
- 코드 유지보수가 좋아짐

## 📍 **C/C++ 강의 11화. 비트 연산자 (2)**

- 비트 연산으로 상태를 표현할수 있음
  - 겹치지 않는 자리로 상태를 나타낼수있음 즉 8비트 = 32가지상태를 나타낼수 있음

```cpp
#define HUNGRY 1
#define THIRSTY 2
#define TIRED 4

int main()
{
	unsigned int iStatus = 0;

	// 상태 삽입
	iStatus |= HUNGRY;
	iStatus |= THIRSTY;
	iStatus |= TIRED;

	if (iStatus & THIRSTY) // 상태확인
	{

	}

	//특정 자리 비트제거
	iStatus &= ~THIRSTY;

	return 0;
}
```
___

**16진수**

```cpp
#define HUNGRY  0x001 // 1
#define THIRSTY 0x002 // 2
#define TIRED   0x004 // 4
#define FIRE    0x008 // 8

#define COLD    0x010 // 16
#define POISON  0x020 // 32
#define POISON1  0x040 // 64
#define POISON2  0x080 // 128

#define POISON3  0x100 // 256
#define POISON4  0x200 // 512
#define POISON5  0x400 // 1024
#define POISON6  0x800 // 2048
```

- 16진수의 각자리수를 2진수로 변환하고 10진수로 보면 편함
- 0x100 (16진수)
  - 0001 0000 0000 (2진수)
  - 256 (10진수)


## 📍 **C/C++ 강의 12화. 변수**

1. 지역변수
   - 함수안에 들어있는 변수를 지칭함
   - `{}` 안쪽에 선언되어있는 변수
2. 지역변수
   - 함수 바깥에 선언되어 있는 변수 
3. 정적변수
4. 외부변수

**함수**
- 하나의 기능을 정의해 놓는것
- 기능의 모듈화
  - 작은 기능들을 모아 큰 기능을 만드는 것
  - 하나의 기능을 명확하고 잘 쪼게놓아야함

```cpp
int Add(int left, int right)
{
	return left + right;
}

int main()
{
  data = Add(10, 20);
}
```

1. 반환 타입 작성
   - `int`
2. 함수 이름 정의
   - `Add`
3. 인자 설정
   - `int left, int right`   
   - 이 인자들도 Add 라는 함수 안의 지역변수임

___


**변수명 규칙**
- 이름을 하나 줬는데 똑같은이름으로 변수를 짓게되면 모호성이 생김 컴파일 에러 발생
  - 지역변수안에 똑같은 변수명을 짓게되면 지역변수안에 있는 변수를 우선으로 할당해줌
  - 쉽게 말해 범위가 작은 변수를 우선적으로 할당하게됨
  - 지역 변수는 자기 지역을 벗어나게되면 사라짐

```cpp
int main()
{
  int test = 0;

  {
    int test = 100;

    test // 100 짜리 test
  }

  test // 0 짜리 test
}
```

## 📍 **C/C++ 강의 13화. 함수 (1) / 반복문**


- 프로그램의 정체는 함수의 호출임 main 함수를 호출 시키는 것
- 반복문이 돌면서 main함수를 유지시키고 특정 조건이 만족되었을때 main함수가 종료되어 프로그램이 종료되는 것
- VS 에선 디버깅 모드에서는 중단점에 걸려 현재 진행중인 코드를 확인할수 있음

**반복문**
- 어떤 조건을 주고 충족될때까지 코드를 반복하는것

**for()**

```cpp
for (/*반복자 초기화*/ ; /*반복자 조건 체크*/; /*반복자 변경*/ )
{

}

for (int i = 0; i < 2; ++i)
{
  printf("Output Test\n");
}
```

- 반복자 초기화 구문: for문이 시작될때 한번만 실행되는 용도로 실행됨
- 반복자 조건 체크: true or flase 입력을받음 true 인 경우에만 구문이 실행됨
- 반복자 변경: for문 {} 구문 수행 후 실행되는 부분

**while()**

```cpp
while(/*조건 체크*/)
{

}

int i = 0;

while(i < 2)
{
  printf("Output Test\n");
  ++i;
}
```

**반복문 내부 키워드**
- for문 while 문 둘다 사용가능함
- `continue`
  - 구문 수행중 continue 를 만나게되면 이번 구문은 스킵하고 다음 구문으로 넘어가게 되는 키워드
- `break`
  - 구문 수행중 break 를 만나게되면 반복을 끝내고 탈출하게 됨

___

**입출력 함수**

- 내가 만든 함수가 아니기때문에 `#include <stdio.h>` 표준 입출력 함수를 참조해야함

```cpp
printf("Output Test\n");
```

- `printf();`
  - 문자열을 입력하고싶을땐 `""` 안에 텍스트를 적어 주면됨
  - `"\n"` 개행 문자로 커서가 다음칸으로 넘어가게됨
- `scanf();`

## 📍 **C/C++ 강의 14화. Visual Studio 단축키 및 편의 사항**

**단축키**
- VS 설정도구에서 커스터마이징 가능함

- 지정한 구문 주석
  - `Ctrl + k, c`
- 지정한 구문 주석 해제
  - `Ctrl + k, u`
- 최근의 했던 작업 되돌리기
  - `Ctrl + z`
- 원하는 부분만 선택할수 있음
  - `Alt + Drag`

<br><br/>

**디버깅**

- 디버깅 시작
  - `F5`
  - **디버깅중, 다음 중단점까지 코드 실행**
- 중단점 생성, 삭제
  - `F9`
  - 중단점 부분 코드 직전에 멈춰줌
- 디버깅 중, 구문 수행
  - `F10`
  - main 함수의 한단계가 수행됨
  - 프로시저 단위 기능단위 라고도함
- 디버깅 중, 구문 수행(함수 진입)
  - `F11`
  - 아주 작은 단위에 코드씩 실행됨
  - 한 단계씩 코드 실행
- 디버깅중, 디버깅 종료하기
  - `Shift + F5`

<br><br/>

**디버깅 창**

- 로컬
  - 디버그 - 창(W) - 지역(L) 
  - 메인함수는 실핼될때 구문이 아직 실행되지 않아도 선언해놓은 지역 변수의 메모리는 미리 잡혀있음 
  - 현재 중단점이 걸려있는 메인함수의 지역 변수를 다 보여줌
  - 커서로 변수에 올려놔도 보임
  - 변수 초기화 전엔 쓰레기값이 들어가있음 
- 조사식
- 호출 스택
  - 디버그 - 창(W) - 호출 스택(C) 

<br><br/>

**윈도우 단축키**

- 복사
  - `Ctrl + c`
- 붙여넣기
  - `Ctrl + v`
- 잘라내기
  - `Ctrl + x`

## 📍 **C/C++ 강의 15화. printf / scanf 문자 입출력**

- 콘솔창
  - 콘솔: 입력, 출력 장치
  - 윈도우 기준 **명령 프롬프트** 창 os 마다 명칭이 다름
- vs 프로젝트 시작시 명령 프롬프트 창으로 실행 으로 설정하였기 때문에 
main 함수가 실행되면 명령 프롬프트 창이 열리게 되는 것

- `#include`
  - 컴파일 전에 다른 헤더파일을 포함하여 사용하겠다는 전처리기

- `printf()`
  - 콘솔창에 문자를 출력
  - `printf("abcdef\n");` `""` 안에 문자를 출력하고 `\n` 줄바꿈 하겠다는 구문
  - 치환문자 `printf("%d", 10);` 
    - 정수형 데이터 `%d` 치환문자 자리에 문자로 대체해주는 것
    - 실수형 데이터 `%f`

```cpp
int iInput = 0;
scanf_s("%d", &iInput);
```

- `scanf()`
  - 콘솔창으로 부터 입력을 받음
  - `scanf_s("%d", &iInput);` 
    - 입력받을 데이터 타입과 변수의 주소를 넘겨줘야함
  - scanf 내부에서 입력이 들어올때까지 무한루프를 돌고있는 것
  
## 📍 **C/C++ 강의 16화. 함수 (2)**

- 함수 안에서 함수를 호출하여 최종적으로 main함수로 돌아옴
  - 자료구조 스텍과 유사함
  - 이전에 호출한 함수가 종료되야 현재 함수가 종료될수있음


**자료구조 Data structure**
- 어떤 데이터를 관리함에 있어 어떠한 구조로 데이터를 효율적으로 관리 하고 처리하는지 연구하는 학문
- 스텍 : 후입 선출 구조
- 큐 : 선입 선출 구조

___

**함수가 사용하는 메모리 영역**
- **스택 메모리 영역**
  - main함수가 실행되는 순간 모든 변수들이 담길 공간을 마련함
     - main함수뿐 아니라 모든 함수에 적용되는 사항임 
  - main 함수실행에 필요한 데이터가 100Byte 라면 main함수 처음 실행시 100Byte 공간을 잡음 메인함수가 다른 함수를 호출하면 그 순간 다른 함수를 호출하면 그 함수에 필요한 데이터를 잡고 함수가 종료될때 데이터를 삭제함
 - 현재 지칭하는 함수명이 다르기때문에 함수별로 같은이름의 변수명을 지을수 있는 것임

___


**코드 != 메모리 영역**
- 코드는 명령어
- 함수는 명령어의 집합
- 메모리 영역은 코드를 수행했을때 수행되는 영역

## 📍 **C/C++ 강의 17화. 함수 (3)**

**계승 (Factorial)**
- `n!` 으로 표현
- 각 자리 숫자들의 최종 곱

**계승 코드**

```cpp
int main()
{
	int i = 4;

	int iValue = 1;

	for (int j = 0; j < i - 1; ++j)
	{
		iValue *= (j +2);

	}

	return 0;
}
```

- i 값만 바꾸면 특정 계승값을 알아낼수있음

**계승 코드의 모듈화**

```cpp
int Factorial(int _iNum)
{
	int iValue = 1;

	for (int j = 0; j < _iNum - 1; ++j)
	{
		iValue *= (j + 2);
	}

	return iValue;
}

int main()
{
	int iValue = Factorial(4);

	iValue = Factorial(10);

	return 0;
}
```

- 함수를 사용하는 이유
  - 하나의 기능 단위를 함수로 구현해놓고 계속 재활용 하기 위해서
- 행동집합을 하나만두고 필요할때마다 지침을 읽고 사용하는 것
- 복잡한 기능을 만들때 기존에 만들어둔 함수들의 조합으로 만들수 있음

## 📍 **C/C++ 강의 18화. 재귀 함수 (1)**

**재귀 함수**
- 함수안에서 자기 자신과 동일한 함수를 호출하는 것
- 무조건 **탈출 조건**이 필요함

**재귀 함수의 장점** 
- 가독성, 구현의 용이
- 계층구조 표현이 재귀 함수가 좋음

**재귀 함수의 단점** 
- 반복문 등으로 대체 표현이 가능하지면 반복문으로는 가독성, 구현이 좋지못함
- 실수할 여지가 있음
- 성능이 많이 떨어짐
  - 여러번의 함수를 호출해서 마치 변수처럼사용하기 때문에 호출, 회수 비용이 들기에 성능이 떨어짐


**디버깅 툴**
- **호출 스택:** 호출된 함수의 순서대로 보여줌 
  - **디버깅시 호출스택의 함수를 클릭하면 클릭한 함수의 상태를 확일할수 있음**
- **로컬:** 현재 호출된 함수의 지역변수들을 보여줌
- VS 의 호출 스택, 로컬, 조사식을 잘 사용하면 문제점을 발견할때에 문제를 찾기가 쉬움
- 지역 변수는 현재 호출된 함수가 사용될 메모리를 갖고있음
- 스택 메모리 영역: 함수가 사용하는 메모리영역

**함수 동작 순서**
- cpu에 레지스터라는 빠르게 접근할수있는 메모리 공간에 잠시 받아두고 함수메모리 해제하고 리턴값을 사용함 


**재귀 함수의 스택 메모리**
- 함수가 계속 실행되어 스택 메모리에 계속 호출되어 쌓이는 방식임
- 한계치에 도달하면 **스택 오버 플로우** 라는 에러가 발생함

## 📍 **C/C++ 강의 19화. 재귀 함수 (2)**

- C/C++ 처음 공부시 그림이나 펜으로 변수 메모리공간을 직접 구상화하면서 연습하는것이 좋음

- 재귀 (Recursion)
- 자료구조 등은 영어 단어로 찾아두는것이 좋음

**재귀 함수**

```cpp
int Factorial_Re(int _iNum)
{
	if (1 == _iNum)
	{
		return 1;
	}
	
	return _iNum * Factorial_Re(_iNum - 1);
}

int main()
{
	int iValue = 0;

	iValue = Factorial_Re(7);

	return 0;
}
```

- 10부터 시작해서 1이될때까지 호출을 계속하다가 1을만나면 1을 리턴하는 재귀함수 코드

<br><br/>

**Fibonacci sequence(피보나치 수열)**

- 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열

```cpp
// 1 1 2 3 5 8 13 21 34 55 89
int Fibonacci(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	int iPrev1 = 1;
	int iPrev2 = 1;
	int iValue = 0;

	for (int i = 0; i < _iNum - 2; ++i)
	{
		iValue = iPrev1 + iPrev2;
		iPrev1 = iPrev2;
		iPrev2 = iValue;
	}

	return iValue;
}

int main()
{
	int iValue = Fibonacci(10); 

	return 0;
}
```

1. 두 변수 공간에 iPrev1, iPrev2에 각각 1을 넣어두기
2. iPrev1 + iPrev2 값을 iValue 넣기
3. iPrev2 값을 iPrev1 에 넣기
4. iValue 값을 iPrev2 에 넣기

- 이런식으로 `_iNum - 2` 번 반복하면 `_iNum` 번째의 피보나치 수열을 구할수 있음 

**재귀 함수 버전 피보나치 수열**

- `f(n) == f(n - 1) + f(n - 2);`

```cpp
int Fibonacci_Re(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	return Fibonacci_Re(_iNum - 1) + Fibonacci_Re(_iNum - 2);
}

int main()
{
	int iValue = Fibonacci_Re(10); 

	return 0;
}
```

- 위 코드는 구현하기는 편하지만 성능이 매우떨어짐
  - 60번만 호출해도 2제곱승수로 호출이 늘어나기때문에 호출을 엄청많이하게됨
  - 꼬리 재귀 등으로 해결이 가능하긴함
- 피보나치 수열은 계층 구조를 표현할때 좋음
- 트리 자료구조 내부에 탐색, 후속자, 선행자를 찾을때 재귀 함수가 용이함















## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****
## 📍 ****

# 📌참조링크
어소트락 게임아카데미 강의 링크- [https://www.youtube.com/watch?v=-h_uxJiiiqg&list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&index=2](https://www.youtube.com/watch?v=-h_uxJiiiqg&list=PL4SIC1d_ab-aOxWPucn31NHkQvNPHK1D1&index=2)