---
published: true
title:  "이코테 2021 강의 몰아보기 #8 기타 그래프 이론, #9 기타 알고리즘"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL, Python]

toc: true
toc_sticky: true
 
date: 2022-03-24
last_modified_at: 2022-03-24
---

# **2022-03-24 TIL**

# 🤔 오늘의 학습목표
- 이코테 2021 강의 몰아보기 #8 기타 그래프 이론
- 이코테 2021 강의 몰아보기 #9 기타 알고리즘


# 📃 학습내용
### **📍 이코테 2021 강의 몰아보기 #8 기타 그래프 이론**

📌 **서로소 집합**
- 공통 원소가 없는 두 집합

**서로소 집합 자료구조** 
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 두 종료의 연산을 지원
  - 합집합(Union): 두 원소가 포함된 집합을 하나의 집합으로 합치는 연상
  - 찾기(Find): 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
- 서로소 집합 자료구조는 합치기 찾기(Union Find) 자료구조 라고 불리기도함

**여러 개의 합치기 연산이 주어졌을 때 서로소 집합 자료구조의 동작과정**
1. 합집합(Union) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인
   1. A와 B의 루트 노드 A', B' 를 각각 찾기
   2. A'를 B'의 부모 노드로 설정
2. 모든 합집합(Union) 연산을 처리할 떄까지 1번의 과정을 반복

**연결성**
- 기본적인 형태의 서로소 집합 자료구조엣는 루트노드에 즉시 접근할 수 없음
 - 루트노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야함 

**기본적인 구현 방법의 문제점**
- 합집합(Union) 연산이 편향되게 이루어지는 경우 찾기(Find) 함수가 비효율 적으로 동작함
- 최악의 경우 찾기(Find) 함수가 모든 노드를 다 확인하게 되어 시간 복잡독 0(V)임

**경로 압축**
- 각 노드에 대하여 찾기(Find) 함수를 호출한 이후에 해당 노드의 루트노드가 바로 부모 노드가됨
- 기본적인 방법에 비하여 시간 복잡도가 개선됨

**서로소 집합을 활용한 사이클 판별**
- 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있음
  - 방향 그래프에서 사이클 여부는 DFS를 이용하여 판별
- **사이클 판별 알고리즘**
  1. 각 간선을 하나씩 확인하며 두 노드의 루트 노드를 확인
     1. 루트 노드가 서로 다르다면 두 노드에 대하여 합집합(uUnion) 연산을 수행
     2. 루트 노드ㅏ 서로 같다면 사이클(Cycle)이 발생한 것
  2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복 

📌 **신장 트리**
- 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미함
  - 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 조건이기도 함.

**최소 신장 트리**
- 최소한의 비용으로 구성되는 신장 트리를 찾아야 할 때

**크루스칼 알고리즘** 
- 대표적인 최소 신장 알고리즘
- 그리디 알고리즘으로 분류됨
- 동작과정
  1. 간성 데이터를 비용에 따라 오름차 순으로 정렬
  2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
    1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킴
    2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않음
  3. 모든 간선에 대하여 2번의 과정을 반복함     

📌 **위상 정렬**
- 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것을 의미함 
- 진입차수(Indegree): 특정한 노드로 들어오는 간선의 개수
- 진출치수(Outdegree): 특정한 노드에서 나가는 간선의 개수
- 동작과정
  1. 진입차수가 0인 모든 노드를 큐에 넣는다
  2. 큐가 빌 때까지 다음의 과정을 반복
     1. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거
     2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다

> 결과적으로 각 노드가 큐에 들어온 순서가 위상 정렬을 수행한 결과와 같음

- **위상 정렬의 특징**
  - 위상 정렬은 DAG에 대해서만 수행할 수 있음
    - DAG (Direct Acyclic Graph): 순환하지 않는 방향 그래프
  - 위상 정렬에서는 여러 가지 답이 존재할 수 있음
    - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면 여러 가지 답이 존재함
  - 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있음
    - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못함
  - 스택을 활용한 DFS를 이용해 위상 정렬을 수행할 수도 있음


### **📍 이코테 2021 강의 몰아보기 #9 기타 알고리즘**

📌 **소수(Prime Number)**
- 소수란 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
  - 6은 1, 2, 3, 6으로 나누어떨어지므로 소수가 아님
  - 7은 1과 7을 제외하고는 나누어 떨어지지 않으므로 소수
- 코딩 테스트에서는 어떠한 자연수가 소수인지 아닌지 판별해야 하는 문제가 자주 출제됨

**소수의 판별: 기본적인 알고리즘**

```py
#소수 판별 함수(2이상의 자연수에 대하여)
def is_prime_number(x):
  # 2부터 (x - 1)까지의 모든 수를 확인하며
  for i in range(2, x):
    # x가 해당 수로 나누어 떨어진다면
    if x % i == 0:
      return False # 소수가 아님
    
  return True

print(is_prime_number(4))
print(is_prime_number(7))
```

- **약수의 성질**
  - 모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이룸
    - 예를 들어 16의 약수는 1, 2, 4, 8, 16
    - 이떄 2 X 8 = 16은 8 X 2 = 16 과 대칭
  - 따라서 특정한 자연수의 모든 약수를 찾을 떄 가운데 약수(제곱근)까지만 확인하면 됨
    - 예를 들어 16이 2로 나누어 떨어진다는 것은 8로도 나누어떨어진다는 것을 의미함.


**소수의 판별: 개선된 알고리즘**

```py
import math

#소수 판별 함수(2이상의 자연수에 대하여)
def is_prime_number(x):
  # 2부터 x의 제곱근까지의 모든 수를 확인하며
  for i in range(2, int(math.sqrt(x)) + 1):
    # x가 해당 수로 나누어 떨어진다면
    if x % i == 0:
      return False # 소수가 아님
    
  return True # 소수임

print(is_prime_number(4))
print(is_prime_number(7))
```


# 😊 배우게 된 점


# 📌참조링크
