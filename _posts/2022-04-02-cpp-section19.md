---
published: true
title:  "따라하며 배우는 C++ Section 19. 모던 C++필수 요소들"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-08
last_modified_at: 2022-05-09
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 19. 모던 C++필수 요소들

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 19. 모던 C++필수 요소들**

### **🌱 19.1 람다 함수와 std::function std::bind, for_each**

**람다 함수**

- 익명함수라고 불림 
- 어원은 람다 캘큘러스에서 나옴
- 보통 lambda function, Anonymous function 이라고 부름

**함수 포인터로써의 람다 함수**

```cpp
auto func = [](const int& i) -> void {cout << "Hello, World!\n"; };  // 람다 함수
```

**익명 함수로써의 람다 함수**

```cpp
[]() -> void { cout << "Hello, World!\n"; }();
```

- 구현할게 잡다하고 많아질때 사용하면 좋음
- GUI 관련 프로그래밍시 많이 사용함


- `[]` lammda-introducer 
  - `[&]` 람다 펑션이 정의된 영역에 `&` 를 넣어놓면 밖에 있는것을 레퍼런스로 가져옴
    - `=` 카피
    - `this` 클래스 멤버 정의
    - `&변수` 

___

**std::for_each**

```cpp
#include <algorithm> // for_each

vector<int> vec;    
vec.push_back(10); 
vec.push_back(20);

auto func2 = [](int val) {cout << val << "  "; };
std::for_each(vec.begin(), vec.end(), func2); 
```

- 이렇게 사용하려고 사용하지 않고 아래 코드와 같이 바로넣어 버려 사용함

```cpp
std::for_each(vec.begin(), vec.end(), [](int val) {cout << val << "  "; });
```

**람다 함수 리턴타입 설정**

```cpp
cout << []() -> int {return 1;} << enld;
```

- int타입으로 설정

___

**std::function**

```cpp
auto func2 = [](int val) {cout << val << "  "; };	
std::function<void(int)> func3 = func2;	
func3(123);
```

- 일종의 함수 포인터를 체계화 시켜준것
  - void 리턴타입
  - int 파라메타 타입

- 함수의 기능을 변수처럼 주고받고함

**std::bind**

```cpp
auto func = [](int val) {cout << val << "  "; };

std::function<void(void)> func2 = std::bind(func, 456);	

func2();  // 456 출력
```

- 파라메타 타입을 자료형을 쓰고싶지않을때 int를 bind하여 넣는 것
- void 타입인 func2에 int타입인 func 함수를 넣어줘서 bind하여서 넣을수 있음

___

**std::placeholders**

```cpp
#include <functional>
#include <iostream>
 
using namespace std;
 
int multiply(int a, int b)
{
    return a * b;
}
 
int main()
{
    auto func = std::bind(multiply, 5, placeholders::_1);
 
    for (int i = 0; i < 10; i++)
    {
        cout << "5 * " << i << " = " << func(i) << endl;
    }
    return 0;
}
```

- 파라메타가 여러개일경우 넣어주는것

### **🌱 19.2 C++ 17 함수에서 여러 개의 리턴값 변환 하기**

**옛날 tuple**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

tuple<int, int> my_func()
{ 
	return tuple<int, int>(123, 456); 
}

int main()
{
	tuple<int, int> result = my_func();
	cout << get<0>(result) << " " << get<1>(result) << endl;
}
```

- 리턴데이터 타입을 구조체나 클래스를 사용해서 만들수도 있음
  - 매번 만들기 귀찮음
- tuple
  - 수학적의미: 여러개의 데이터의 쌍

___

**현대적 C++ tuple 사용법**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto my_func()
{ 
  return tuple<int, int, int>(123, 456, 789); // 옛날 방식
	return tuple(123, 456, 789); // C++ 17 부터 사용가능
}

int main()
{
	auto [a, b, c] = func();
	cout << a << " " << b << " " << c << "\n";
}
```

### **🌱 19.3 std thread와 멀티쓰레딩 기초**

**Process**

- os가 우리가 작성한 프로그램을 실행시킬때 관리하는 단위
- 하나의 프로세스가 여러개의 thread를 관리함


**multithreading**

- 하나의 프로그램을 만들고 그프로그램이 여러개의 thread를 만들어서 여러개의 코어를 동시에 활용해 효율성을 높이는 방법
- 하나의 cpu에 여러개의 코어가 들어있는경우 그코어들을 활용해서 동시에 여러개의 작업을 수행하는 것
- 예전엔 cpu하나에 코어 하나가 들어있던시절에는 한보드에 여러개의 cpu를 넣어서 multithreading을 했었음 보통 2개정도 꽂으면 메모리 속도의 한계때문에 효율이좋지않았음
- **분산처리:** multithreading시 효율을 높이기위해 네트워크로 여러개의 pc를 연결시키고 여러개의 pc에 들어있는 코어들을 전부 동시에 활용하는 것
  - pc가 전부 흩어져 있어 메모리를 공유할수 없음
  - 통신할때 여러가지 부가적인 오버헤드가 생기기도 함
- multithreading은 여러개의 thread들이 메모리를 공유함
  - 위험하기도함
- multicore cpu에서 자동으로 multithreading으로 효율을 높여주는것이 아니고 multithreading을 하도록 프로그래밍을 직접해야함
- thread가 실타래라는 의미를 갖고있어 실선이외에 쭈글쭈글한 선으로 표현하는 경우도 있음

<br>


**Process 수행 순서**

1. 메인 함수로 프로그램이 실행됨 그 메인함수를 실행하고있는 thread를 메인 thread,주된 thread 라고 부름
2. 무거운 작업을 시작할때 여러개의 thread들이 일을 나눠서 작업해야할때 multithreading으로 프로그래밍을 해두고 main thread가 여러개의 thread를 실행을 시킴
  - 부가적인 thread를 실행시킬때 순차적으로 시키지만 동시에 시킨다고 하기도함
  - 자식 thread 에서 또다른 자식 thread 를 실행시킬수도 있음
3. 자식 thread 는 main thread가 어떤 작업을 하던지 간에 별도의 프로그램인것 처럼 작동을 함 
4. 자식 thread가 작업을 마칠때 main thread가 기다리고있음
   - 자식 thread가 작업이 끝나는 시점을 main thread는 알지 못함 
5. 작업이 끝나면 프로그램이 끝남

___

![캡처](https://user-images.githubusercontent.com/90514882/167283762-8b9fbad2-4859-4baf-bbfe-7e3a2c30c26d.PNG)


- **코어:** 물리적 코어의 갯수
- **논리 프로세서:** hyper threading 이라는 기술로 물리적코어의 2배에 해당하는 프로세서를 가지고있는것 처럼 사용할수 있게해줌
- **이용률:** 현재 cpu가 사용되고 있는 비율
  - 논리 프로세서를 모두 고려한 컴퓨팅 능력을 보여주는것
- **프로세서:** 메인 함수를 실행시켜주는 os가 배정해주는 일을하는 존재
- **스레드:** 프로세스 하나가 여러개의 스레드를 사용해서 일을 함

<br>

- main 함수를 실행시키면 프로세스 하나가 실행이된다
- 프로세스 하나가 차지하는 것은 기본적으로 cpu의 논리 프로세서 하나를 사용함

___

**thread**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	cout << std::thread::hardware_concurrency() << endl; // 논리 프로세서 갯수
	cout << std::this_thread::get_id() << endl; // thread id

  // multi thread
	std::thread t1 = std::thread([] {
	cout << std::this_thread::get_id() << '\n';
	//while (true);
	});
	t1.join();		// t1이 끝날 때까지 기다린다.
}
```

- `hardware_concurrency()` 코어갯수 를 받아올수 있음
- `std::this_thread::get_id()` 메인함수가 실행되고있는 thread this_thread의 id를 출력해줌
- 메인함수가 메인스레드를 실행하고 `std::thread t1 = std::thread([] {cout << std::this_thread::get_id() << '\n';});` 안에서 자식스레드를 실행함 자식스레드가 끝난뒤에 메인 스레드와 통신해야하는데 통신하기 전에 메인 함수가 끝나버려 에러가 발생함 
  - 이를 방지하기위해 `t1.join()` 를 사용할수 있음

___

**여러개의 thread 사용하기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	std::thread t1 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t2 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t3 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t4 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	t1.join();
	//t2.join();
	//t3.join();
	//t4.join();
}
```

**출력결과**

```cpp
463276042468
```
- t1, t2, t3, t4 스레드가 각각 병렬로 동시에 실행되기 때문에(멀티스레딩) id가 중구난방으로 섞여 출력됨
- cout이 감당을 못해서 꼬인것

___

**vector에 thread 넣기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	const int num_pro = std::thread::hardware_concurrency();

	vector<std::thread> my_threads;
	my_threads.resize(num_pro);

  for (auto & e : my_threads)
  {
      e = std::thread([](){
				cout << std::this_thread::get_id() << endl;
				while(true){}
          });
  }
		
	for (auto & e : my_threads)
		e.join();
}
```

**출력결과**

```cpp
2438421972
9364
17412
20952
13428

9864
16900
20628
15592
4840
2584
4516
13492
20320
22612




```

- 위 예제코드를 실행시키면 cpu사용률 100퍼를 사용하게됨
  - 중간중간 글자가 깨짐
- multi thread 를 공부하게되면 num_thread와 실제 생성하는 thread 갯수를 신경써야함
- 일반적으로 생성하는 thread 갯수와 하드웨어 프로세서 갯수를 맞추는것이 일반적임 
- 모든문제를 병렬로 다 사용할순없지만 일반적으로 멀티스레딩은 유용함
  
___

```cpp
#include <iostream>
#include <thread>
#include <mutex>		// semaphore는 없음
using namespace std;

int main()
{
	auto work_func = [](const string & name)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	work_func("JackJack");
	work_func("Dash");
}
```

**출력결과**

```cpp
JackJack 5172 is working 0
JackJack 5172 is working 1
JackJack 5172 is working 2
JackJack 5172 is working 3
JackJack 5172 is working 4
Dash 5172 is working 0
Dash 5172 is working 1
Dash 5172 is working 2
Dash 5172 is working 3
Dash 5172 is working 4

```

- `std::this_thread::sleep_for(std::chrono::milliseconds(100));` 쉬는 시간 넣기
  - 실제로는 할 작업을 넣는 부분
- `work_func("JackJack");` 이 실행되는 동안 `work_func("Dash");` 는 놀고있는 형태임
  - multi threading이 아니며 비효율적임

**multi threading으로 바꾸기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	auto work_func = [](const string& name, const int j)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			cout << name << " " << j << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack", 123);
	std::thread t2 = std::thread(work_func, "Dash", 456);

	t1.join();
	t2.join();
}
```

**출력결과**

```cpp
JackJack Dash 456 23564 is working 0123 16988 is working 0

JackJack 123 16988 is working 1
Dash 456 23564 is working 1
JackJack 123 16988 is working 2
Dash 456 23564 is working 2
Dash 456 23564 is working 3
JackJack 123 16988 is working 3
JackJack 123 16988 is working 4
Dash 456 23564 is working 4

```

- 멀티쓰레딩을 사용하는 이유는 동시에 일을하기 위해 사용함
- 작업은 동시에하는데 출력도 동시에나와서 지저분함

**mutex**

```cpp
#include <iostream>
#include <thread>
#include <mutex> 

using namespace std;

mutex mtx; // 선언

int main()
{	

	auto work_func = [](const string& name)
	{

		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			mtx.lock();
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
			mtx.unlock();
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack");
	std::thread t2 = std::thread(work_func, "Dash");

	t1.join();
	t2.join();
}
```

**출력 결과**

```cpp
JackJack 4272 is working 0
Dash 12944 is working 0
Dash 12944 is working 1
JackJack 4272 is working 1
JackJack 4272 is working 2
Dash 12944 is working 2
Dash 12944 is working 3
JackJack 4272 is working 3
JackJack 4272 is working 4
Dash 12944 is working 4

```

- 작업은 동시에하는데 출력도 출력을 순차적으로 해줄수있음
- mutex 는 **mutual exclusion** 를 뜻함 
  - 상호배재 라는뜻
- 여러개의 스레드를 이부분은 건들이지말고 한번에 하나의스레드를 실행시키라는 뜻
- 두 스레드중 작업을 먼저 마친 스레드가 mtx.lock 에 와서 잠궈버림 다른 스레드는 못들어오게됨 그 후 출력 후 lock을 풀고 다른 스레드가 대기를 하고있다가 들어오고 반복하는 과정임
- `mtx.lock();` 을하고 `mtx.unlock();` 을 안해버리면 문제가 발생함
- 멀티스레드는 서로 중복되는 부분에서 문제를 어떻게 해결하느냐가 중요함


### **🌱 19.4 레이스 컨디션, std::atomic, std::scoped_lock**

- Race Condition: 동일한 데이터를 서로 다른 여러 스레드들이 접근하는 과정에서 생기는 문제

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	int shared_memory(0);

	auto count_func = [&](){
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();
	
	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**출력 결과**

```cpp
After
1996

```

- 실전에서는 여러개의 스레드가 함께 사용하는 메모리가 int 정수형 하나뿐 아니라 훨씬더 커질수있음
- `sleep_for` 가없으면 일을 단번에 처리해서 문제가 발생하지않을수도 있음
- 2000 이 출력되야하는데 엉뚱한 값이 나오는 이유
  - 둘다 1000번씩 더하긴함
  1. cpu로 shared_memory 데이터를 가져옴
  2. cpu로 shared_memory 데이터에 1을 더함
  3. 1을 더한 shared_memory값을 다시 shared_memory변수로 보내 덮어씌움
  - cpu로 읽어들인 사이에 스레드 2가 재빨리 값을바꿔버린것

<br>

- `std::this_thread::sleep_for(std::chrono::microseconds(1));` 이것을 지워버리면 2000이 깔끔하게 출력됨
  - 문제가 사라진것이 아님 1000번 더하는게 순식간에 일어나 t1이 끝난뒤에 t2가 실행이되어 깔끔하게 출력이된것 즉, 병렬처리가 된것이 아님
___

**레이스 컨디션 해결 방법 1 atomic**

```cpp
#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	atomic<int> shared_memory(0);
	
	auto count_func = [&]()
	{
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;		// 혹은 shared_memory.fetch_add(1);	
		}
	};

	std::thread t1 = std::thread(count_func);
	std::thread t2 = std::thread(count_func);

	t1.join();
	t2.join();

    cout << "After" << endl;
	cout << shared_memory << '\n';
}
```

**출력 결과**

```cpp
After
2000

```

- atomic: 원자, 쪼갤수없다 라는뜻
  - 스레드 계산 처리방법 3단계를 한방에 하게끔 바꾼것
- `shared_memory++;` 의 `++` 는 증감연산자가 아닌 atomic<int> 의 증감연산자를 오버로딩이 되어있는것 
- 단점으로는 `fetch_add()`, `++` 그냥 증감연산자 등보다 조금 느림
  - 필요한 곳에만 사용해야함

___

**레이스 컨디션 해결 방법 2 mutex**

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

mutex mtx;

int main()
{
	int shared_memory(0);

	auto count_func = [&]() {
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));

			/*mtx.lock();*/
			std::lock_guard lock(mtx);
			std::scoped_lock lock(mtx); // C ++ 17
			shared_memory++;
			/*mtx.unlock();*/
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();

	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**출력 결과**

```cpp
After
2000

```

- mutex를 사용하여 `lock()` 을 걸면 하나의 스레드만 접근하는것이 되어 레이스 컨디션을 방지할수 있음
- unlock을 까먹을수도있고 예외처리시 unlock를 건너뛰는 등 실수를 할 가능성이 있음
  - 이때 사용하는것이 lcokguard가 있음
  - `std::lock_guard lock(mtx);` 
    - lock 이라는 변수가 `{}` 안에 선언이 되어 `{}`이 끝날때 종료되기 때문에 unlock을 해줄필요가 없음
- `std::scoped_lock lock(mtx);`
  - C++ 17에 도입된 기능 lock_guard 보다 진보된 기능 이것을 사용하는것을 더 권장하는 편이라고 함

### **🌱 19.5 작업 기반 비동기 프로그래밍**

- 작업 Task
- 비동기 async
- future, promise

___

- `#include <future>`
  - async,Future,Promise 등을 사용할수있음

**multi-threading**

```cpp
{
	int result;
	std::thread t([&] {result = 1 + 2; });  // 모든 바깥 변수를 레퍼런스로 받으므로 result 값이 변화한다.
	t.join();

	cout << result << '\n';  
}
```

- 최근에는 스레드만 접근하는 변수를 선언하는 방식을 선호하기도함
- 기본적으로 스레드로부터 값을 주거니 받거리 하기위해선 스코프를 넓게 잡고 그 스코프 변수를 여러 스레드들이 공유를 하는것이 일반적임
- 스레드 위주로 프로그래밍이 된것
- 스레드가 몇개 생기고 그 스레드가 각각 어느일을 하는지 지정해주는것

___

**task-based parallellism**

<br>

**async**

```cpp
{
std::future<int> future = std::async([] {return (1 + 2);});  //  auto future 쓰는게 더 간편
cout << future.get() << '\n';  // 3 출력
}
```

- **async:** Asynchronous 비동기적이다 라는뜻
- return 값을 future이 받는것 처럼 프로그래밍 한것
- async 는 스레드를 관리하는 방법이 여러개있음
  - 보통 thread보다 async를 더 선호함
  - multi-threading 보다 task-based parallellism 를 더 선호함
- 어떤 작업을 할것인가 위주 프로그래밍 return 을 해주는 값을 현재 받을수 있는 것이 아님
  - 일반적인 return과 다름 작업시간 이 오래 걸려 나중에 받을수도있음 
- async가 실행되는 task와 정확히 결합이 되는 구조임
- `future.get()` 
  - 리턴값이 int가 날라옴
  - return값이 get() 값으로 나오는것
  - 리턴값을 받기 전이라면 async가 작업을 마치고 값을 return 해줄때 까지 기다림


**promsise**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	// future and promsise
	{	
		std::promise<int> prom;
		auto future = prom.get_future();

		auto t = std::thread([](std::promise<int>&& prom)
		{
            prom.set_value(1 + 2);
        }, std::move(prom));
		
		cout << future.get() << endl;
		t.join();
	}
}
```

- future 를 aysunc 이외에 thread에서도 사용할수 있음
- promsise는 async 처럼 future 를 주지않고 자기 thread를 줌 future를 받을수 있는 존재가 필요해 promise를 거쳐가는것
- prom에 set_value() 를 통해서 값을 받을때까지 future가 계속 기다림
- thread 이기 때문에 `t.join();` 이필요함

___

**async 동시실행**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	auto f1 = std::async([] {
		cout << "Async 1 start\n";
		this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
		cout << "Async 1 end\n";
		});
	auto f2 = std::async([] {
		cout << "Async 2 start\n";
		this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
		cout << "Async 2 end\n";
		});

	cout << "Main function\n";  // 메인 스레드가 실행

}
```

**출력 결과**

```cpp
Main function
Async 1 start
Async 2 start
Async 2 end
Async 1 end

```

- async는 thread와 달리 join이 없음.

**thread 로 바꾸기**

```cpp
{
auto f1 = std::thread([] {
	cout << "Async 1 start\n";
	this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
	cout << "Async 1 end\n";
});
auto f2 = std::thread([] {
	cout << "Async 2 start\n";
	this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
	cout << "Async 2 end\n";
});

cout << "Main function\n";  // 메인 스레드가 실행

f1.join();
f2.join();

}
```

**출력 결과**

```cpp
Main function
Async 2 start
Async 1 start
Async 2 end
Async 1 end

```

### **🌱 19.6 멀티쓰레딩 예제 (백터 내적 계산)**

**백터 내적 계산 전체코드**

```cpp
#include <iostream>
#include <chrono>
#include <mutex>	
#include <utility>
#include <vector>	
#include <atomic>
#include <numeric>		// std::inner_product
#include <random>
#include <execution>	// parallel execution
#include <future>
#include <thread>

using namespace std;

mutex mtx;

void dotProductNaive(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

void dotProductLock(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	//cout << "Thread Start" << endl;
	for (unsigned int i = start; i < end; ++i)
	{
		std::scoped_lock lock(mtx);
		sum += (v0[i] * v1[i]);
	}
	//cout << "Thread End" << endl;
}

void dotProductAtomic(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, atomic<unsigned long long> & sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

auto dotProductFuture(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end)
{
	int sum = 0;
	for (unsigned int i = start; i < end; ++i)
		sum += (v0[i] * v1[i]);
	return sum;
}


int main()
{
	const long long numData = 100'000'000;
	const unsigned int numThread = 4;
	// thread 개수 늘린다고 degree of multithreading이 높아지지는 않음

	vector<int> vec0, vec1;
	vec0.reserve(numData);
	vec1.reserve(numData);

	std::random_device seed;
	std::mt19937_64 makerand(seed());
	std::uniform_int_distribution<> range(1, 10);

	for (long long i = 0; i < numData; ++i)
	{
		vec0.push_back(range(makerand));
		vec1.push_back(range(makerand));
	}

	cout << "실험 1번 - std::inner_product\n";
	{
		const auto sta = std::chrono::steady_clock::now();		// 시간 측정 시작
		const auto sum = std::inner_product(vec0.begin(), vec0.end(), vec1.begin(), 0ull);
		// 두 벡터의 개수가 같다고 가정하므로 vec1은 begin만 있어도 되며 ull은 unsigned long long의 약자
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;		

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}

	cout << "실험 2번 - Naive\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductNaive, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}

	cout << "실험 3번 - Lockguard\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}

	cout << "실험 4번 - Atomic\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		atomic<unsigned long long> sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductAtomic, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}

	cout << "실험 5번 - Future\n";
	{
		const auto sta = std::chrono::steady_clock::now();

		unsigned long long sum = 0;

		vector<std::future<int>> futures;
		futures.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			futures[t] = std::async(dotProductFuture, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread);
		for (unsigned int t = 0; t < numThread; ++t)
			sum += futures[t].get();
		
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}
	// TODO : Future의 divide and conquer 방식은 thread에서도 구현해보자.
	// async 대신에 thread와 promise를 사용해서 future을 사용해보자.
	
  cout << "실험 6번 - promise\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		vector<std::promise<int>> prom;
		vector<std::future<int>> future;
		vector<std::thread> threads;
		prom.resize(numThread);
		future.resize(numThread);
		threads.resize(numThread);
		
		unsigned long long sum(0);
		unsigned numPerThread = numData / numThread;
		for (unsigned i = 0; i < numThread; ++i)
		{
			future[i] = prom[i].get_future();
			unsigned long long tempSum(0);
			threads[i] = std::thread([&](std::promise<int>&& prom)
				{
					std::scoped_lock lock2(mtx);
					
					for (unsigned int j = 0; j < numPerThread; ++j)
						tempSum += (vec0[j] * vec1[j]);
					prom.set_value(tempSum);
				}, std::move(prom[i]));
			threads[i].join();
		}
		for (unsigned int t = 0; t < numThread; ++t)
			sum += future[t].get();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}

	cout << "실험 7번 - std::transform_reduce\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		const auto sum = std::transform_reduce(std::execution::par, vec0.begin(), vec0.end(), vec1.begin(), 0ull);
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "연산에 소요된 시간 = " << dur.count() << '\n';
		cout << "결과값 = " << sum << '\n';
		cout << '\n';
	}
}
```

___

**main 함수**

```cpp
using namespace std;

mutex mtx;

int main()
{
	const long long numData = 100'000'000;
	const unsigned int numThread = 4;

	vector<int> vec0, vec1;
	vec0.reserve(numData);
	vec1.reserve(numData);

	std::random_device seed;
	std::mt19937_64 makerand(seed());
	std::uniform_int_distribution<> range(1, 10);

	for (long long i = 0; i < numData; ++i)
	{
		vec0.push_back(range(makerand));
		vec1.push_back(range(makerand));
	}
```

- 내적: 기하학 닷프로덕트 와 같은것 안의 원소가 많을경우에는 내적이라고 부름
- 2,3차원 vector 끼리의 내적을 닷 프로덕트라고 부름 
- 스레드를 많이쓴다고 멀티스레딩 효율이 높아 지진않음
- 1억개의 랜덤 원소를 갖고있는 vector 두개를 만든것

___

**inner_product**

```cpp
cout << "실험 1번 - std::inner_product\n";
{
	const auto sta = std::chrono::steady_clock::now();		// 시간 측정 시작
	const auto sum = std::inner_product(vec0.begin(), vec0.end(), vec1.begin(), 0ull);
	// 두 벡터의 개수가 같다고 가정하므로 vec1은 begin만 있어도 되며 ull은 unsigned long long의 약자
	const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

	cout << "연산에 소요된 시간 = " << dur.count() << '\n';
	cout << "결과값 = " << sum << '\n';
	cout << '\n';
}
```

- `#include <numeric>` 
  - `std::inner_product`
- vec1은 `begin()` 만 있으면됨 두개의 갯수가 갖다고 가정하기 때문임
- auto 에서 `0ull` 을 넣어줬기 때문에 unsigned long long 으로 형변환을 해줌
- `now()` 계산 시간 시작
- `dur.count()` 계산 종료 시간 출력
- 병렬처리를 할때는 사소한 실수로 결과가 다르게 나올경우가 있음 멀티쓰레딩 프로그래밍시 정답을 계산하고 그것과 비교하고 퍼포먼스를 비교하는 방식으로 작업하는 것이 좋음


___

**순진한 멀티 쓰레딩**

```cpp
void dotProductNaive(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

...

unsigned long long sum = 0;

vector<std::thread> threads;
threads.resize(numThread);

const unsigned int numPerThread = numData / numThread;

for (unsigned int t = 0; t < numThread; ++t)
	threads[t] = std::thread(dotProductNaive, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

for (unsigned int t = 0; t < numThread; ++t)
	threads[t].join();


const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

cout << "연산에 소요된 시간 = " << dur.count() << '\n';
cout << "결과값 = " << sum << '\n';
cout << '\n';
```

- numPerThread 을 딱떨어지게 계산하거나 남은수를 몇몇개의 스레드에게 일을 시키는등으로 처리해야함
- 스레드 갯수만큼 for문을 돌면서 스레드를 만듬
- std::ref() 로 명시해서 넘겨주고있음
- 스레드 1억개를 스레드에 맞춰서 잘라서 넣어줌
- 레이스 컨디션 현상으로 `inner_product` 와 결과값이 다름

___

**Lockguard**

```cpp
mutex mtx;

void dotProductLock(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	//cout << "Thread Start" << endl;
	for (unsigned int i = start; i < end; ++i)
	{
		std::scoped_lock lock(mtx); // c++ 17
		sum += (v0[i] * v1[i]);
	}
	//cout << "Thread End" << endl;
}

...

cout << "실험 3번 - Lockguard\n";
{
	const auto sta = std::chrono::steady_clock::now();

	unsigned long long sum = 0;

	vector<std::thread> threads;
	threads.resize(numThread);

	const unsigned int numPerThread = numData / numThread;
	for (unsigned int t = 0; t < numThread; ++t)
		threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1),
			t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
	for (unsigned int t = 0; t < numThread; ++t)
		threads[t].join();

	const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

	cout << "연산에 소요된 시간 = " << dur.count() << '\n';
	cout << "결과값 = " << sum << '\n';
	cout << '\n';
}
```

- `mutex mtx;` 는 여러스레드가 접근할수있는곳에 선언
- scoped_lock으로 방지
- 값은 정확히 떨어지지만 수행시간이 매우느림
  - scoped_lock을 for문 밖으로빼면 속도가 더 빨리짐
  - 시퀀셜하게 실행이되어 lock을 블럭 전체에 처리하는건 의미가없음
  - scoped_lock은 영역을 좁은곳에 넣은게좋지만 너무많이 실행이되면 오히려느려짐

___

**atomic**

```cpp
void dotProductAtomic(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, atomic<unsigned long long> & sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

...

const unsigned int numPerThread = numData / numThread;

for (unsigned int t = 0; t < numThread; ++t)
	threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

for (unsigned int t = 0; t < numThread; ++t)
	threads[t].join();
```

- lock_guard 에 비해 구현이 간단함 
- 결과는 동일하게 나왔으나 느림
- 더해주는 연산이 빈번하여 퍼포먼스가 느려짐

___

**Task-based parallelism (std::async)**

```cpp
auto dotProductFuture(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end)
{
	int sum = 0;
	for (unsigned int i = start; i < end; ++i)
		sum += (v0[i] * v1[i]);
	return sum;
}

...

unsigned long long sum = 0;

vector<std::future<int>> futures;
futures.resize(numThread);

const unsigned int numPerThread = numData / numThread;
for (unsigned int t = 0; t < numThread; ++t)
	futures[t] = std::async(dotProductFuture, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread);

for (unsigned int t = 0; t < numThread; ++t)
	sum += futures[t].get();
```

- int 로 받는 이유는 부분합은 int로 들어오기때문에 int로 받음
  - unsigned long long 으로 바꿔도됨
- 멀티스레딩시 각각의 스레드가 연산을하고 끝낸결과를 받아와 취합하는것이 제일좋음
- 위의 멀티스레딩 예제에선 sum 이라는 글로벌 변수에 여러스레드가 달려들어 값을 더해나가는 방식이엇고 async가 작동할때 부분합을 리턴해주고 그걸 futures로 받아와 합치는 방식
  - 위 멀티스레잉 예제의 함수에선 값을 리턴을 못해줬지만 Future에선 리턴이 가능 함
- 결과가 잘나오고 속도가 `inner_product`의 1/4 정도의 속도가 나옴

___

**std::transform_reduce**

- std::dot 프로덕트의 병렬버전이 std::transform_reduce 라는 함수임
- std::sort 등이 병렬처리를 지원함

```cpp
const auto sum = std::transform_reduce(std::execution::par, vec0.begin(), vec0.end(), vec1.begin(), 0ull);
```

- `std::execution::par`
  - par 패러랠의 약자
  - 병렬로 실행
- `std::execution::seq`
  - seq 시퀀셜의 약자
  - 순차적으로 실행

### **🌱 19.7 완벽한 전달과 std::forward**

- Perfect Forwarding


```cpp
#include <iostream>	
#include <vector>
#include <utility> // std::forward

using namespace std;

struct myStruct
{};

void func(struct myStruct& s) { cout << "Pass by L-ref\n"; }  // L-value Reference 오버로딩
void func(struct myStruct&& s) { cout << "Pass by R-ref\n"; }  // R-value Reference 오버로딩

template<typename T>   // 여러가지 타입을 T로 받을 수 있다.
void func_wrapper(T t)
{
    func(t);
}

int main()
{
	myStruct s;

	func(s);			
	func(myStruct()); // 적당한 것을 IDE가 잘 찾아서 연결해준다.

    cout << endl;

	func_wrapper(s);
	func_wrapper(myStruct());
}
```

**출력 결과**

```cpp
Pass by L-ref
Pass by R-ref

Pass by L-ref
Pass by L-ref

```

- 직접적으로 사용하는것은 컴파일러가 L-value인지 R-value 인지 구분해줌
- 템플릿 사용시에는 구분을 안해줌
  - 템플릿타이즈가되면서 L-value인지 R-value 인지 정보가 날라가서 L-value가 됨

___

**std::forward**

```cpp
#include <iostream>	
#include <vector>
#include <utility> // std::forward

using namespace std;

struct myStruct
{};

void func(struct myStruct& s) { cout << "Pass by L-ref\n"; }
void func(struct myStruct&& s) { cout << "Pass by R-ref\n"; }

template<typename T>
void func_wrapper(T&& t)
{
	func(std::forward<T>(t));
}

int main()
{
	myStruct s;

	func_wrapper(s);
	func_wrapper(myStruct());
}
```

**출력 결과**

```cpp
Pass by L-ref
Pass by R-ref

```

- `std::forward` 가 하는일을 T가 들어올때 L-value 로 들어오면 L-value 로 리턴해주고 R-value 로 들어왔으면 R-value로 리턴해줌

___

**Move Semantics 와 연관지어 생각해보기**

```cpp
#include <iostream>	
#include <vector>
#include <utility>

using namespace std;

class CustomVector
{
public:
	unsigned n_data = 0;  // 동적 배열의 사이즈가 될 멤버 변수
	int *ptr = nullptr;  // 동적 배열 포인터가 될 멤버 변수 (할당은 init 함수에서)

	CustomVector(const unsigned & _n_data, const int & _init = 0)
	{
		cout << "Constructor" << endl;
		
		init(_n_data, _init);
	}

	CustomVector(CustomVector & l_input)  // L-value 만 받을 수 있다.
	{
		cout << "Copy construtor" << endl;

		init(l_input.n_data);


        // 🎉깊은 복사 
		for (unsigned i = 0; i < n_data; ++i)  
			ptr[i] = l_input.ptr[i];
	}

	CustomVector(CustomVector && r_input) // R-value 만 받을 수 있다.
	{
		cout << "Move construtor" << endl;

        // 🎉얕은 복사 
        // 소유권 이전
		n_data = r_input.n_data;
		ptr = r_input.ptr;

        // 소유권 박탈
		r_input.n_data = 0;
		r_input.ptr = nullptr;
	}
	
	~CustomVector()
	{
		delete[] ptr;
	}

	void init(const unsigned & _n_data, const int & _init = 0)
	{
		n_data = _n_data;
		ptr = new int[n_data];
		for (unsigned i = 0; i < n_data; ++i)
			ptr[i] = _init; 
	}
};


void doSomething(CustomVector & vec)
{
	cout << "Pass by L-reference" << endl;
	CustomVector new_vec(vec);
}

void doSomething(CustomVector && vec)
{
	cout << "Pass by R-reference" << endl;
	CustomVector new_vec(std::move(vec));  // R-value로 vec을 받았더라도 std::move로서 넘겨주어야 한다. 
}

template<typename T>
void doSomethingTemplate_O(T && vec)  // 올바르게 R-value, L-value를 구분해서 컴파일 한다.
{
	doSomething(std::forward<T>(vec));
}

template<typename T>
void doSomethingTemplate_X(T vec)  // R-value, L-value를 구분해서 컴파일 하지 못하고 그냥 다 L-value로 처리해버린다.
{
	doSomething(vec);
}
```

- `void doSomething(CustomVector && vec)` move() 를빼고 그냥넣어버리면 L-value로 받아 copy Constructor 가 호출됨
- vec 자체는 변수라 l-value로 들어감
- R-value 로 파라메타를 받는 함수를 오버로딩할때는 `std::move()` 를써서 명확하게 구현하기

**L-value 깊은 복사**

```cpp
int main()
{
    CustomVector my_vec(10, 1024);
	CustomVector temp(my_vec);  // my_vec 은 L-value

	cout << my_vec.n_data << endl;
}
```

**출력 결과**

```cpp
Constructor
Copy constructor
10
```

**R-value 얕은 복사**

```cpp
int main()
{
    CustomVector my_vec(10, 1024);
	CustomVector temp(std::move(my_vec));  // my_vec 은 R-value

	cout << my_vec.n_data << endl;
}
```

**출력 결과**

```cpp
Constructor
Move constructor
0
```

- std::move() 로 R-value 로 바꿔준다는 개념보단 Move constructor 를 부른다는 느낌이 강함 
- R-value 를 파라메타로 넣어주어 Move constructor 가 실행됨 
- 깊은복사와 얕은 복사 수행시간 차이가 많이 날것임

___

```cpp
int main()
{
    CustomVector my_vec(10, 1024);
	CustomVector temp(std::move(my_vec));  // my_vec 은 R-value

	cout << my_vec.n_data << endl;
}
```

**출력 결과**

```cpp
Constructor
Move constructor
0
```

- my_vec을 사용하여 객체를 만들 대, my_vec을 또 사용하겠다는 의지가 있다면 소유권이 박탈되지 않게끔 깊은 복사를 사용하는 L-value로서 넘겨야 하고 `CustomVector(10, 8)`처럼 더는 사용할 일이 없는 R-value라면 이동 생성자를 호출하는 것을 권장한다.

___

**template**

```cpp
template<typename T> // 틀린 예제
void doSomethingTemplate_X(T vec)  // R-value, L-value를 구분해서 컴파일 하지 못하고 그냥 다 L-value로 처리해버린다.
{
	doSomething(vec);
}

template<typename T> // 올바른 예제
void doSomethingTemplate_O(T&& vec)  // 올바르게 R-value, L-value를 구분해서 컴파일 한다.
{
	doSomething(std::forward<T>(vec));
}

int main()
{
    CustomVector my_vec(10, 1024);

	doSomethingTemplate_O(my_vec);
    doSomethingTemplate_O(CustomVector(10, 8));

	my_vec;
}
```

### **🌱 19.8 자료형 추론 auto와 decttype**

- Type Inference

**전체코드**

```cpp
#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>

using namespace std;

class Examples
{
public:
	void ex1()
	{
		std::vector<int> vect;
		for (std::vector<int>::iterator itr = vect.begin(); itr != vect.end(); ++itr)
			cout << *itr;
		for (auto itr = vect.begin(); itr != vect.end(); itr++)
			cout << *itr;

		for (auto itr : vect) //for (const & itr : vect)
			cout << itr;
	}
	void ex2()
	{
		int x = int();
		auto auto_x = x;
		const int& crx = x;
		auto auto_crx1 = crx; //auto는 형을 받아들일 때 const를 떼 버린다.
		const auto& auto_crx2 = crx;  //auto에 const와 &를 받아줘야 한다.
		volatile int vx = 1024;
		//volatile은 값이 자주 변하기 때문에 최적화할 때 뺴 달라는 말.
		auto avx = vx; //여기도 volatile을 떼고 int만 남긴다.
		volatile auto vavx = vx;
		//auto는 가장 기본적인 것만 변환하고, 자잘한 것은 추가해야 한다.
	}

	template<class T>
	void func_ex3(T arg)
	{}

	/*template <class T>
	void func_ex3(const T& arg)
	{}
	*/  //이렇게 추가해야 한다.

	void ex3()
	{
		const int& crx = 123;
		func_ex3(crx);    //여기서 const 와 &를뗴 버린다.
	}

	void  ex4()
	{
		const int c = 0;
		auto& rc = c;
		//rc = 123; //error //여기서 const가 여전히 붙어 있다.
		//여기서 const int의 reference는 무조건 const가 붙어야 한다(아니면 못 가져옴)
		//그래서 이럴 땐 auto가 const를 붙인다.
	}

	void ex5() //amendment = 개정
	{
		int i = 42;
		auto&& ri_1 = i; //l-value  //왼쪽에 l-value가 들어오면 무조건 l-value.
		auto&& ri_2 = 42; //r-value
	}

	void ex6()
	{
		int x = 42;
		const int* p1 = &x;
		auto p2 = p1;   //const int * 까지 찾아줌.
	}

	template <typename T, typename S>
	void func_ex7(T lhs, S rhs)
	{
		auto prod1 = lhs * rhs;   //곱하기를 한 결과값의 형이 어떻게 되는지 모름!

		//typedef typeof(lhs * rhs) product_type; //pre-c++11 'some' compilers
		//일부 컴파일러에서 제공해줬음. 즉, 데이터 타입을 리턴해주는 함수가 있었음.
		typedef decltype(lhs* rhs) product_type;
		//이것이 정식으로 넘어옴. decltype으로.

		product_type prod2 = lhs * rhs;
		decltype(lhs * rhs) prod3 = lhs * rhs; //자료형처럼 바로 사용할 수 있음.
	}

	template <typename T, typename S>
	auto func_ex8(T lhs, S rhs) -> decltype(lhs* rhs)
	{
		return lhs * rhs;
	}
	//decltype(lhs * rhs) func_ex8(T lhs, S rhs)
	//는 컴파일러가 읽어들이는 순서 상 읽을 수 없다.

	void ex7_8()
	{
		func_ex7(1.0, 345);
		func_ex8(1.2, 345);
	}

	struct S
	{
		int m_x;
		S()
		{
			m_x = 42;
		}
	};

	void ex9()
	{
		int x;
		const int cx = 42;
		const int& crx = x;
		const S* p = new S();
		auto a = x;
		auto b = cx;
		auto c = crx;
		auto d = p;
		auto e = p->m_x;
		//e는 그냥 integer가 된다. p는 const지만 복사해서 상관없어지는 것

		typedef decltype(x) x_type;	//int
		typedef decltype(cx) cx_type; //const int
		typedef decltype(crx) crx_type; //const int &
		typedef decltype(p->m_x) m_x_type; //int
		//멤버는 int로 선언되어 있어서.
		//declared type은 선언된 타입 그대로를 다 가져옴.

		typedef decltype((x)) x_with_parens_type;  //add references to lvalues
		typedef decltype((cx)) cx_with_parens_type;
		typedef decltype((crx)) crx_with_parens_type;
		typedef decltype((p->m_x)) m__with_parens_type;
		//reference라 변화가 되면 안된다는 const도 같이 가져옴
	}

	const S foo()
	{
		return S();
	}

	const int& foobar()
	{
		return 123;
	}

	void ex10()
	{
		std::vector<int> vect = { 42, 43 };
		auto a = foo();   //S
		typedef decltype(foo()) foo_type; //const S
		auto b = foobar();
		typedef decltype(foobar()) foobar_type;

		auto itr = vect.begin();
		typedef decltype(vect.begin()) iterator_type;

		auto first_element = vect[0];
		decltype(vect[1]) second_element = vect[1];
	}

	void ex11()
	{
		int x = 0;
		int y = 0;
		const int cx = 42;
		const int cy = 43;
		double d1 = 3.14;
		double d2 = 2.72;

		typedef decltype(x* y) prod_xy_type; //int
		auto a = x * y; //int

		typedef decltype(cx* cy) prod_cxcy_type; //int
		auto a = cx * cy; //in //result is prvalue, 상수이므로 그냥 int

		typedef decltype(d1 < d2 ? d1 : d2) cond_type; // l-value에는 &가 붙는다.
		auto c = d1 < d2 ? d1 : d2;   //그냥 double

		typedef decltype(x < d2 ? x : d2) cond_type_mixed; //double로 형변환이 잘 된다.
		auto d = x < d2 ? x : d2;  

		//auto d = std::min(x, dbl); //error, min은 데이터 타입이 같아야 비교해줌.
	}

	template<typename T, typename S>
	auto fpmin_wrong(T x, S y) -> decltype(x < y ? x : y)
	{
		return x < y ? x : y;
	}
	//여기서 T와 S의 형이 같으면 reference가 붙는게 단점.

	template<typename T, typename S>
	auto fpmin(T x, S y) ->
		typename std::remove_reference<decltype(x < y ? x : y)>::type
		//reference를 제거한 타입을 사용한다.
	{
		return x < y ? x : y;
	}

	void ex12()
	{
		int i = 42;
		double d = 45.1;
		//auto a = std::min(i, d); //error
		auto a = std::min(static_cast<double>(i), d);
		int& j = i;
		typedef decltype(fpmin_wrong(d, d)) fpmin_return_type1;  //double의 reference
		typedef decltype(fpmin_wrong(d, d)) fpmin_return_type2; //그냥 double
		typedef decltype(fpmin_wrong(d, d)) fpmin_return_type3; //그냥 double
	}

	void ex13()
	{
		std::vector<int> vect; //vect is empty
		typedef decltype(vect[0]) integer;
		//실제 수행은 안해서 문제는 안 생김
	}

	template<typename R>
	class SomeFunctor
	{
	public:
		typedef R result_type;
		SomeFunctor()
		{

		}
		result_type operator() ()
		{
			return R();
		}
	};

	void ex14()
	{
		SomeFunctor<int> func;
		typedef decltype(func)::result_type integer; //nested type;
		//함수 안의 nested type도 간편하게 접근 가능.
	}

	void ex15()
	{
		auto lambda = []() {return 42; };
		decltype(lambda) lambda2(lambda);
		decltype((lambda)) lambda3(lambda);
		cout << "Lambda functions" << endl;
		cout << &lambda << " " << &lambda2 << endl;
		cout << &lambda << " " << &lambda3 << endl;
	}

	void ex16()
	{

		//generic lambda
		auto lambda = [](auto x, auto y)
		{
			return x + y;
		};
		cout << lambda(1.1, 2) << " " << lambda(3, 4) << " " << lambda(4.5, 2.2) << endl;
	}
};
int main()
{
	Examples examples;

	examples.ex1();
	examples.ex2();
	examples.ex3();
	examples.ex10();
	examples.ex12();
	examples.ex14();
	examples.ex15();
	examples.ex16();
}
```

___


**예제 1**

```cpp
using namespace std;

void ex()
{
	vector<int> vect;
	
//  1️⃣
	for (vector<int>::const_iterator cit = vect.begin(); cit != vect.end(); ++cit)
		cout << *cit;
//  2️⃣
	for (auto itr = vect.begin(); itr != vect.end(); ++itr)
		cout << *itr;
//  3️⃣
	for (auto itr : vect)
		cout << itr;
}
```

- vector 사용시 초기화할때 auto가 자동으로 인식해주기 때문에 편해짐

___


**예제 2**

```cpp
void ex2()
{
	int x = int();
	auto auto_x = x;
	const int& crx = x;
	auto auto_crx1 = crx; //auto는 형을 받아들일 때 const를 떼 버린다.
	const auto& auto_crx2 = crx;  //auto에 const와 &를 받아줘야 한다.
	volatile int vx = 1024;
	//volatile은 값이 자주 변하기 때문에 최적화할 때 뺴 달라는 말.
	auto avx = vx; //여기도 volatile을 떼고 int만 남긴다.
	volatile auto vavx = vx;
	//auto는 가장 기본적인 것만 변환하고, 자잘한 것은 추가해야 한다.
}
```

- auto에 const int & 를 넣으면 const나 &를 다 떼어버림
  - const auto& 와같이 지정을 해주면 사용할수 있음
- `volatile:` 값이 자주바뀌기때문에 최적화시 빼달라는 뜻 
  - 멀티스레딩시 사용

___

**예제 3**

```cpp
template<class T>
void func_ex3(T arg)
{}

/*template <class T>
void func_ex3(const T& arg)
{}
*/  //이렇게 추가해야 한다.

void ex3()
{
	const int& crx = 123;
	func_ex3(crx);    //여기서 const 와 &를뗴 버린다.
}
```

- `const int & crx = 123;` 를 파라메타로 넣어줬을때 template T 의 형태로 받아오면 const 와 & 다떼고 int만 남음
- 예제 2 와같이 파라메타에 const & 등 지정을해야함
- template 타입 디럭션로 auto와 비슷한 방식이다

___

**예제 4**

```cpp
void ex()
{
	const int c = 0;
	auto& rc = c;
    // rc = 123 - error!
}
```

- 레퍼런스로 가져올려고할때는 가져오는 데이터가 레퍼런스여 야 하고 이때 auto 에서는 const도 같이 추론을 시켜줌
___

**예제 5**

```cpp
void ex()
{
	int i = 40;
	auto && ri = i;		// ri는 l-value. int& ri 왜냐하면 들어온게 l-value니까
	auto && ri2 = 42;	// ri2는 r-value. int&& ri2
	auto && ri3 = std::move(i); // ri3는 r-value.  int && ri3
}
```

- 대입되는 존재가 l-value 면 레퍼런스로 바뀜
- 대입되는 존재가 r-value 면 r-value로 받아드림

___

**예제 6**

```cpp
void ex()
{
	int i = 40;
	const int* pi = &i;
	auto p = pi;		
    
    // ex2, ex4와는 달리 이번에는 int가 아니라 const int * 까지 다 가져옴
	// 즉, 포인터일 경우에는 auto가 값을 다 가져오는 것을 알 수 있음
}
```

- `const int*` 까지 추론해줌

___

**decltype**

**예제 7**

```cpp
template <typename T, typename S>
void func_ex7(T lhs, S rhs)
{
	auto prod1 = lhs * rhs;   //곱하기를 한 결과값의 형이 어떻게 되는지 모름!

	//typedef typeof(lhs * rhs) product_type; //pre-c++11 'some' compilers
	//일부 컴파일러에서 제공해줬음. 즉, 데이터 타입을 리턴해주는 함수가 있었음.
	typedef decltype(lhs* rhs) product_type;
	//이것이 정식으로 넘어옴. decltype으로.

	product_type prod2 = lhs * rhs;
	decltype(lhs * rhs) prod3 = lhs * rhs; //자료형처럼 바로 사용할 수 있음.
}

void ex7_8()
{
	func_ex7(1.0, 345);
	func_ex8(1.2, 345);
}
```

- C++ 11 이전에는 계산된값의 데이터 타입 을 리턴받아 사용했었음
- `decltype()` 안에선 실행되는건 아니고 추론되는 것

___

**예제 8**

```cpp
template <typename T, typename S>

template <typename T, typename S>
auto func_ex8(T lhs, S rhs) -> decltype(lhs* rhs)
{
	return lhs * rhs;
}
//decltype(lhs * rhs) func_ex8(T lhs, S rhs)
//는 컴파일러가 읽어들이는 순서 상 읽을 수 없다.

void ex7_8()
{
	func_ex7(1.0, 345);
	func_ex8(1.2, 345);
}
```

- 리턴 타입에도 사용할수 있음
___

**예제 9**

```cpp
struct S
{
	int m_x;
	S()
	{
		m_x = 42;
	}
};

void ex9()
{
	int x;
	const int cx = 42;
	const int& crx = x;
	const S* p = new S();

	auto a = x;
	auto b = cx;
	auto c = crx;
	auto d = p;
	auto e = p->m_x;
	//e는 그냥 integer가 된다. p는 const지만 복사해서 상관없어지는 것

	typedef decltype(x) x_type;	//int
	typedef decltype(cx) cx_type; //const int
	typedef decltype(crx) crx_type; //const int &
	typedef decltype(p->m_x) m_x_type; //int
	//멤버는 int로 선언되어 있어서.
	//declared type은 선언된 타입 그대로를 다 가져옴.

	typedef decltype((x)) x_with_parens_type;  //add references to lvalues
	typedef decltype((cx)) cx_with_parens_type;
	typedef decltype((crx)) crx_with_parens_type;
	typedef decltype((p->m_x)) m__with_parens_type;
	//reference라 변화가 되면 안된다는 const도 같이 가져옴
}
```

- `(())` 레퍼런스를 더해줌 
  - 원래 레퍼런스라면 그냥 유지함

___

**예제 10**

```cpp
const S foo()
{
	return S();
}

const int& foobar()
{
	return 123;
}

void ex10()
{
	std::vector<int> vect = { 42, 43 };
	auto a = foo();   //S
	typedef decltype(foo()) foo_type; //const S
	auto b = foobar(); // int
	typedef decltype(foobar()) foobar_type; // const int &

	auto itr = vect.begin();
	typedef decltype(vect.begin()) iterator_type;

	auto first_element = vect[0]; // int
	decltype(vect[1]) second_element = vect[1]; // int &
}
```

- auto 에선 리턴타입을 S로만 받고
- vector에 오버로딩 되어있는 `[]` 오퍼레이터가 리턴할때 `int &` 를 리턴하는 함수임

___

**예제 11**

```cpp
void ex11()
{
	int x = 0;
	int y = 0;
	const int cx = 42;
	const int cy = 43;
	double d1 = 3.14;
	double d2 = 2.72;

	typedef decltype(x* y) prod_xy_type; //int
	auto a = x * y; //int

	typedef decltype(cx* cy) prod_cxcy_type; //int
	auto a = cx * cy; //in // result is prvalue, 상수이므로 그냥 int

	typedef decltype(d1 < d2 ? d1 : d2) cond_type; // l-value에는 &가 붙는다.
	auto c = d1 < d2 ? d1 : d2;   //그냥 double

	typedef decltype(x < d2 ? x : d2) cond_type_mixed; //double로 형변환이 잘 된다.
	auto d = x < d2 ? x : d2;

	//auto d = std::min(x, dbl); //error, min은 데이터 타입이 같아야 비교해줌.
	
	template<typename T, typename S>
	auto fpmin_wrong(T x, S y) -> decltype(x < y ? x : y)
	{
		return x < y ? x : y;
	}
	//여기서 T와 S의 형이 같으면 reference가 붙는게 단점.

	template<typename T, typename S>
	auto fpmin(T x, S y) ->
		typename std::remove_reference<decltype(x < y ? x : y)>::type
		//reference를 제거한 타입을 사용한다.
	{
		return x < y ? x : y;
	}
}
```

- fpmin_wrong 부스트 라이브러리에 fpmin이라는 것이 들어있었음
- `remove_reference` 레퍼런스를 제거한 

___

**예제 12**

```cpp
void ex12()
{
	int i = 42;
	double d = 45.1;
	//auto a = std::min(i, d); //error
	auto a = std::min(static_cast<double>(i), d);
	int& j = i;
	typedef decltype(fpmin_wrong(d, d)) fpmin_return_type1;  //double의 reference
	typedef decltype(fpmin_wrong(i, d)) fpmin_return_type2; //그냥 double
	typedef decltype(fpmin_wrong(j, d)) fpmin_return_type3; //그냥 double
}
```
___

**예제 13**

```cpp
void ex13()
{
	std::vector<int> vect; //vect is empty
	typedef decltype(vect[0]) integer;
	//실제 수행은 안해서 문제는 안 생김
}
```

- decltype 은 실제 수행을 안하기 때문에 vector에 내용물이 없어도 에러가 발생이안됨

___

**예제 14**

```cpp
template<typename R>
class SomeFunctor
{
public:
	typedef R result_type;
	SomeFunctor()
	{

	}
	result_type operator() ()
	{
		return R();
	}
};

void ex14()
{
	SomeFunctor<int> func;
	typedef decltype(func)::result_type integer; //nested type;
	//함수 안의 nested type도 간편하게 접근 가능.
}
```

___

**예제 15**

```cpp
void ex15()
{
	auto lambda = []() {return 42; }; // class lambda
	decltype(lambda) lambda2(lambda); // 같은기능을하는 람다함수가 하나더 생김
	decltype((lambda)) lambda3(lambda); // 레퍼런스를 리턴받아 넣어주는형태
	cout << "Lambda functions" << endl;
	cout << &lambda << " " << &lambda2 << endl; // 서로 다름
	cout << &lambda << " " << &lambda3 << endl; // 서로 같음
}
```
___

**예제 16**

```cpp
void ex16()
{

	//generic lambda
	auto lambda = [](auto x, auto y)
	{
		return x + y;
	};
	cout << lambda(1.1, 2) << " " << lambda(3, 4) << " " << lambda(4.5, 2.2) << endl;
}
```

- 람다에도 auto를 사용할수 있음

# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**공부하는 식빵맘 👱‍♀️ 님의 블로그** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)

**maxlafe-개발 블로그** - [https://maxcomfem.tistory.com/22](https://maxcomfem.tistory.com/22)