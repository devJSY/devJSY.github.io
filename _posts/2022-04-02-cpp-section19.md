---
published: true
title:  "따라하며 배우는 C++ Section 19. 모던 C++필수 요소들"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-08
last_modified_at: 2022-05-08 
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 19. 모던 C++필수 요소들

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 19. 모던 C++필수 요소들**

### **🌱 19.1 람다 함수와 std::function std::bind, for_each**

**람다 함수**

- 익명함수라고 불림 
- 어원은 람다 캘큘러스에서 나옴
- 보통 lambda function, Anonymous function 이라고 부름

**함수 포인터로써의 람다 함수**

```cpp
auto func = [](const int& i) -> void {cout << "Hello, World!\n"; };  // 람다 함수
```

**익명 함수로써의 람다 함수**

```cpp
[]() -> void { cout << "Hello, World!\n"; }();
```

- 구현할게 잡다하고 많아질때 사용하면 좋음
- GUI 관련 프로그래밍시 많이 사용함


- `[]` lammda-introducer 
  - `[&]` 람다 펑션이 정의된 영역에 `&` 를 넣어놓면 밖에 있는것을 레퍼런스로 가져옴
    - `=` 카피
    - `this` 클래스 멤버 정의
    - `&변수` 

___

**std::for_each**

```cpp
#include <algorithm> // for_each

vector<int> vec;    
vec.push_back(10); 
vec.push_back(20);

auto func2 = [](int val) {cout << val << "  "; };
std::for_each(vec.begin(), vec.end(), func2); 
```

- 이렇게 사용하려고 사용하지 않고 아래 코드와 같이 바로넣어 버려 사용함

```cpp
std::for_each(vec.begin(), vec.end(), [](int val) {cout << val << "  "; });
```

**람다 함수 리턴타입 설정**

```cpp
cout << []() -> int {return 1;} << enld;
```

- int타입으로 설정

___

**std::function**

```cpp
auto func2 = [](int val) {cout << val << "  "; };	
std::function<void(int)> func3 = func2;	
func3(123);
```

- 일종의 함수 포인터를 체계화 시켜준것
  - void 리턴타입
  - int 파라메타 타입

- 함수의 기능을 변수처럼 주고받고함

**std::bind**

```cpp
auto func = [](int val) {cout << val << "  "; };

std::function<void(void)> func2 = std::bind(func, 456);	

func2();  // 456 출력
```

- 파라메타 타입을 자료형을 쓰고싶지않을때 int를 bind하여 넣는 것
- void 타입인 func2에 int타입인 func 함수를 넣어줘서 bind하여서 넣을수 있음

___

**std::placeholders**

```cpp
#include <functional>
#include <iostream>
 
using namespace std;
 
int multiply(int a, int b)
{
    return a * b;
}
 
int main()
{
    auto func = std::bind(multiply, 5, placeholders::_1);
 
    for (int i = 0; i < 10; i++)
    {
        cout << "5 * " << i << " = " << func(i) << endl;
    }
    return 0;
}
```

- 파라메타가 여러개일경우 넣어주는것

### **🌱 19.2 C++ 17 함수에서 여러 개의 리턴값 변환 하기**

**옛날 tuple**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

tuple<int, int> my_func()
{ 
	return tuple<int, int>(123, 456); 
}

int main()
{
	tuple<int, int> result = my_func();
	cout << get<0>(result) << " " << get<1>(result) << endl;
}
```

- 리턴데이터 타입을 구조체나 클래스를 사용해서 만들수도 있음
  - 매번 만들기 귀찮음
- tuple
  - 수학적의미: 여러개의 데이터의 쌍

___

**현대적 C++ tuple 사용법**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto my_func()
{ 
  return tuple<int, int, int>(123, 456, 789); // 옛날 방식
	return tuple(123, 456, 789); // C++ 17 부터 사용가능
}

int main()
{
	auto [a, b, c] = func();
	cout << a << " " << b << " " << c << "\n";
}
```

### **🌱 19.3 std thread와 멀티쓰레딩 기초**

**Process**

- os가 우리가 작성한 프로그램을 실행시킬때 관리하는 단위
- 하나의 프로세스가 여러개의 thread를 관리함


**multithreading**

- 하나의 프로그램을 만들고 그프로그램이 여러개의 thread를 만들어서 여러개의 코어를 동시에 활용해 효율성을 높이는 방법
- 하나의 cpu에 여러개의 코어가 들어있는경우 그코어들을 활용해서 동시에 여러개의 작업을 수행하는 것
- 예전엔 cpu하나에 코어 하나가 들어있던시절에는 한보드에 여러개의 cpu를 넣어서 multithreading을 했었음 보통 2개정도 꽂으면 메모리 속도의 한계때문에 효율이좋지않았음
- **분산처리:** multithreading시 효율을 높이기위해 네트워크로 여러개의 pc를 연결시키고 여러개의 pc에 들어있는 코어들을 전부 동시에 활용하는 것
  - pc가 전부 흩어져 있어 메모리를 공유할수 없음
  - 통신할때 여러가지 부가적인 오버헤드가 생기기도 함
- multithreading은 여러개의 thread들이 메모리를 공유함
  - 위험하기도함
- multicore cpu에서 자동으로 multithreading으로 효율을 높여주는것이 아니고 multithreading을 하도록 프로그래밍을 직접해야함
- thread가 실타래라는 의미를 갖고있어 실선이외에 쭈글쭈글한 선으로 표현하는 경우도 있음

<br>


**Process 수행 순서**

1. 메인 함수로 프로그램이 실행됨 그 메인함수를 실행하고있는 thread를 메인 thread,주된 thread 라고 부름
2. 무거운 작업을 시작할때 여러개의 thread들이 일을 나눠서 작업해야할때 multithreading으로 프로그래밍을 해두고 main thread가 여러개의 thread를 실행을 시킴
  - 부가적인 thread를 실행시킬때 순차적으로 시키지만 동시에 시킨다고 하기도함
  - 자식 thread 에서 또다른 자식 thread 를 실행시킬수도 있음
3. 자식 thread 는 main thread가 어떤 작업을 하던지 간에 별도의 프로그램인것 처럼 작동을 함 
4. 자식 thread가 작업을 마칠때 main thread가 기다리고있음
   - 자식 thread가 작업이 끝나는 시점을 main thread는 알지 못함 
5. 작업이 끝나면 프로그램이 끝남

___

![캡처](https://user-images.githubusercontent.com/90514882/167283762-8b9fbad2-4859-4baf-bbfe-7e3a2c30c26d.PNG)


- **코어:** 물리적 코어의 갯수
- **논리 프로세서:** hyper threading 이라는 기술로 물리적코어의 2배에 해당하는 프로세서를 가지고있는것 처럼 사용할수 있게해줌
- **이용률:** 현재 cpu가 사용되고 있는 비율
  - 논리 프로세서를 모두 고려한 컴퓨팅 능력을 보여주는것
- **프로세서:** 메인 함수를 실행시켜주는 os가 배정해주는 일을하는 존재
- **스레드:** 프로세스 하나가 여러개의 스레드를 사용해서 일을 함

<br>

- main 함수를 실행시키면 프로세스 하나가 실행이된다
- 프로세스 하나가 차지하는 것은 기본적으로 cpu의 논리 프로세서 하나를 사용함

___

**thread**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	cout << std::thread::hardware_concurrency() << endl; // 논리 프로세서 갯수
	cout << std::this_thread::get_id() << endl; // thread id

  // multi thread
	std::thread t1 = std::thread([] {
	cout << std::this_thread::get_id() << '\n';
	//while (true);
	});
	t1.join();		// t1이 끝날 때까지 기다린다.
}
```

- `hardware_concurrency()` 코어갯수 를 받아올수 있음
- `std::this_thread::get_id()` 메인함수가 실행되고있는 thread this_thread의 id를 출력해줌
- 메인함수가 메인스레드를 실행하고 `std::thread t1 = std::thread([] {cout << std::this_thread::get_id() << '\n';});` 안에서 자식스레드를 실행함 자식스레드가 끝난뒤에 메인 스레드와 통신해야하는데 통신하기 전에 메인 함수가 끝나버려 에러가 발생함 
  - 이를 방지하기위해 `t1.join()` 를 사용할수 있음

___

**여러개의 thread 사용하기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	std::thread t1 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t2 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t3 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t4 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	t1.join();
	//t2.join();
	//t3.join();
	//t4.join();
}
```

**출력결과**

```cpp
463276042468
```
- t1, t2, t3, t4 스레드가 각각 병렬로 동시에 실행되기 때문에(멀티스레딩) id가 중구난방으로 섞여 출력됨
- cout이 감당을 못해서 꼬인것

___

**vector에 thread 넣기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	const int num_pro = std::thread::hardware_concurrency();

	vector<std::thread> my_threads;
	my_threads.resize(num_pro);

  for (auto & e : my_threads)
  {
      e = std::thread([](){
				cout << std::this_thread::get_id() << endl;
				while(true){}
          });
  }
		
	for (auto & e : my_threads)
		e.join();
}
```

**출력결과**

```cpp
2438421972
9364
17412
20952
13428

9864
16900
20628
15592
4840
2584
4516
13492
20320
22612




```

- 위 예제코드를 실행시키면 cpu사용률 100퍼를 사용하게됨
  - 중간중간 글자가 깨짐
- multi thread 를 공부하게되면 num_thread와 실제 생성하는 thread 갯수를 신경써야함
- 일반적으로 생성하는 thread 갯수와 하드웨어 프로세서 갯수를 맞추는것이 일반적임 
- 모든문제를 병렬로 다 사용할순없지만 일반적으로 멀티스레딩은 유용함
  
___

```cpp
#include <iostream>
#include <thread>
#include <mutex>		// semaphore는 없음
using namespace std;

int main()
{
	auto work_func = [](const string & name)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	work_func("JackJack");
	work_func("Dash");
}
```

**출력결과**

```cpp
JackJack 5172 is working 0
JackJack 5172 is working 1
JackJack 5172 is working 2
JackJack 5172 is working 3
JackJack 5172 is working 4
Dash 5172 is working 0
Dash 5172 is working 1
Dash 5172 is working 2
Dash 5172 is working 3
Dash 5172 is working 4

```

- `std::this_thread::sleep_for(std::chrono::milliseconds(100));` 쉬는 시간 넣기
  - 실제로는 할 작업을 넣는 부분
- `work_func("JackJack");` 이 실행되는 동안 `work_func("Dash");` 는 놀고있는 형태임
  - multi threading이 아니며 비효율적임

**multi threading으로 바꾸기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	auto work_func = [](const string& name, const int j)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			cout << name << " " << j << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack", 123);
	std::thread t2 = std::thread(work_func, "Dash", 456);

	t1.join();
	t2.join();
}
```

**출력결과**

```cpp
JackJack Dash 456 23564 is working 0123 16988 is working 0

JackJack 123 16988 is working 1
Dash 456 23564 is working 1
JackJack 123 16988 is working 2
Dash 456 23564 is working 2
Dash 456 23564 is working 3
JackJack 123 16988 is working 3
JackJack 123 16988 is working 4
Dash 456 23564 is working 4

```

- 멀티쓰레딩을 사용하는 이유는 동시에 일을하기 위해 사용함
- 작업은 동시에하는데 출력도 동시에나와서 지저분함

**mutex**

```cpp
#include <iostream>
#include <thread>
#include <mutex> 

using namespace std;

mutex mtx; // 선언

int main()
{	

	auto work_func = [](const string& name)
	{

		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			mtx.lock();
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
			mtx.unlock();
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack");
	std::thread t2 = std::thread(work_func, "Dash");

	t1.join();
	t2.join();
}
```

**출력 결과**

```cpp
JackJack 4272 is working 0
Dash 12944 is working 0
Dash 12944 is working 1
JackJack 4272 is working 1
JackJack 4272 is working 2
Dash 12944 is working 2
Dash 12944 is working 3
JackJack 4272 is working 3
JackJack 4272 is working 4
Dash 12944 is working 4

```

- 작업은 동시에하는데 출력도 출력을 순차적으로 해줄수있음
- mutex 는 **mutual exclusion** 를 뜻함 
  - 상호배재 라는뜻
- 여러개의 스레드를 이부분은 건들이지말고 한번에 하나의스레드를 실행시키라는 뜻
- 두 스레드중 작업을 먼저 마친 스레드가 mtx.lock 에 와서 잠궈버림 다른 스레드는 못들어오게됨 그 후 출력 후 lock을 풀고 다른 스레드가 대기를 하고있다가 들어오고 반복하는 과정임
- `mtx.lock();` 을하고 `mtx.unlock();` 을 안해버리면 문제가 발생함
- 멀티스레드는 서로 중복되는 부분에서 문제를 어떻게 해결하느냐가 중요함


### **🌱 19.4 레이스 컨디션, std::atomic, std::scoped_lock**

- Race Condition: 동일한 데이터를 서로 다른 여러 스레드들이 접근하는 과정에서 생기는 문제

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	int shared_memory(0);

	auto count_func = [&](){
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();
	
	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**출력 결과**

```cpp
After
1996

```

- 실전에서는 여러개의 스레드가 함께 사용하는 메모리가 int 정수형 하나뿐 아니라 훨씬더 커질수있음
- `sleep_for` 가없으면 일을 단번에 처리해서 문제가 발생하지않을수도 있음
- 2000 이 출력되야하는데 엉뚱한 값이 나오는 이유
  - 둘다 1000번씩 더하긴함
  1. cpu로 shared_memory 데이터를 가져옴
  2. cpu로 shared_memory 데이터에 1을 더함
  3. 1을 더한 shared_memory값을 다시 shared_memory변수로 보내 덮어씌움
  - cpu로 읽어들인 사이에 스레드 2가 재빨리 값을바꿔버린것

<br>

- `std::this_thread::sleep_for(std::chrono::microseconds(1));` 이것을 지워버리면 2000이 깔끔하게 출력됨
  - 문제가 사라진것이 아님 1000번 더하는게 순식간에 일어나 t1이 끝난뒤에 t2가 실행이되어 깔끔하게 출력이된것 즉, 병렬처리가 된것이 아님
___

**레이스 컨디션 해결 방법 1 atomic**

```cpp
#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	atomic<int> shared_memory(0);
	
	auto count_func = [&]()
	{
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;		// 혹은 shared_memory.fetch_add(1);	
		}
	};

	std::thread t1 = std::thread(count_func);
	std::thread t2 = std::thread(count_func);

	t1.join();
	t2.join();

    cout << "After" << endl;
	cout << shared_memory << '\n';
}
```

**출력 결과**

```cpp
After
2000

```

- atomic: 원자, 쪼갤수없다 라는뜻
  - 스레드 계산 처리방법 3단계를 한방에 하게끔 바꾼것
- `shared_memory++;` 의 `++` 는 증감연산자가 아닌 atomic<int> 의 증감연산자를 오버로딩이 되어있는것 
- 단점으로는 `fetch_add()`, `++` 그냥 증감연산자 등보다 조금 느림
  - 필요한 곳에만 사용해야함

___

**레이스 컨디션 해결 방법 2 mutex**

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

mutex mtx;

int main()
{
	int shared_memory(0);

	auto count_func = [&]() {
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));

			/*mtx.lock();*/
			std::lock_guard lock(mtx);
			std::scoped_lock lock(mtx); // C ++ 17
			shared_memory++;
			/*mtx.unlock();*/
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();

	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**출력 결과**

```cpp
After
2000

```

- mutex를 사용하여 `lock()` 을 걸면 하나의 스레드만 접근하는것이 되어 레이스 컨디션을 방지할수 있음
- unlock을 까먹을수도있고 예외처리시 unlock를 건너뛰는 등 실수를 할 가능성이 있음
  - 이때 사용하는것이 lcokguard가 있음
  - `std::lock_guard lock(mtx);` 
    - lock 이라는 변수가 `{}` 안에 선언이 되어 `{}`이 끝날때 종료되기 때문에 unlock을 해줄필요가 없음
- `std::scoped_lock lock(mtx);`
  - C++ 17에 도입된 기능 lock_guard 보다 진보된 기능 이것을 사용하는것을 더 권장하는 편이라고 함

### **🌱 19.5 작업 기반 비동기 프로그래밍**

- 작업 Task
- 비동기 async
- future, promise

___

- `#include <future>`
  - async,Future,Promise 등을 사용할수있음

**multi-threading**

```cpp
{
	int result;
	std::thread t([&] {result = 1 + 2; });  // 모든 바깥 변수를 레퍼런스로 받으므로 result 값이 변화한다.
	t.join();

	cout << result << '\n';  
}
```

- 최근에는 스레드만 접근하는 변수를 선언하는 방식을 선호하기도함
- 기본적으로 스레드로부터 값을 주거니 받거리 하기위해선 스코프를 넓게 잡고 그 스코프 변수를 여러 스레드들이 공유를 하는것이 일반적임
- 스레드 위주로 프로그래밍이 된것
- 스레드가 몇개 생기고 그 스레드가 각각 어느일을 하는지 지정해주는것

___

**task-based parallellism**

<br>

**async**

```cpp
{
std::future<int> future = std::async([] {return (1 + 2);});  //  auto future 쓰는게 더 간편
cout << future.get() << '\n';  // 3 출력
}
```

- **async:** Asynchronous 비동기적이다 라는뜻
- return 값을 future이 받는것 처럼 프로그래밍 한것
- async 는 스레드를 관리하는 방법이 여러개있음
  - 보통 thread보다 async를 더 선호함
  - multi-threading 보다 task-based parallellism 를 더 선호함
- 어떤 작업을 할것인가 위주 프로그래밍 return 을 해주는 값을 현재 받을수 있는 것이 아님
  - 일반적인 return과 다름 작업시간 이 오래 걸려 나중에 받을수도있음 
- async가 실행되는 task와 정확히 결합이 되는 구조임
- `future.get()` 
  - 리턴값이 int가 날라옴
  - return값이 get() 값으로 나오는것
  - 리턴값을 받기 전이라면 async가 작업을 마치고 값을 return 해줄때 까지 기다림


**promsise**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	// future and promsise
	{	
		std::promise<int> prom;
		auto future = prom.get_future();

		auto t = std::thread([](std::promise<int>&& prom)
		{
            prom.set_value(1 + 2);
        }, std::move(prom));
		
		cout << future.get() << endl;
		t.join();
	}
}
```

- future 를 aysunc 이외에 thread에서도 사용할수 있음
- promsise는 async 처럼 future 를 주지않고 자기 thread를 줌 future를 받을수 있는 존재가 필요해 promise를 거쳐가는것
- prom에 set_value() 를 통해서 값을 받을때까지 future가 계속 기다림
- thread 이기 때문에 `t.join();` 이필요함

___

**async 동시실행**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	auto f1 = std::async([] {
		cout << "Async 1 start\n";
		this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
		cout << "Async 1 end\n";
		});
	auto f2 = std::async([] {
		cout << "Async 2 start\n";
		this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
		cout << "Async 2 end\n";
		});

	cout << "Main function\n";  // 메인 스레드가 실행

}
```

**출력 결과**

```cpp
Main function
Async 1 start
Async 2 start
Async 2 end
Async 1 end

```

- async는 thread와 달리 join이 없음.

**thread 로 바꾸기**

```cpp
{
auto f1 = std::thread([] {
	cout << "Async 1 start\n";
	this_thread::sleep_for(std::chrono::seconds(2)); // 2초 대기
	cout << "Async 1 end\n";
});
auto f2 = std::thread([] {
	cout << "Async 2 start\n";
	this_thread::sleep_for(std::chrono::seconds(1)); // 1초 대기
	cout << "Async 2 end\n";
});

cout << "Main function\n";  // 메인 스레드가 실행

f1.join();
f2.join();

}
```

**출력 결과**

```cpp
Main function
Async 2 start
Async 1 start
Async 2 end
Async 1 end

```

### **🌱 **

### **🌱 **

### **🌱 **

# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**공부하는 식빵맘 👱‍♀️ 님의 블로그** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)