---
published: true
title:  "ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤"
excerpt: ""

categories:
  - ë”°ë°°ì”¨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-08
last_modified_at: 2022-05-08 
---

# ğŸ¤” í•™ìŠµëª©í‘œ
- ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤

# ğŸ“ƒ í•™ìŠµë‚´ìš©
## ğŸ“ **ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤**

### **ğŸŒ± 19.1 ëŒë‹¤ í•¨ìˆ˜ì™€ std::function std::bind, for_each**

**ëŒë‹¤ í•¨ìˆ˜**

- ìµëª…í•¨ìˆ˜ë¼ê³  ë¶ˆë¦¼ 
- ì–´ì›ì€ ëŒë‹¤ ìº˜í˜ëŸ¬ìŠ¤ì—ì„œ ë‚˜ì˜´
- ë³´í†µ lambda function, Anonymous function ì´ë¼ê³  ë¶€ë¦„

**í•¨ìˆ˜ í¬ì¸í„°ë¡œì¨ì˜ ëŒë‹¤ í•¨ìˆ˜**

```cpp
auto func = [](const int& i) -> void {cout << "Hello, World!\n"; };  // ëŒë‹¤ í•¨ìˆ˜
```

**ìµëª… í•¨ìˆ˜ë¡œì¨ì˜ ëŒë‹¤ í•¨ìˆ˜**

```cpp
[]() -> void { cout << "Hello, World!\n"; }();
```

- êµ¬í˜„í• ê²Œ ì¡ë‹¤í•˜ê³  ë§ì•„ì§ˆë•Œ ì‚¬ìš©í•˜ë©´ ì¢‹ìŒ
- GUI ê´€ë ¨ í”„ë¡œê·¸ë˜ë°ì‹œ ë§ì´ ì‚¬ìš©í•¨


- `[]` lammda-introducer 
  - `[&]` ëŒë‹¤ í‘ì…˜ì´ ì •ì˜ëœ ì˜ì—­ì— `&` ë¥¼ ë„£ì–´ë†“ë©´ ë°–ì— ìˆëŠ”ê²ƒì„ ë ˆí¼ëŸ°ìŠ¤ë¡œ ê°€ì ¸ì˜´
    - `=` ì¹´í”¼
    - `this` í´ë˜ìŠ¤ ë©¤ë²„ ì •ì˜
    - `&ë³€ìˆ˜` 

___

**std::for_each**

```cpp
#include <algorithm> // for_each

vector<int> vec;    
vec.push_back(10); 
vec.push_back(20);

auto func2 = [](int val) {cout << val << "  "; };
std::for_each(vec.begin(), vec.end(), func2); 
```

- ì´ë ‡ê²Œ ì‚¬ìš©í•˜ë ¤ê³  ì‚¬ìš©í•˜ì§€ ì•Šê³  ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ë°”ë¡œë„£ì–´ ë²„ë ¤ ì‚¬ìš©í•¨

```cpp
std::for_each(vec.begin(), vec.end(), [](int val) {cout << val << "  "; });
```

**ëŒë‹¤ í•¨ìˆ˜ ë¦¬í„´íƒ€ì… ì„¤ì •**

```cpp
cout << []() -> int {return 1;} << enld;
```

- intíƒ€ì…ìœ¼ë¡œ ì„¤ì •

___

**std::function**

```cpp
auto func2 = [](int val) {cout << val << "  "; };	
std::function<void(int)> func3 = func2;	
func3(123);
```

- ì¼ì¢…ì˜ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì²´ê³„í™” ì‹œì¼œì¤€ê²ƒ
  - void ë¦¬í„´íƒ€ì…
  - int íŒŒë¼ë©”íƒ€ íƒ€ì…

- í•¨ìˆ˜ì˜ ê¸°ëŠ¥ì„ ë³€ìˆ˜ì²˜ëŸ¼ ì£¼ê³ ë°›ê³ í•¨

**std::bind**

```cpp
auto func = [](int val) {cout << val << "  "; };

std::function<void(void)> func2 = std::bind(func, 456);	

func2();  // 456 ì¶œë ¥
```

- íŒŒë¼ë©”íƒ€ íƒ€ì…ì„ ìë£Œí˜•ì„ ì“°ê³ ì‹¶ì§€ì•Šì„ë•Œ intë¥¼ bindí•˜ì—¬ ë„£ëŠ” ê²ƒ
- void íƒ€ì…ì¸ func2ì— intíƒ€ì…ì¸ func í•¨ìˆ˜ë¥¼ ë„£ì–´ì¤˜ì„œ bindí•˜ì—¬ì„œ ë„£ì„ìˆ˜ ìˆìŒ

___

**std::placeholders**

```cpp
#include <functional>
#include <iostream>
 
using namespace std;
 
int multiply(int a, int b)
{
    return a * b;
}
 
int main()
{
    auto func = std::bind(multiply, 5, placeholders::_1);
 
    for (int i = 0; i < 10; i++)
    {
        cout << "5 * " << i << " = " << func(i) << endl;
    }
    return 0;
}
```

- íŒŒë¼ë©”íƒ€ê°€ ì—¬ëŸ¬ê°œì¼ê²½ìš° ë„£ì–´ì£¼ëŠ”ê²ƒ

### **ğŸŒ± 19.2 C++ 17 í•¨ìˆ˜ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ë¦¬í„´ê°’ ë³€í™˜ í•˜ê¸°**

**ì˜›ë‚  tuple**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

tuple<int, int> my_func()
{ 
	return tuple<int, int>(123, 456); 
}

int main()
{
	tuple<int, int> result = my_func();
	cout << get<0>(result) << " " << get<1>(result) << endl;
}
```

- ë¦¬í„´ë°ì´í„° íƒ€ì…ì„ êµ¬ì¡°ì²´ë‚˜ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ìˆ˜ë„ ìˆìŒ
  - ë§¤ë²ˆ ë§Œë“¤ê¸° ê·€ì°®ìŒ
- tuple
  - ìˆ˜í•™ì ì˜ë¯¸: ì—¬ëŸ¬ê°œì˜ ë°ì´í„°ì˜ ìŒ

___

**í˜„ëŒ€ì  C++ tuple ì‚¬ìš©ë²•**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto my_func()
{ 
  return tuple<int, int, int>(123, 456, 789); // ì˜›ë‚  ë°©ì‹
	return tuple(123, 456, 789); // C++ 17 ë¶€í„° ì‚¬ìš©ê°€ëŠ¥
}

int main()
{
	auto [a, b, c] = func();
	cout << a << " " << b << " " << c << "\n";
}
```

### **ğŸŒ± 19.3 std threadì™€ ë©€í‹°ì“°ë ˆë”© ê¸°ì´ˆ**

**Process**

- osê°€ ìš°ë¦¬ê°€ ì‘ì„±í•œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰ì‹œí‚¬ë•Œ ê´€ë¦¬í•˜ëŠ” ë‹¨ìœ„
- í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ê´€ë¦¬í•¨


**multithreading**

- í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ê³  ê·¸í”„ë¡œê·¸ë¨ì´ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ë§Œë“¤ì–´ì„œ ì—¬ëŸ¬ê°œì˜ ì½”ì–´ë¥¼ ë™ì‹œì— í™œìš©í•´ íš¨ìœ¨ì„±ì„ ë†’ì´ëŠ” ë°©ë²•
- í•˜ë‚˜ì˜ cpuì— ì—¬ëŸ¬ê°œì˜ ì½”ì–´ê°€ ë“¤ì–´ìˆëŠ”ê²½ìš° ê·¸ì½”ì–´ë“¤ì„ í™œìš©í•´ì„œ ë™ì‹œì— ì—¬ëŸ¬ê°œì˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒ
- ì˜ˆì „ì—” cpuí•˜ë‚˜ì— ì½”ì–´ í•˜ë‚˜ê°€ ë“¤ì–´ìˆë˜ì‹œì ˆì—ëŠ” í•œë³´ë“œì— ì—¬ëŸ¬ê°œì˜ cpuë¥¼ ë„£ì–´ì„œ multithreadingì„ í–ˆì—ˆìŒ ë³´í†µ 2ê°œì •ë„ ê½‚ìœ¼ë©´ ë©”ëª¨ë¦¬ ì†ë„ì˜ í•œê³„ë•Œë¬¸ì— íš¨ìœ¨ì´ì¢‹ì§€ì•Šì•˜ìŒ
- **ë¶„ì‚°ì²˜ë¦¬:** multithreadingì‹œ íš¨ìœ¨ì„ ë†’ì´ê¸°ìœ„í•´ ë„¤íŠ¸ì›Œí¬ë¡œ ì—¬ëŸ¬ê°œì˜ pcë¥¼ ì—°ê²°ì‹œí‚¤ê³  ì—¬ëŸ¬ê°œì˜ pcì— ë“¤ì–´ìˆëŠ” ì½”ì–´ë“¤ì„ ì „ë¶€ ë™ì‹œì— í™œìš©í•˜ëŠ” ê²ƒ
  - pcê°€ ì „ë¶€ í©ì–´ì ¸ ìˆì–´ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í• ìˆ˜ ì—†ìŒ
  - í†µì‹ í• ë•Œ ì—¬ëŸ¬ê°€ì§€ ë¶€ê°€ì ì¸ ì˜¤ë²„í—¤ë“œê°€ ìƒê¸°ê¸°ë„ í•¨
- multithreadingì€ ì—¬ëŸ¬ê°œì˜ threadë“¤ì´ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•¨
  - ìœ„í—˜í•˜ê¸°ë„í•¨
- multicore cpuì—ì„œ ìë™ìœ¼ë¡œ multithreadingìœ¼ë¡œ íš¨ìœ¨ì„ ë†’ì—¬ì£¼ëŠ”ê²ƒì´ ì•„ë‹ˆê³  multithreadingì„ í•˜ë„ë¡ í”„ë¡œê·¸ë˜ë°ì„ ì§ì ‘í•´ì•¼í•¨
- threadê°€ ì‹¤íƒ€ë˜ë¼ëŠ” ì˜ë¯¸ë¥¼ ê°–ê³ ìˆì–´ ì‹¤ì„ ì´ì™¸ì— ì­ˆê¸€ì­ˆê¸€í•œ ì„ ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²½ìš°ë„ ìˆìŒ

<br>


**Process ìˆ˜í–‰ ìˆœì„œ**

1. ë©”ì¸ í•¨ìˆ˜ë¡œ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë¨ ê·¸ ë©”ì¸í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³ ìˆëŠ” threadë¥¼ ë©”ì¸ thread,ì£¼ëœ thread ë¼ê³  ë¶€ë¦„
2. ë¬´ê±°ìš´ ì‘ì—…ì„ ì‹œì‘í• ë•Œ ì—¬ëŸ¬ê°œì˜ threadë“¤ì´ ì¼ì„ ë‚˜ëˆ ì„œ ì‘ì—…í•´ì•¼í• ë•Œ multithreadingìœ¼ë¡œ í”„ë¡œê·¸ë˜ë°ì„ í•´ë‘ê³  main threadê°€ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ì‹¤í–‰ì„ ì‹œí‚´
  - ë¶€ê°€ì ì¸ threadë¥¼ ì‹¤í–‰ì‹œí‚¬ë•Œ ìˆœì°¨ì ìœ¼ë¡œ ì‹œí‚¤ì§€ë§Œ ë™ì‹œì— ì‹œí‚¨ë‹¤ê³  í•˜ê¸°ë„í•¨
  - ìì‹ thread ì—ì„œ ë˜ë‹¤ë¥¸ ìì‹ thread ë¥¼ ì‹¤í–‰ì‹œí‚¬ìˆ˜ë„ ìˆìŒ
3. ìì‹ thread ëŠ” main threadê°€ ì–´ë–¤ ì‘ì—…ì„ í•˜ë˜ì§€ ê°„ì— ë³„ë„ì˜ í”„ë¡œê·¸ë¨ì¸ê²ƒ ì²˜ëŸ¼ ì‘ë™ì„ í•¨ 
4. ìì‹ threadê°€ ì‘ì—…ì„ ë§ˆì¹ ë•Œ main threadê°€ ê¸°ë‹¤ë¦¬ê³ ìˆìŒ
   - ìì‹ threadê°€ ì‘ì—…ì´ ëë‚˜ëŠ” ì‹œì ì„ main threadëŠ” ì•Œì§€ ëª»í•¨ 
5. ì‘ì—…ì´ ëë‚˜ë©´ í”„ë¡œê·¸ë¨ì´ ëë‚¨

___

![ìº¡ì²˜](https://user-images.githubusercontent.com/90514882/167283762-8b9fbad2-4859-4baf-bbfe-7e3a2c30c26d.PNG)


- **ì½”ì–´:** ë¬¼ë¦¬ì  ì½”ì–´ì˜ ê°¯ìˆ˜
- **ë…¼ë¦¬ í”„ë¡œì„¸ì„œ:** hyper threading ì´ë¼ëŠ” ê¸°ìˆ ë¡œ ë¬¼ë¦¬ì ì½”ì–´ì˜ 2ë°°ì— í•´ë‹¹í•˜ëŠ” í”„ë¡œì„¸ì„œë¥¼ ê°€ì§€ê³ ìˆëŠ”ê²ƒ ì²˜ëŸ¼ ì‚¬ìš©í• ìˆ˜ ìˆê²Œí•´ì¤Œ
- **ì´ìš©ë¥ :** í˜„ì¬ cpuê°€ ì‚¬ìš©ë˜ê³  ìˆëŠ” ë¹„ìœ¨
  - ë…¼ë¦¬ í”„ë¡œì„¸ì„œë¥¼ ëª¨ë‘ ê³ ë ¤í•œ ì»´í“¨íŒ… ëŠ¥ë ¥ì„ ë³´ì—¬ì£¼ëŠ”ê²ƒ
- **í”„ë¡œì„¸ì„œ:** ë©”ì¸ í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œì¼œì£¼ëŠ” osê°€ ë°°ì •í•´ì£¼ëŠ” ì¼ì„í•˜ëŠ” ì¡´ì¬
- **ìŠ¤ë ˆë“œ:** í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•´ì„œ ì¼ì„ í•¨

<br>

- main í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì‹¤í–‰ì´ëœë‹¤
- í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì°¨ì§€í•˜ëŠ” ê²ƒì€ ê¸°ë³¸ì ìœ¼ë¡œ cpuì˜ ë…¼ë¦¬ í”„ë¡œì„¸ì„œ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•¨

___

**thread**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	cout << std::thread::hardware_concurrency() << endl; // ë…¼ë¦¬ í”„ë¡œì„¸ì„œ ê°¯ìˆ˜
	cout << std::this_thread::get_id() << endl; // thread id

  // multi thread
	std::thread t1 = std::thread([] {
	cout << std::this_thread::get_id() << '\n';
	//while (true);
	});
	t1.join();		// t1ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤.
}
```

- `hardware_concurrency()` ì½”ì–´ê°¯ìˆ˜ ë¥¼ ë°›ì•„ì˜¬ìˆ˜ ìˆìŒ
- `std::this_thread::get_id()` ë©”ì¸í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ê³ ìˆëŠ” thread this_threadì˜ idë¥¼ ì¶œë ¥í•´ì¤Œ
- ë©”ì¸í•¨ìˆ˜ê°€ ë©”ì¸ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•˜ê³  `std::thread t1 = std::thread([] {cout << std::this_thread::get_id() << '\n';});` ì•ˆì—ì„œ ìì‹ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•¨ ìì‹ìŠ¤ë ˆë“œê°€ ëë‚œë’¤ì— ë©”ì¸ ìŠ¤ë ˆë“œì™€ í†µì‹ í•´ì•¼í•˜ëŠ”ë° í†µì‹ í•˜ê¸° ì „ì— ë©”ì¸ í•¨ìˆ˜ê°€ ëë‚˜ë²„ë ¤ ì—ëŸ¬ê°€ ë°œìƒí•¨ 
  - ì´ë¥¼ ë°©ì§€í•˜ê¸°ìœ„í•´ `t1.join()` ë¥¼ ì‚¬ìš©í• ìˆ˜ ìˆìŒ

___

**ì—¬ëŸ¬ê°œì˜ thread ì‚¬ìš©í•˜ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	std::thread t1 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t2 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t3 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t4 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	t1.join();
	//t2.join();
	//t3.join();
	//t4.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
463276042468
```
- t1, t2, t3, t4 ìŠ¤ë ˆë“œê°€ ê°ê° ë³‘ë ¬ë¡œ ë™ì‹œì— ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—(ë©€í‹°ìŠ¤ë ˆë”©) idê°€ ì¤‘êµ¬ë‚œë°©ìœ¼ë¡œ ì„ì—¬ ì¶œë ¥ë¨
- coutì´ ê°ë‹¹ì„ ëª»í•´ì„œ ê¼¬ì¸ê²ƒ

___

**vectorì— thread ë„£ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	const int num_pro = std::thread::hardware_concurrency();

	vector<std::thread> my_threads;
	my_threads.resize(num_pro);

  for (auto & e : my_threads)
  {
      e = std::thread([](){
				cout << std::this_thread::get_id() << endl;
				while(true){}
          });
  }
		
	for (auto & e : my_threads)
		e.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
2438421972
9364
17412
20952
13428

9864
16900
20628
15592
4840
2584
4516
13492
20320
22612




```

- ìœ„ ì˜ˆì œì½”ë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ cpuì‚¬ìš©ë¥  100í¼ë¥¼ ì‚¬ìš©í•˜ê²Œë¨
  - ì¤‘ê°„ì¤‘ê°„ ê¸€ìê°€ ê¹¨ì§
- multi thread ë¥¼ ê³µë¶€í•˜ê²Œë˜ë©´ num_threadì™€ ì‹¤ì œ ìƒì„±í•˜ëŠ” thread ê°¯ìˆ˜ë¥¼ ì‹ ê²½ì¨ì•¼í•¨
- ì¼ë°˜ì ìœ¼ë¡œ ìƒì„±í•˜ëŠ” thread ê°¯ìˆ˜ì™€ í•˜ë“œì›¨ì–´ í”„ë¡œì„¸ì„œ ê°¯ìˆ˜ë¥¼ ë§ì¶”ëŠ”ê²ƒì´ ì¼ë°˜ì ì„ 
- ëª¨ë“ ë¬¸ì œë¥¼ ë³‘ë ¬ë¡œ ë‹¤ ì‚¬ìš©í• ìˆœì—†ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë©€í‹°ìŠ¤ë ˆë”©ì€ ìœ ìš©í•¨
  
___

```cpp
#include <iostream>
#include <thread>
#include <mutex>		// semaphoreëŠ” ì—†ìŒ
using namespace std;

int main()
{
	auto work_func = [](const string & name)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	work_func("JackJack");
	work_func("Dash");
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
JackJack 5172 is working 0
JackJack 5172 is working 1
JackJack 5172 is working 2
JackJack 5172 is working 3
JackJack 5172 is working 4
Dash 5172 is working 0
Dash 5172 is working 1
Dash 5172 is working 2
Dash 5172 is working 3
Dash 5172 is working 4

```

- `std::this_thread::sleep_for(std::chrono::milliseconds(100));` ì‰¬ëŠ” ì‹œê°„ ë„£ê¸°
  - ì‹¤ì œë¡œëŠ” í•  ì‘ì—…ì„ ë„£ëŠ” ë¶€ë¶„
- `work_func("JackJack");` ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ `work_func("Dash");` ëŠ” ë†€ê³ ìˆëŠ” í˜•íƒœì„
  - multi threadingì´ ì•„ë‹ˆë©° ë¹„íš¨ìœ¨ì ì„

**multi threadingìœ¼ë¡œ ë°”ê¾¸ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	auto work_func = [](const string& name, const int j)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			cout << name << " " << j << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack", 123);
	std::thread t2 = std::thread(work_func, "Dash", 456);

	t1.join();
	t2.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
JackJack Dash 456 23564 is working 0123 16988 is working 0

JackJack 123 16988 is working 1
Dash 456 23564 is working 1
JackJack 123 16988 is working 2
Dash 456 23564 is working 2
Dash 456 23564 is working 3
JackJack 123 16988 is working 3
JackJack 123 16988 is working 4
Dash 456 23564 is working 4

```

- ë©€í‹°ì“°ë ˆë”©ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ë™ì‹œì— ì¼ì„í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•¨
- ì‘ì—…ì€ ë™ì‹œì—í•˜ëŠ”ë° ì¶œë ¥ë„ ë™ì‹œì—ë‚˜ì™€ì„œ ì§€ì €ë¶„í•¨

**mutex**

```cpp
#include <iostream>
#include <thread>
#include <mutex> 

using namespace std;

mutex mtx; // ì„ ì–¸

int main()
{	

	auto work_func = [](const string& name)
	{

		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			mtx.lock();
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
			mtx.unlock();
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack");
	std::thread t2 = std::thread(work_func, "Dash");

	t1.join();
	t2.join();
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
JackJack 4272 is working 0
Dash 12944 is working 0
Dash 12944 is working 1
JackJack 4272 is working 1
JackJack 4272 is working 2
Dash 12944 is working 2
Dash 12944 is working 3
JackJack 4272 is working 3
JackJack 4272 is working 4
Dash 12944 is working 4

```

- ì‘ì—…ì€ ë™ì‹œì—í•˜ëŠ”ë° ì¶œë ¥ë„ ì¶œë ¥ì„ ìˆœì°¨ì ìœ¼ë¡œ í•´ì¤„ìˆ˜ìˆìŒ
- mutex ëŠ” **mutual exclusion** ë¥¼ ëœ»í•¨ 
  - ìƒí˜¸ë°°ì¬ ë¼ëŠ”ëœ»
- ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì´ë¶€ë¶„ì€ ê±´ë“¤ì´ì§€ë§ê³  í•œë²ˆì— í•˜ë‚˜ì˜ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë¼ëŠ” ëœ»
- ë‘ ìŠ¤ë ˆë“œì¤‘ ì‘ì—…ì„ ë¨¼ì € ë§ˆì¹œ ìŠ¤ë ˆë“œê°€ mtx.lock ì— ì™€ì„œ ì ê¶ˆë²„ë¦¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ëª»ë“¤ì–´ì˜¤ê²Œë¨ ê·¸ í›„ ì¶œë ¥ í›„ lockì„ í’€ê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°ë¥¼ í•˜ê³ ìˆë‹¤ê°€ ë“¤ì–´ì˜¤ê³  ë°˜ë³µí•˜ëŠ” ê³¼ì •ì„
- `mtx.lock();` ì„í•˜ê³  `mtx.unlock();` ì„ ì•ˆí•´ë²„ë¦¬ë©´ ë¬¸ì œê°€ ë°œìƒí•¨
- ë©€í‹°ìŠ¤ë ˆë“œëŠ” ì„œë¡œ ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ì—ì„œ ë¬¸ì œë¥¼ ì–´ë–»ê²Œ í•´ê²°í•˜ëŠëƒê°€ ì¤‘ìš”í•¨


### **ğŸŒ± 19.4 ë ˆì´ìŠ¤ ì»¨ë””ì…˜, std::atomic, std::scoped_lock**

- Race Condition: ë™ì¼í•œ ë°ì´í„°ë¥¼ ì„œë¡œ ë‹¤ë¥¸ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë“¤ì´ ì ‘ê·¼í•˜ëŠ” ê³¼ì •ì—ì„œ ìƒê¸°ëŠ” ë¬¸ì œ

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	int shared_memory(0);

	auto count_func = [&](){
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();
	
	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
After
1996

```

- ì‹¤ì „ì—ì„œëŠ” ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œê°€ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ê°€ int ì •ìˆ˜í˜• í•˜ë‚˜ë¿ ì•„ë‹ˆë¼ í›¨ì”¬ë” ì»¤ì§ˆìˆ˜ìˆìŒ
- `sleep_for` ê°€ì—†ìœ¼ë©´ ì¼ì„ ë‹¨ë²ˆì— ì²˜ë¦¬í•´ì„œ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ì•Šì„ìˆ˜ë„ ìˆìŒ
- 2000 ì´ ì¶œë ¥ë˜ì•¼í•˜ëŠ”ë° ì—‰ëš±í•œ ê°’ì´ ë‚˜ì˜¤ëŠ” ì´ìœ 
  - ë‘˜ë‹¤ 1000ë²ˆì”© ë”í•˜ê¸´í•¨
  1. cpuë¡œ shared_memory ë°ì´í„°ë¥¼ ê°€ì ¸ì˜´
  2. cpuë¡œ shared_memory ë°ì´í„°ì— 1ì„ ë”í•¨
  3. 1ì„ ë”í•œ shared_memoryê°’ì„ ë‹¤ì‹œ shared_memoryë³€ìˆ˜ë¡œ ë³´ë‚´ ë®ì–´ì”Œì›€
  - cpuë¡œ ì½ì–´ë“¤ì¸ ì‚¬ì´ì— ìŠ¤ë ˆë“œ 2ê°€ ì¬ë¹¨ë¦¬ ê°’ì„ë°”ê¿”ë²„ë¦°ê²ƒ

<br>

- `std::this_thread::sleep_for(std::chrono::microseconds(1));` ì´ê²ƒì„ ì§€ì›Œë²„ë¦¬ë©´ 2000ì´ ê¹”ë”í•˜ê²Œ ì¶œë ¥ë¨
  - ë¬¸ì œê°€ ì‚¬ë¼ì§„ê²ƒì´ ì•„ë‹˜ 1000ë²ˆ ë”í•˜ëŠ”ê²Œ ìˆœì‹ê°„ì— ì¼ì–´ë‚˜ t1ì´ ëë‚œë’¤ì— t2ê°€ ì‹¤í–‰ì´ë˜ì–´ ê¹”ë”í•˜ê²Œ ì¶œë ¥ì´ëœê²ƒ ì¦‰, ë³‘ë ¬ì²˜ë¦¬ê°€ ëœê²ƒì´ ì•„ë‹˜
___

**ë ˆì´ìŠ¤ ì»¨ë””ì…˜ í•´ê²° ë°©ë²• 1 atomic**

```cpp
#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	atomic<int> shared_memory(0);
	
	auto count_func = [&]()
	{
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;		// í˜¹ì€ shared_memory.fetch_add(1);	
		}
	};

	std::thread t1 = std::thread(count_func);
	std::thread t2 = std::thread(count_func);

	t1.join();
	t2.join();

    cout << "After" << endl;
	cout << shared_memory << '\n';
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
After
2000

```

- atomic: ì›ì, ìª¼ê°¤ìˆ˜ì—†ë‹¤ ë¼ëŠ”ëœ»
  - ìŠ¤ë ˆë“œ ê³„ì‚° ì²˜ë¦¬ë°©ë²• 3ë‹¨ê³„ë¥¼ í•œë°©ì— í•˜ê²Œë” ë°”ê¾¼ê²ƒ
- `shared_memory++;` ì˜ `++` ëŠ” ì¦ê°ì—°ì‚°ìê°€ ì•„ë‹Œ atomic<int> ì˜ ì¦ê°ì—°ì‚°ìë¥¼ ì˜¤ë²„ë¡œë”©ì´ ë˜ì–´ìˆëŠ”ê²ƒ 
- ë‹¨ì ìœ¼ë¡œëŠ” `fetch_add()`, `++` ê·¸ëƒ¥ ì¦ê°ì—°ì‚°ì ë“±ë³´ë‹¤ ì¡°ê¸ˆ ëŠë¦¼
  - í•„ìš”í•œ ê³³ì—ë§Œ ì‚¬ìš©í•´ì•¼í•¨

___

**ë ˆì´ìŠ¤ ì»¨ë””ì…˜ í•´ê²° ë°©ë²• 2 mutex**

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

mutex mtx;

int main()
{
	int shared_memory(0);

	auto count_func = [&]() {
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));

			/*mtx.lock();*/
			std::lock_guard lock(mtx);
			std::scoped_lock lock(mtx); // C ++ 17
			shared_memory++;
			/*mtx.unlock();*/
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();

	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
After
2000

```

- mutexë¥¼ ì‚¬ìš©í•˜ì—¬ `lock()` ì„ ê±¸ë©´ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼í•˜ëŠ”ê²ƒì´ ë˜ì–´ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ ë°©ì§€í• ìˆ˜ ìˆìŒ
- unlockì„ ê¹Œë¨¹ì„ìˆ˜ë„ìˆê³  ì˜ˆì™¸ì²˜ë¦¬ì‹œ unlockë¥¼ ê±´ë„ˆë›°ëŠ” ë“± ì‹¤ìˆ˜ë¥¼ í•  ê°€ëŠ¥ì„±ì´ ìˆìŒ
  - ì´ë•Œ ì‚¬ìš©í•˜ëŠ”ê²ƒì´ lcokguardê°€ ìˆìŒ
  - `std::lock_guard lock(mtx);` 
    - lock ì´ë¼ëŠ” ë³€ìˆ˜ê°€ `{}` ì•ˆì— ì„ ì–¸ì´ ë˜ì–´ `{}`ì´ ëë‚ ë•Œ ì¢…ë£Œë˜ê¸° ë•Œë¬¸ì— unlockì„ í•´ì¤„í•„ìš”ê°€ ì—†ìŒ
- `std::scoped_lock lock(mtx);`
  - C++ 17ì— ë„ì…ëœ ê¸°ëŠ¥ lock_guard ë³´ë‹¤ ì§„ë³´ëœ ê¸°ëŠ¥ ì´ê²ƒì„ ì‚¬ìš©í•˜ëŠ”ê²ƒì„ ë” ê¶Œì¥í•˜ëŠ” í¸ì´ë¼ê³  í•¨

### **ğŸŒ± 19.5 ì‘ì—… ê¸°ë°˜ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°**

- ì‘ì—… Task
- ë¹„ë™ê¸° async
- future, promise

___

- `#include <future>`
  - async,Future,Promise ë“±ì„ ì‚¬ìš©í• ìˆ˜ìˆìŒ

**multi-threading**

```cpp
{
	int result;
	std::thread t([&] {result = 1 + 2; });  // ëª¨ë“  ë°”ê¹¥ ë³€ìˆ˜ë¥¼ ë ˆí¼ëŸ°ìŠ¤ë¡œ ë°›ìœ¼ë¯€ë¡œ result ê°’ì´ ë³€í™”í•œë‹¤.
	t.join();

	cout << result << '\n';  
}
```

- ìµœê·¼ì—ëŠ” ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼í•˜ëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ì‹ì„ ì„ í˜¸í•˜ê¸°ë„í•¨
- ê¸°ë³¸ì ìœ¼ë¡œ ìŠ¤ë ˆë“œë¡œë¶€í„° ê°’ì„ ì£¼ê±°ë‹ˆ ë°›ê±°ë¦¬ í•˜ê¸°ìœ„í•´ì„  ìŠ¤ì½”í”„ë¥¼ ë„“ê²Œ ì¡ê³  ê·¸ ìŠ¤ì½”í”„ ë³€ìˆ˜ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë“¤ì´ ê³µìœ ë¥¼ í•˜ëŠ”ê²ƒì´ ì¼ë°˜ì ì„
- ìŠ¤ë ˆë“œ ìœ„ì£¼ë¡œ í”„ë¡œê·¸ë˜ë°ì´ ëœê²ƒ
- ìŠ¤ë ˆë“œê°€ ëª‡ê°œ ìƒê¸°ê³  ê·¸ ìŠ¤ë ˆë“œê°€ ê°ê° ì–´ëŠì¼ì„ í•˜ëŠ”ì§€ ì§€ì •í•´ì£¼ëŠ”ê²ƒ

___

**task-based parallellism**

<br>

**async**

```cpp
{
std::future<int> future = std::async([] {return (1 + 2);});  //  auto future ì“°ëŠ”ê²Œ ë” ê°„í¸
cout << future.get() << '\n';  // 3 ì¶œë ¥
}
```

- **async:** Asynchronous ë¹„ë™ê¸°ì ì´ë‹¤ ë¼ëŠ”ëœ»
- return ê°’ì„ futureì´ ë°›ëŠ”ê²ƒ ì²˜ëŸ¼ í”„ë¡œê·¸ë˜ë° í•œê²ƒ
- async ëŠ” ìŠ¤ë ˆë“œë¥¼ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì´ ì—¬ëŸ¬ê°œìˆìŒ
  - ë³´í†µ threadë³´ë‹¤ asyncë¥¼ ë” ì„ í˜¸í•¨
  - multi-threading ë³´ë‹¤ task-based parallellism ë¥¼ ë” ì„ í˜¸í•¨
- ì–´ë–¤ ì‘ì—…ì„ í• ê²ƒì¸ê°€ ìœ„ì£¼ í”„ë¡œê·¸ë˜ë° return ì„ í•´ì£¼ëŠ” ê°’ì„ í˜„ì¬ ë°›ì„ìˆ˜ ìˆëŠ” ê²ƒì´ ì•„ë‹˜
  - ì¼ë°˜ì ì¸ returnê³¼ ë‹¤ë¦„ ì‘ì—…ì‹œê°„ ì´ ì˜¤ë˜ ê±¸ë ¤ ë‚˜ì¤‘ì— ë°›ì„ìˆ˜ë„ìˆìŒ 
- asyncê°€ ì‹¤í–‰ë˜ëŠ” taskì™€ ì •í™•íˆ ê²°í•©ì´ ë˜ëŠ” êµ¬ì¡°ì„
- `future.get()` 
  - ë¦¬í„´ê°’ì´ intê°€ ë‚ ë¼ì˜´
  - returnê°’ì´ get() ê°’ìœ¼ë¡œ ë‚˜ì˜¤ëŠ”ê²ƒ
  - ë¦¬í„´ê°’ì„ ë°›ê¸° ì „ì´ë¼ë©´ asyncê°€ ì‘ì—…ì„ ë§ˆì¹˜ê³  ê°’ì„ return í•´ì¤„ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¼


**promsise**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	// future and promsise
	{	
		std::promise<int> prom;
		auto future = prom.get_future();

		auto t = std::thread([](std::promise<int>&& prom)
		{
            prom.set_value(1 + 2);
        }, std::move(prom));
		
		cout << future.get() << endl;
		t.join();
	}
}
```

- future ë¥¼ aysunc ì´ì™¸ì— threadì—ì„œë„ ì‚¬ìš©í• ìˆ˜ ìˆìŒ
- promsiseëŠ” async ì²˜ëŸ¼ future ë¥¼ ì£¼ì§€ì•Šê³  ìê¸° threadë¥¼ ì¤Œ futureë¥¼ ë°›ì„ìˆ˜ ìˆëŠ” ì¡´ì¬ê°€ í•„ìš”í•´ promiseë¥¼ ê±°ì³ê°€ëŠ”ê²ƒ
- promì— set_value() ë¥¼ í†µí•´ì„œ ê°’ì„ ë°›ì„ë•Œê¹Œì§€ futureê°€ ê³„ì† ê¸°ë‹¤ë¦¼
- thread ì´ê¸° ë•Œë¬¸ì— `t.join();` ì´í•„ìš”í•¨

___

**async ë™ì‹œì‹¤í–‰**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	auto f1 = std::async([] {
		cout << "Async 1 start\n";
		this_thread::sleep_for(std::chrono::seconds(2)); // 2ì´ˆ ëŒ€ê¸°
		cout << "Async 1 end\n";
		});
	auto f2 = std::async([] {
		cout << "Async 2 start\n";
		this_thread::sleep_for(std::chrono::seconds(1)); // 1ì´ˆ ëŒ€ê¸°
		cout << "Async 2 end\n";
		});

	cout << "Main function\n";  // ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰

}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Main function
Async 1 start
Async 2 start
Async 2 end
Async 1 end

```

- asyncëŠ” threadì™€ ë‹¬ë¦¬ joinì´ ì—†ìŒ.

**thread ë¡œ ë°”ê¾¸ê¸°**

```cpp
{
auto f1 = std::thread([] {
	cout << "Async 1 start\n";
	this_thread::sleep_for(std::chrono::seconds(2)); // 2ì´ˆ ëŒ€ê¸°
	cout << "Async 1 end\n";
});
auto f2 = std::thread([] {
	cout << "Async 2 start\n";
	this_thread::sleep_for(std::chrono::seconds(1)); // 1ì´ˆ ëŒ€ê¸°
	cout << "Async 2 end\n";
});

cout << "Main function\n";  // ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰

f1.join();
f2.join();

}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Main function
Async 2 start
Async 1 start
Async 2 end
Async 1 end

```

### **ğŸŒ± **

### **ğŸŒ± **

### **ğŸŒ± **

# ğŸ“Œì°¸ì¡°ë§í¬
ì¸í”„ëŸ° **ë”°ë¼í•˜ë©´ì„œ ë°°ìš°ëŠ” C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**ê³µë¶€í•˜ëŠ” ì‹ë¹µë§˜ ğŸ‘±â€â™€ï¸ ë‹˜ì˜ ë¸”ë¡œê·¸** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)