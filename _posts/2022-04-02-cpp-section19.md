---
published: true
title:  "ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤"
excerpt: ""

categories:
  - ë”°ë°°ì”¨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-08
last_modified_at: 2022-05-08 
---

# ğŸ¤” í•™ìŠµëª©í‘œ
- ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤

# ğŸ“ƒ í•™ìŠµë‚´ìš©
## ğŸ“ **ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤**

### **ğŸŒ± 19.1 ëŒë‹¤ í•¨ìˆ˜ì™€ std::function std::bind, for_each**

**ëŒë‹¤ í•¨ìˆ˜**

- ìµëª…í•¨ìˆ˜ë¼ê³  ë¶ˆë¦¼ 
- ì–´ì›ì€ ëŒë‹¤ ìº˜í˜ëŸ¬ìŠ¤ì—ì„œ ë‚˜ì˜´
- ë³´í†µ lambda function, Anonymous function ì´ë¼ê³  ë¶€ë¦„

**í•¨ìˆ˜ í¬ì¸í„°ë¡œì¨ì˜ ëŒë‹¤ í•¨ìˆ˜**

```cpp
auto func = [](const int& i) -> void {cout << "Hello, World!\n"; };  // ëŒë‹¤ í•¨ìˆ˜
```

**ìµëª… í•¨ìˆ˜ë¡œì¨ì˜ ëŒë‹¤ í•¨ìˆ˜**

```cpp
[]() -> void { cout << "Hello, World!\n"; }();
```

- êµ¬í˜„í• ê²Œ ì¡ë‹¤í•˜ê³  ë§ì•„ì§ˆë•Œ ì‚¬ìš©í•˜ë©´ ì¢‹ìŒ
- GUI ê´€ë ¨ í”„ë¡œê·¸ë˜ë°ì‹œ ë§ì´ ì‚¬ìš©í•¨


- `[]` lammda-introducer 
  - `[&]` ëŒë‹¤ í‘ì…˜ì´ ì •ì˜ëœ ì˜ì—­ì— `&` ë¥¼ ë„£ì–´ë†“ë©´ ë°–ì— ìˆëŠ”ê²ƒì„ ë ˆí¼ëŸ°ìŠ¤ë¡œ ê°€ì ¸ì˜´
    - `=` ì¹´í”¼
    - `this` í´ë˜ìŠ¤ ë©¤ë²„ ì •ì˜
    - `&ë³€ìˆ˜` 

___

**std::for_each**

```cpp
#include <algorithm> // for_each

vector<int> vec;    
vec.push_back(10); 
vec.push_back(20);

auto func2 = [](int val) {cout << val << "  "; };
std::for_each(vec.begin(), vec.end(), func2); 
```

- ì´ë ‡ê²Œ ì‚¬ìš©í•˜ë ¤ê³  ì‚¬ìš©í•˜ì§€ ì•Šê³  ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ë°”ë¡œë„£ì–´ ë²„ë ¤ ì‚¬ìš©í•¨

```cpp
std::for_each(vec.begin(), vec.end(), [](int val) {cout << val << "  "; });
```

**ëŒë‹¤ í•¨ìˆ˜ ë¦¬í„´íƒ€ì… ì„¤ì •**

```cpp
cout << []() -> int {return 1;} << enld;
```

- intíƒ€ì…ìœ¼ë¡œ ì„¤ì •

___

**std::function**

```cpp
auto func2 = [](int val) {cout << val << "  "; };	
std::function<void(int)> func3 = func2;	
func3(123);
```

- ì¼ì¢…ì˜ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì²´ê³„í™” ì‹œì¼œì¤€ê²ƒ
  - void ë¦¬í„´íƒ€ì…
  - int íŒŒë¼ë©”íƒ€ íƒ€ì…

- í•¨ìˆ˜ì˜ ê¸°ëŠ¥ì„ ë³€ìˆ˜ì²˜ëŸ¼ ì£¼ê³ ë°›ê³ í•¨

**std::bind**

```cpp
auto func = [](int val) {cout << val << "  "; };

std::function<void(void)> func2 = std::bind(func, 456);	

func2();  // 456 ì¶œë ¥
```

- íŒŒë¼ë©”íƒ€ íƒ€ì…ì„ ìë£Œí˜•ì„ ì“°ê³ ì‹¶ì§€ì•Šì„ë•Œ intë¥¼ bindí•˜ì—¬ ë„£ëŠ” ê²ƒ
- void íƒ€ì…ì¸ func2ì— intíƒ€ì…ì¸ func í•¨ìˆ˜ë¥¼ ë„£ì–´ì¤˜ì„œ bindí•˜ì—¬ì„œ ë„£ì„ìˆ˜ ìˆìŒ

___

**std::placeholders**

```cpp
#include <functional>
#include <iostream>
 
using namespace std;
 
int multiply(int a, int b)
{
    return a * b;
}
 
int main()
{
    auto func = std::bind(multiply, 5, placeholders::_1);
 
    for (int i = 0; i < 10; i++)
    {
        cout << "5 * " << i << " = " << func(i) << endl;
    }
    return 0;
}
```

- íŒŒë¼ë©”íƒ€ê°€ ì—¬ëŸ¬ê°œì¼ê²½ìš° ë„£ì–´ì£¼ëŠ”ê²ƒ

### **ğŸŒ± 19.2 C++ 17 í•¨ìˆ˜ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ë¦¬í„´ê°’ ë³€í™˜ í•˜ê¸°**

**ì˜›ë‚  tuple**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

tuple<int, int> my_func()
{ 
	return tuple<int, int>(123, 456); 
}

int main()
{
	tuple<int, int> result = my_func();
	cout << get<0>(result) << " " << get<1>(result) << endl;
}
```

- ë¦¬í„´ë°ì´í„° íƒ€ì…ì„ êµ¬ì¡°ì²´ë‚˜ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ìˆ˜ë„ ìˆìŒ
  - ë§¤ë²ˆ ë§Œë“¤ê¸° ê·€ì°®ìŒ
- tuple
  - ìˆ˜í•™ì ì˜ë¯¸: ì—¬ëŸ¬ê°œì˜ ë°ì´í„°ì˜ ìŒ

___

**í˜„ëŒ€ì  C++ tuple ì‚¬ìš©ë²•**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto my_func()
{ 
  return tuple<int, int, int>(123, 456, 789); // ì˜›ë‚  ë°©ì‹
	return tuple(123, 456, 789); // C++ 17 ë¶€í„° ì‚¬ìš©ê°€ëŠ¥
}

int main()
{
	auto [a, b, c] = func();
	cout << a << " " << b << " " << c << "\n";
}
```

### **ğŸŒ± 19.3 std threadì™€ ë©€í‹°ì“°ë ˆë”© ê¸°ì´ˆ**

**Process**

- osê°€ ìš°ë¦¬ê°€ ì‘ì„±í•œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰ì‹œí‚¬ë•Œ ê´€ë¦¬í•˜ëŠ” ë‹¨ìœ„
- í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ê´€ë¦¬í•¨


**multithreading**

- í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ê³  ê·¸í”„ë¡œê·¸ë¨ì´ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ë§Œë“¤ì–´ì„œ ì—¬ëŸ¬ê°œì˜ ì½”ì–´ë¥¼ ë™ì‹œì— í™œìš©í•´ íš¨ìœ¨ì„±ì„ ë†’ì´ëŠ” ë°©ë²•
- í•˜ë‚˜ì˜ cpuì— ì—¬ëŸ¬ê°œì˜ ì½”ì–´ê°€ ë“¤ì–´ìˆëŠ”ê²½ìš° ê·¸ì½”ì–´ë“¤ì„ í™œìš©í•´ì„œ ë™ì‹œì— ì—¬ëŸ¬ê°œì˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒ
- ì˜ˆì „ì—” cpuí•˜ë‚˜ì— ì½”ì–´ í•˜ë‚˜ê°€ ë“¤ì–´ìˆë˜ì‹œì ˆì—ëŠ” í•œë³´ë“œì— ì—¬ëŸ¬ê°œì˜ cpuë¥¼ ë„£ì–´ì„œ multithreadingì„ í–ˆì—ˆìŒ ë³´í†µ 2ê°œì •ë„ ê½‚ìœ¼ë©´ ë©”ëª¨ë¦¬ ì†ë„ì˜ í•œê³„ë•Œë¬¸ì— íš¨ìœ¨ì´ì¢‹ì§€ì•Šì•˜ìŒ
- **ë¶„ì‚°ì²˜ë¦¬:** multithreadingì‹œ íš¨ìœ¨ì„ ë†’ì´ê¸°ìœ„í•´ ë„¤íŠ¸ì›Œí¬ë¡œ ì—¬ëŸ¬ê°œì˜ pcë¥¼ ì—°ê²°ì‹œí‚¤ê³  ì—¬ëŸ¬ê°œì˜ pcì— ë“¤ì–´ìˆëŠ” ì½”ì–´ë“¤ì„ ì „ë¶€ ë™ì‹œì— í™œìš©í•˜ëŠ” ê²ƒ
  - pcê°€ ì „ë¶€ í©ì–´ì ¸ ìˆì–´ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í• ìˆ˜ ì—†ìŒ
  - í†µì‹ í• ë•Œ ì—¬ëŸ¬ê°€ì§€ ë¶€ê°€ì ì¸ ì˜¤ë²„í—¤ë“œê°€ ìƒê¸°ê¸°ë„ í•¨
- multithreadingì€ ì—¬ëŸ¬ê°œì˜ threadë“¤ì´ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•¨
  - ìœ„í—˜í•˜ê¸°ë„í•¨
- multicore cpuì—ì„œ ìë™ìœ¼ë¡œ multithreadingìœ¼ë¡œ íš¨ìœ¨ì„ ë†’ì—¬ì£¼ëŠ”ê²ƒì´ ì•„ë‹ˆê³  multithreadingì„ í•˜ë„ë¡ í”„ë¡œê·¸ë˜ë°ì„ ì§ì ‘í•´ì•¼í•¨
- threadê°€ ì‹¤íƒ€ë˜ë¼ëŠ” ì˜ë¯¸ë¥¼ ê°–ê³ ìˆì–´ ì‹¤ì„ ì´ì™¸ì— ì­ˆê¸€ì­ˆê¸€í•œ ì„ ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²½ìš°ë„ ìˆìŒ

<br>


**Process ìˆ˜í–‰ ìˆœì„œ**

1. ë©”ì¸ í•¨ìˆ˜ë¡œ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë¨ ê·¸ ë©”ì¸í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³ ìˆëŠ” threadë¥¼ ë©”ì¸ thread,ì£¼ëœ thread ë¼ê³  ë¶€ë¦„
2. ë¬´ê±°ìš´ ì‘ì—…ì„ ì‹œì‘í• ë•Œ ì—¬ëŸ¬ê°œì˜ threadë“¤ì´ ì¼ì„ ë‚˜ëˆ ì„œ ì‘ì—…í•´ì•¼í• ë•Œ multithreadingìœ¼ë¡œ í”„ë¡œê·¸ë˜ë°ì„ í•´ë‘ê³  main threadê°€ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ì‹¤í–‰ì„ ì‹œí‚´
  - ë¶€ê°€ì ì¸ threadë¥¼ ì‹¤í–‰ì‹œí‚¬ë•Œ ìˆœì°¨ì ìœ¼ë¡œ ì‹œí‚¤ì§€ë§Œ ë™ì‹œì— ì‹œí‚¨ë‹¤ê³  í•˜ê¸°ë„í•¨
  - ìì‹ thread ì—ì„œ ë˜ë‹¤ë¥¸ ìì‹ thread ë¥¼ ì‹¤í–‰ì‹œí‚¬ìˆ˜ë„ ìˆìŒ
3. ìì‹ thread ëŠ” main threadê°€ ì–´ë–¤ ì‘ì—…ì„ í•˜ë˜ì§€ ê°„ì— ë³„ë„ì˜ í”„ë¡œê·¸ë¨ì¸ê²ƒ ì²˜ëŸ¼ ì‘ë™ì„ í•¨ 
4. ìì‹ threadê°€ ì‘ì—…ì„ ë§ˆì¹ ë•Œ main threadê°€ ê¸°ë‹¤ë¦¬ê³ ìˆìŒ
   - ìì‹ threadê°€ ì‘ì—…ì´ ëë‚˜ëŠ” ì‹œì ì„ main threadëŠ” ì•Œì§€ ëª»í•¨ 
5. ì‘ì—…ì´ ëë‚˜ë©´ í”„ë¡œê·¸ë¨ì´ ëë‚¨

___

![ìº¡ì²˜](https://user-images.githubusercontent.com/90514882/167283762-8b9fbad2-4859-4baf-bbfe-7e3a2c30c26d.PNG)


- **ì½”ì–´:** ë¬¼ë¦¬ì  ì½”ì–´ì˜ ê°¯ìˆ˜
- **ë…¼ë¦¬ í”„ë¡œì„¸ì„œ:** hyper threading ì´ë¼ëŠ” ê¸°ìˆ ë¡œ ë¬¼ë¦¬ì ì½”ì–´ì˜ 2ë°°ì— í•´ë‹¹í•˜ëŠ” í”„ë¡œì„¸ì„œë¥¼ ê°€ì§€ê³ ìˆëŠ”ê²ƒ ì²˜ëŸ¼ ì‚¬ìš©í• ìˆ˜ ìˆê²Œí•´ì¤Œ
- **ì´ìš©ë¥ :** í˜„ì¬ cpuê°€ ì‚¬ìš©ë˜ê³  ìˆëŠ” ë¹„ìœ¨
  - ë…¼ë¦¬ í”„ë¡œì„¸ì„œë¥¼ ëª¨ë‘ ê³ ë ¤í•œ ì»´í“¨íŒ… ëŠ¥ë ¥ì„ ë³´ì—¬ì£¼ëŠ”ê²ƒ
- **í”„ë¡œì„¸ì„œ:** ë©”ì¸ í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œì¼œì£¼ëŠ” osê°€ ë°°ì •í•´ì£¼ëŠ” ì¼ì„í•˜ëŠ” ì¡´ì¬
- **ìŠ¤ë ˆë“œ:** í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•´ì„œ ì¼ì„ í•¨

<br>

- main í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì‹¤í–‰ì´ëœë‹¤
- í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì°¨ì§€í•˜ëŠ” ê²ƒì€ ê¸°ë³¸ì ìœ¼ë¡œ cpuì˜ ë…¼ë¦¬ í”„ë¡œì„¸ì„œ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•¨

___

**thread**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	cout << std::thread::hardware_concurrency() << endl; // ë…¼ë¦¬ í”„ë¡œì„¸ì„œ ê°¯ìˆ˜
	cout << std::this_thread::get_id() << endl; // thread id

  // multi thread
	std::thread t1 = std::thread([] {
	cout << std::this_thread::get_id() << '\n';
	//while (true);
	});
	t1.join();		// t1ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤.
}
```

- `hardware_concurrency()` ì½”ì–´ê°¯ìˆ˜ ë¥¼ ë°›ì•„ì˜¬ìˆ˜ ìˆìŒ
- `std::this_thread::get_id()` ë©”ì¸í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ê³ ìˆëŠ” thread this_threadì˜ idë¥¼ ì¶œë ¥í•´ì¤Œ
- ë©”ì¸í•¨ìˆ˜ê°€ ë©”ì¸ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•˜ê³  `std::thread t1 = std::thread([] {cout << std::this_thread::get_id() << '\n';});` ì•ˆì—ì„œ ìì‹ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•¨ ìì‹ìŠ¤ë ˆë“œê°€ ëë‚œë’¤ì— ë©”ì¸ ìŠ¤ë ˆë“œì™€ í†µì‹ í•´ì•¼í•˜ëŠ”ë° í†µì‹ í•˜ê¸° ì „ì— ë©”ì¸ í•¨ìˆ˜ê°€ ëë‚˜ë²„ë ¤ ì—ëŸ¬ê°€ ë°œìƒí•¨ 
  - ì´ë¥¼ ë°©ì§€í•˜ê¸°ìœ„í•´ `t1.join()` ë¥¼ ì‚¬ìš©í• ìˆ˜ ìˆìŒ

___

**ì—¬ëŸ¬ê°œì˜ thread ì‚¬ìš©í•˜ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	std::thread t1 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t2 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t3 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t4 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	t1.join();
	//t2.join();
	//t3.join();
	//t4.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
463276042468
```
- t1, t2, t3, t4 ìŠ¤ë ˆë“œê°€ ê°ê° ë³‘ë ¬ë¡œ ë™ì‹œì— ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—(ë©€í‹°ìŠ¤ë ˆë”©) idê°€ ì¤‘êµ¬ë‚œë°©ìœ¼ë¡œ ì„ì—¬ ì¶œë ¥ë¨
- coutì´ ê°ë‹¹ì„ ëª»í•´ì„œ ê¼¬ì¸ê²ƒ

___

**vectorì— thread ë„£ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	const int num_pro = std::thread::hardware_concurrency();

	vector<std::thread> my_threads;
	my_threads.resize(num_pro);

  for (auto & e : my_threads)
  {
      e = std::thread([](){
				cout << std::this_thread::get_id() << endl;
				while(true){}
          });
  }
		
	for (auto & e : my_threads)
		e.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
2438421972
9364
17412
20952
13428

9864
16900
20628
15592
4840
2584
4516
13492
20320
22612




```

- ìœ„ ì˜ˆì œì½”ë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ cpuì‚¬ìš©ë¥  100í¼ë¥¼ ì‚¬ìš©í•˜ê²Œë¨
  - ì¤‘ê°„ì¤‘ê°„ ê¸€ìê°€ ê¹¨ì§
- multi thread ë¥¼ ê³µë¶€í•˜ê²Œë˜ë©´ num_threadì™€ ì‹¤ì œ ìƒì„±í•˜ëŠ” thread ê°¯ìˆ˜ë¥¼ ì‹ ê²½ì¨ì•¼í•¨
- ì¼ë°˜ì ìœ¼ë¡œ ìƒì„±í•˜ëŠ” thread ê°¯ìˆ˜ì™€ í•˜ë“œì›¨ì–´ í”„ë¡œì„¸ì„œ ê°¯ìˆ˜ë¥¼ ë§ì¶”ëŠ”ê²ƒì´ ì¼ë°˜ì ì„ 
- ëª¨ë“ ë¬¸ì œë¥¼ ë³‘ë ¬ë¡œ ë‹¤ ì‚¬ìš©í• ìˆœì—†ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë©€í‹°ìŠ¤ë ˆë”©ì€ ìœ ìš©í•¨
  
___

```cpp
#include <iostream>
#include <thread>
#include <mutex>		// semaphoreëŠ” ì—†ìŒ
using namespace std;

int main()
{
	auto work_func = [](const string & name)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	work_func("JackJack");
	work_func("Dash");
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
JackJack 5172 is working 0
JackJack 5172 is working 1
JackJack 5172 is working 2
JackJack 5172 is working 3
JackJack 5172 is working 4
Dash 5172 is working 0
Dash 5172 is working 1
Dash 5172 is working 2
Dash 5172 is working 3
Dash 5172 is working 4

```

- `std::this_thread::sleep_for(std::chrono::milliseconds(100));` ì‰¬ëŠ” ì‹œê°„ ë„£ê¸°
  - ì‹¤ì œë¡œëŠ” í•  ì‘ì—…ì„ ë„£ëŠ” ë¶€ë¶„
- `work_func("JackJack");` ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ `work_func("Dash");` ëŠ” ë†€ê³ ìˆëŠ” í˜•íƒœì„
  - multi threadingì´ ì•„ë‹ˆë©° ë¹„íš¨ìœ¨ì ì„

**multi threadingìœ¼ë¡œ ë°”ê¾¸ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	auto work_func = [](const string& name, const int j)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			cout << name << " " << j << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack", 123);
	std::thread t2 = std::thread(work_func, "Dash", 456);

	t1.join();
	t2.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
JackJack Dash 456 23564 is working 0123 16988 is working 0

JackJack 123 16988 is working 1
Dash 456 23564 is working 1
JackJack 123 16988 is working 2
Dash 456 23564 is working 2
Dash 456 23564 is working 3
JackJack 123 16988 is working 3
JackJack 123 16988 is working 4
Dash 456 23564 is working 4

```

- ë©€í‹°ì“°ë ˆë”©ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ë™ì‹œì— ì¼ì„í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•¨
- ì‘ì—…ì€ ë™ì‹œì—í•˜ëŠ”ë° ì¶œë ¥ë„ ë™ì‹œì—ë‚˜ì™€ì„œ ì§€ì €ë¶„í•¨

**mutex**

```cpp
#include <iostream>
#include <thread>
#include <mutex> 

using namespace std;

mutex mtx; // ì„ ì–¸

int main()
{	

	auto work_func = [](const string& name)
	{

		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			mtx.lock();
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
			mtx.unlock();
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack");
	std::thread t2 = std::thread(work_func, "Dash");

	t1.join();
	t2.join();
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
JackJack 4272 is working 0
Dash 12944 is working 0
Dash 12944 is working 1
JackJack 4272 is working 1
JackJack 4272 is working 2
Dash 12944 is working 2
Dash 12944 is working 3
JackJack 4272 is working 3
JackJack 4272 is working 4
Dash 12944 is working 4

```

- ì‘ì—…ì€ ë™ì‹œì—í•˜ëŠ”ë° ì¶œë ¥ë„ ì¶œë ¥ì„ ìˆœì°¨ì ìœ¼ë¡œ í•´ì¤„ìˆ˜ìˆìŒ
- mutex ëŠ” **mutual exclusion** ë¥¼ ëœ»í•¨ 
  - ìƒí˜¸ë°°ì¬ ë¼ëŠ”ëœ»
- ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì´ë¶€ë¶„ì€ ê±´ë“¤ì´ì§€ë§ê³  í•œë²ˆì— í•˜ë‚˜ì˜ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë¼ëŠ” ëœ»
- ë‘ ìŠ¤ë ˆë“œì¤‘ ì‘ì—…ì„ ë¨¼ì € ë§ˆì¹œ ìŠ¤ë ˆë“œê°€ mtx.lock ì— ì™€ì„œ ì ê¶ˆë²„ë¦¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ëª»ë“¤ì–´ì˜¤ê²Œë¨ ê·¸ í›„ ì¶œë ¥ í›„ lockì„ í’€ê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°ë¥¼ í•˜ê³ ìˆë‹¤ê°€ ë“¤ì–´ì˜¤ê³  ë°˜ë³µí•˜ëŠ” ê³¼ì •ì„
- `mtx.lock();` ì„í•˜ê³  `mtx.unlock();` ì„ ì•ˆí•´ë²„ë¦¬ë©´ ë¬¸ì œê°€ ë°œìƒí•¨
- ë©€í‹°ìŠ¤ë ˆë“œëŠ” ì„œë¡œ ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ì—ì„œ ë¬¸ì œë¥¼ ì–´ë–»ê²Œ í•´ê²°í•˜ëŠëƒê°€ ì¤‘ìš”í•¨


### **ğŸŒ± **

### **ğŸŒ± **


# ğŸ“Œì°¸ì¡°ë§í¬
ì¸í”„ëŸ° **ë”°ë¼í•˜ë©´ì„œ ë°°ìš°ëŠ” C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**ê³µë¶€í•˜ëŠ” ì‹ë¹µë§˜ ğŸ‘±â€â™€ï¸ ë‹˜ì˜ ë¸”ë¡œê·¸** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)