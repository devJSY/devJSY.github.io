---
published: true
title:  "따라하며 배우는 C++ Section 19. 모던 C++필수 요소들"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-08
last_modified_at: 2022-05-08 
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 19. 모던 C++필수 요소들

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 19. 모던 C++필수 요소들**

### **🌱 19.1 람다 함수와 std::function std::bind, for_each**

**람다 함수**

- 익명함수라고 불림 
- 어원은 람다 캘큘러스에서 나옴
- 보통 lambda function, Anonymous function 이라고 부름

**함수 포인터로써의 람다 함수**

```cpp
auto func = [](const int& i) -> void {cout << "Hello, World!\n"; };  // 람다 함수
```

**익명 함수로써의 람다 함수**

```cpp
[]() -> void { cout << "Hello, World!\n"; }();
```

- 구현할게 잡다하고 많아질때 사용하면 좋음
- GUI 관련 프로그래밍시 많이 사용함


- `[]` lammda-introducer 
  - `[&]` 람다 펑션이 정의된 영역에 `&` 를 넣어놓면 밖에 있는것을 레퍼런스로 가져옴
    - `=` 카피
    - `this` 클래스 멤버 정의
    - `&변수` 

___

**std::for_each**

```cpp
#include <algorithm> // for_each

vector<int> vec;    
vec.push_back(10); 
vec.push_back(20);

auto func2 = [](int val) {cout << val << "  "; };
std::for_each(vec.begin(), vec.end(), func2); 
```

- 이렇게 사용하려고 사용하지 않고 아래 코드와 같이 바로넣어 버려 사용함

```cpp
std::for_each(vec.begin(), vec.end(), [](int val) {cout << val << "  "; });
```

**람다 함수 리턴타입 설정**

```cpp
cout << []() -> int {return 1;} << enld;
```

- int타입으로 설정

___

**std::function**

```cpp
auto func2 = [](int val) {cout << val << "  "; };	
std::function<void(int)> func3 = func2;	
func3(123);
```

- 일종의 함수 포인터를 체계화 시켜준것
  - void 리턴타입
  - int 파라메타 타입

- 함수의 기능을 변수처럼 주고받고함

**std::bind**

```cpp
auto func = [](int val) {cout << val << "  "; };

std::function<void(void)> func2 = std::bind(func, 456);	

func2();  // 456 출력
```

- 파라메타 타입을 자료형을 쓰고싶지않을때 int를 bind하여 넣는 것
- void 타입인 func2에 int타입인 func 함수를 넣어줘서 bind하여서 넣을수 있음

___

**std::placeholders**

```cpp
#include <functional>
#include <iostream>
 
using namespace std;
 
int multiply(int a, int b)
{
    return a * b;
}
 
int main()
{
    auto func = std::bind(multiply, 5, placeholders::_1);
 
    for (int i = 0; i < 10; i++)
    {
        cout << "5 * " << i << " = " << func(i) << endl;
    }
    return 0;
}
```

- 파라메타가 여러개일경우 넣어주는것

### **🌱 19.2 C++ 17 함수에서 여러 개의 리턴값 변환 하기**

**옛날 tuple**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

tuple<int, int> my_func()
{ 
	return tuple<int, int>(123, 456); 
}

int main()
{
	tuple<int, int> result = my_func();
	cout << get<0>(result) << " " << get<1>(result) << endl;
}
```

- 리턴데이터 타입을 구조체나 클래스를 사용해서 만들수도 있음
  - 매번 만들기 귀찮음
- tuple
  - 수학적의미: 여러개의 데이터의 쌍

___

**현대적 C++ tuple 사용법**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto my_func()
{ 
  return tuple<int, int, int>(123, 456, 789); // 옛날 방식
	return tuple(123, 456, 789); // C++ 17 부터 사용가능
}

int main()
{
	auto [a, b, c] = func();
	cout << a << " " << b << " " << c << "\n";
}
```

### **🌱 19.3 std thread와 멀티쓰레딩 기초**

**Process**

- os가 우리가 작성한 프로그램을 실행시킬때 관리하는 단위
- 하나의 프로세스가 여러개의 thread를 관리함


**multithreading**

- 하나의 프로그램을 만들고 그프로그램이 여러개의 thread를 만들어서 여러개의 코어를 동시에 활용해 효율성을 높이는 방법
- 하나의 cpu에 여러개의 코어가 들어있는경우 그코어들을 활용해서 동시에 여러개의 작업을 수행하는 것
- 예전엔 cpu하나에 코어 하나가 들어있던시절에는 한보드에 여러개의 cpu를 넣어서 multithreading을 했었음 보통 2개정도 꽂으면 메모리 속도의 한계때문에 효율이좋지않았음
- **분산처리:** multithreading시 효율을 높이기위해 네트워크로 여러개의 pc를 연결시키고 여러개의 pc에 들어있는 코어들을 전부 동시에 활용하는 것
  - pc가 전부 흩어져 있어 메모리를 공유할수 없음
  - 통신할때 여러가지 부가적인 오버헤드가 생기기도 함
- multithreading은 여러개의 thread들이 메모리를 공유함
  - 위험하기도함
- multicore cpu에서 자동으로 multithreading으로 효율을 높여주는것이 아니고 multithreading을 하도록 프로그래밍을 직접해야함
- thread가 실타래라는 의미를 갖고있어 실선이외에 쭈글쭈글한 선으로 표현하는 경우도 있음

<br>


**Process 수행 순서**

1. 메인 함수로 프로그램이 실행됨 그 메인함수를 실행하고있는 thread를 메인 thread,주된 thread 라고 부름
2. 무거운 작업을 시작할때 여러개의 thread들이 일을 나눠서 작업해야할때 multithreading으로 프로그래밍을 해두고 main thread가 여러개의 thread를 실행을 시킴
  - 부가적인 thread를 실행시킬때 순차적으로 시키지만 동시에 시킨다고 하기도함
  - 자식 thread 에서 또다른 자식 thread 를 실행시킬수도 있음
3. 자식 thread 는 main thread가 어떤 작업을 하던지 간에 별도의 프로그램인것 처럼 작동을 함 
4. 자식 thread가 작업을 마칠때 main thread가 기다리고있음
   - 자식 thread가 작업이 끝나는 시점을 main thread는 알지 못함 
5. 작업이 끝나면 프로그램이 끝남

___

![캡처](https://user-images.githubusercontent.com/90514882/167283762-8b9fbad2-4859-4baf-bbfe-7e3a2c30c26d.PNG)


- **코어:** 물리적 코어의 갯수
- **논리 프로세서:** hyper threading 이라는 기술로 물리적코어의 2배에 해당하는 프로세서를 가지고있는것 처럼 사용할수 있게해줌
- **이용률:** 현재 cpu가 사용되고 있는 비율
  - 논리 프로세서를 모두 고려한 컴퓨팅 능력을 보여주는것
- **프로세서:** 메인 함수를 실행시켜주는 os가 배정해주는 일을하는 존재
- **스레드:** 프로세스 하나가 여러개의 스레드를 사용해서 일을 함

<br>

- main 함수를 실행시키면 프로세스 하나가 실행이된다
- 프로세스 하나가 차지하는 것은 기본적으로 cpu의 논리 프로세서 하나를 사용함

___

**thread**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	cout << std::thread::hardware_concurrency() << endl; // 논리 프로세서 갯수
	cout << std::this_thread::get_id() << endl; // thread id

  // multi thread
	std::thread t1 = std::thread([] {
	cout << std::this_thread::get_id() << '\n';
	//while (true);
	});
	t1.join();		// t1이 끝날 때까지 기다린다.
}
```

- `hardware_concurrency()` 코어갯수 를 받아올수 있음
- `std::this_thread::get_id()` 메인함수가 실행되고있는 thread this_thread의 id를 출력해줌
- 메인함수가 메인스레드를 실행하고 `std::thread t1 = std::thread([] {cout << std::this_thread::get_id() << '\n';});` 안에서 자식스레드를 실행함 자식스레드가 끝난뒤에 메인 스레드와 통신해야하는데 통신하기 전에 메인 함수가 끝나버려 에러가 발생함 
  - 이를 방지하기위해 `t1.join()` 를 사용할수 있음

___

**여러개의 thread 사용하기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	std::thread t1 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t2 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t3 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t4 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	t1.join();
	//t2.join();
	//t3.join();
	//t4.join();
}
```

**출력결과**

```cpp
463276042468
```
- t1, t2, t3, t4 스레드가 각각 병렬로 동시에 실행되기 때문에(멀티스레딩) id가 중구난방으로 섞여 출력됨
- cout이 감당을 못해서 꼬인것

___

**vector에 thread 넣기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	const int num_pro = std::thread::hardware_concurrency();

	vector<std::thread> my_threads;
	my_threads.resize(num_pro);

  for (auto & e : my_threads)
  {
      e = std::thread([](){
				cout << std::this_thread::get_id() << endl;
				while(true){}
          });
  }
		
	for (auto & e : my_threads)
		e.join();
}
```

**출력결과**

```cpp
2438421972
9364
17412
20952
13428

9864
16900
20628
15592
4840
2584
4516
13492
20320
22612




```

- 위 예제코드를 실행시키면 cpu사용률 100퍼를 사용하게됨
  - 중간중간 글자가 깨짐
- multi thread 를 공부하게되면 num_thread와 실제 생성하는 thread 갯수를 신경써야함
- 일반적으로 생성하는 thread 갯수와 하드웨어 프로세서 갯수를 맞추는것이 일반적임 
- 모든문제를 병렬로 다 사용할순없지만 일반적으로 멀티스레딩은 유용함
  
___

```cpp
#include <iostream>
#include <thread>
#include <mutex>		// semaphore는 없음
using namespace std;

int main()
{
	auto work_func = [](const string & name)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	work_func("JackJack");
	work_func("Dash");
}
```

**출력결과**

```cpp
JackJack 5172 is working 0
JackJack 5172 is working 1
JackJack 5172 is working 2
JackJack 5172 is working 3
JackJack 5172 is working 4
Dash 5172 is working 0
Dash 5172 is working 1
Dash 5172 is working 2
Dash 5172 is working 3
Dash 5172 is working 4

```

- `std::this_thread::sleep_for(std::chrono::milliseconds(100));` 쉬는 시간 넣기
  - 실제로는 할 작업을 넣는 부분
- `work_func("JackJack");` 이 실행되는 동안 `work_func("Dash");` 는 놀고있는 형태임
  - multi threading이 아니며 비효율적임

**multi threading으로 바꾸기**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	auto work_func = [](const string& name, const int j)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			cout << name << " " << j << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack", 123);
	std::thread t2 = std::thread(work_func, "Dash", 456);

	t1.join();
	t2.join();
}
```

**출력결과**

```cpp
JackJack Dash 456 23564 is working 0123 16988 is working 0

JackJack 123 16988 is working 1
Dash 456 23564 is working 1
JackJack 123 16988 is working 2
Dash 456 23564 is working 2
Dash 456 23564 is working 3
JackJack 123 16988 is working 3
JackJack 123 16988 is working 4
Dash 456 23564 is working 4

```

- 멀티쓰레딩을 사용하는 이유는 동시에 일을하기 위해 사용함
- 작업은 동시에하는데 출력도 동시에나와서 지저분함

**mutex**

```cpp
#include <iostream>
#include <thread>
#include <mutex> 

using namespace std;

mutex mtx; // 선언

int main()
{	

	auto work_func = [](const string& name)
	{

		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			mtx.lock();
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
			mtx.unlock();
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack");
	std::thread t2 = std::thread(work_func, "Dash");

	t1.join();
	t2.join();
}
```

**출력 결과**

```cpp
JackJack 4272 is working 0
Dash 12944 is working 0
Dash 12944 is working 1
JackJack 4272 is working 1
JackJack 4272 is working 2
Dash 12944 is working 2
Dash 12944 is working 3
JackJack 4272 is working 3
JackJack 4272 is working 4
Dash 12944 is working 4

```

- 작업은 동시에하는데 출력도 출력을 순차적으로 해줄수있음
- mutex 는 **mutual exclusion** 를 뜻함 
  - 상호배재 라는뜻
- 여러개의 스레드를 이부분은 건들이지말고 한번에 하나의스레드를 실행시키라는 뜻
- 두 스레드중 작업을 먼저 마친 스레드가 mtx.lock 에 와서 잠궈버림 다른 스레드는 못들어오게됨 그 후 출력 후 lock을 풀고 다른 스레드가 대기를 하고있다가 들어오고 반복하는 과정임
- `mtx.lock();` 을하고 `mtx.unlock();` 을 안해버리면 문제가 발생함
- 멀티스레드는 서로 중복되는 부분에서 문제를 어떻게 해결하느냐가 중요함


### **🌱 **

### **🌱 **


# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**공부하는 식빵맘 👱‍♀️ 님의 블로그** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)