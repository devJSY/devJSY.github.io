---
published: true
title:  "ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤"
excerpt: ""

categories:
  - ë”°ë°°ì”¨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-05-08
last_modified_at: 2022-05-09
---

# ğŸ¤” í•™ìŠµëª©í‘œ
- ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤

# ğŸ“ƒ í•™ìŠµë‚´ìš©
## ğŸ“ **ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 19. ëª¨ë˜ C++í•„ìˆ˜ ìš”ì†Œë“¤**

### **ğŸŒ± 19.1 ëŒë‹¤ í•¨ìˆ˜ì™€ std::function std::bind, for_each**

**ëŒë‹¤ í•¨ìˆ˜**

- ìµëª…í•¨ìˆ˜ë¼ê³  ë¶ˆë¦¼ 
- ì–´ì›ì€ ëŒë‹¤ ìº˜í˜ëŸ¬ìŠ¤ì—ì„œ ë‚˜ì˜´
- ë³´í†µ lambda function, Anonymous function ì´ë¼ê³  ë¶€ë¦„

**í•¨ìˆ˜ í¬ì¸í„°ë¡œì¨ì˜ ëŒë‹¤ í•¨ìˆ˜**

```cpp
auto func = [](const int& i) -> void {cout << "Hello, World!\n"; };  // ëŒë‹¤ í•¨ìˆ˜
```

**ìµëª… í•¨ìˆ˜ë¡œì¨ì˜ ëŒë‹¤ í•¨ìˆ˜**

```cpp
[]() -> void { cout << "Hello, World!\n"; }();
```

- êµ¬í˜„í• ê²Œ ì¡ë‹¤í•˜ê³  ë§ì•„ì§ˆë•Œ ì‚¬ìš©í•˜ë©´ ì¢‹ìŒ
- GUI ê´€ë ¨ í”„ë¡œê·¸ë˜ë°ì‹œ ë§ì´ ì‚¬ìš©í•¨


- `[]` lammda-introducer 
  - `[&]` ëŒë‹¤ í‘ì…˜ì´ ì •ì˜ëœ ì˜ì—­ì— `&` ë¥¼ ë„£ì–´ë†“ë©´ ë°–ì— ìˆëŠ”ê²ƒì„ ë ˆí¼ëŸ°ìŠ¤ë¡œ ê°€ì ¸ì˜´
    - `=` ì¹´í”¼
    - `this` í´ë˜ìŠ¤ ë©¤ë²„ ì •ì˜
    - `&ë³€ìˆ˜` 

___

**std::for_each**

```cpp
#include <algorithm> // for_each

vector<int> vec;    
vec.push_back(10); 
vec.push_back(20);

auto func2 = [](int val) {cout << val << "  "; };
std::for_each(vec.begin(), vec.end(), func2); 
```

- ì´ë ‡ê²Œ ì‚¬ìš©í•˜ë ¤ê³  ì‚¬ìš©í•˜ì§€ ì•Šê³  ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ë°”ë¡œë„£ì–´ ë²„ë ¤ ì‚¬ìš©í•¨

```cpp
std::for_each(vec.begin(), vec.end(), [](int val) {cout << val << "  "; });
```

**ëŒë‹¤ í•¨ìˆ˜ ë¦¬í„´íƒ€ì… ì„¤ì •**

```cpp
cout << []() -> int {return 1;} << enld;
```

- intíƒ€ì…ìœ¼ë¡œ ì„¤ì •

___

**std::function**

```cpp
auto func2 = [](int val) {cout << val << "  "; };	
std::function<void(int)> func3 = func2;	
func3(123);
```

- ì¼ì¢…ì˜ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì²´ê³„í™” ì‹œì¼œì¤€ê²ƒ
  - void ë¦¬í„´íƒ€ì…
  - int íŒŒë¼ë©”íƒ€ íƒ€ì…

- í•¨ìˆ˜ì˜ ê¸°ëŠ¥ì„ ë³€ìˆ˜ì²˜ëŸ¼ ì£¼ê³ ë°›ê³ í•¨

**std::bind**

```cpp
auto func = [](int val) {cout << val << "  "; };

std::function<void(void)> func2 = std::bind(func, 456);	

func2();  // 456 ì¶œë ¥
```

- íŒŒë¼ë©”íƒ€ íƒ€ì…ì„ ìë£Œí˜•ì„ ì“°ê³ ì‹¶ì§€ì•Šì„ë•Œ intë¥¼ bindí•˜ì—¬ ë„£ëŠ” ê²ƒ
- void íƒ€ì…ì¸ func2ì— intíƒ€ì…ì¸ func í•¨ìˆ˜ë¥¼ ë„£ì–´ì¤˜ì„œ bindí•˜ì—¬ì„œ ë„£ì„ìˆ˜ ìˆìŒ

___

**std::placeholders**

```cpp
#include <functional>
#include <iostream>
 
using namespace std;
 
int multiply(int a, int b)
{
    return a * b;
}
 
int main()
{
    auto func = std::bind(multiply, 5, placeholders::_1);
 
    for (int i = 0; i < 10; i++)
    {
        cout << "5 * " << i << " = " << func(i) << endl;
    }
    return 0;
}
```

- íŒŒë¼ë©”íƒ€ê°€ ì—¬ëŸ¬ê°œì¼ê²½ìš° ë„£ì–´ì£¼ëŠ”ê²ƒ

### **ğŸŒ± 19.2 C++ 17 í•¨ìˆ˜ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ë¦¬í„´ê°’ ë³€í™˜ í•˜ê¸°**

**ì˜›ë‚  tuple**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

tuple<int, int> my_func()
{ 
	return tuple<int, int>(123, 456); 
}

int main()
{
	tuple<int, int> result = my_func();
	cout << get<0>(result) << " " << get<1>(result) << endl;
}
```

- ë¦¬í„´ë°ì´í„° íƒ€ì…ì„ êµ¬ì¡°ì²´ë‚˜ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ìˆ˜ë„ ìˆìŒ
  - ë§¤ë²ˆ ë§Œë“¤ê¸° ê·€ì°®ìŒ
- tuple
  - ìˆ˜í•™ì ì˜ë¯¸: ì—¬ëŸ¬ê°œì˜ ë°ì´í„°ì˜ ìŒ

___

**í˜„ëŒ€ì  C++ tuple ì‚¬ìš©ë²•**

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto my_func()
{ 
  return tuple<int, int, int>(123, 456, 789); // ì˜›ë‚  ë°©ì‹
	return tuple(123, 456, 789); // C++ 17 ë¶€í„° ì‚¬ìš©ê°€ëŠ¥
}

int main()
{
	auto [a, b, c] = func();
	cout << a << " " << b << " " << c << "\n";
}
```

### **ğŸŒ± 19.3 std threadì™€ ë©€í‹°ì“°ë ˆë”© ê¸°ì´ˆ**

**Process**

- osê°€ ìš°ë¦¬ê°€ ì‘ì„±í•œ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰ì‹œí‚¬ë•Œ ê´€ë¦¬í•˜ëŠ” ë‹¨ìœ„
- í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ê´€ë¦¬í•¨


**multithreading**

- í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ê³  ê·¸í”„ë¡œê·¸ë¨ì´ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ë§Œë“¤ì–´ì„œ ì—¬ëŸ¬ê°œì˜ ì½”ì–´ë¥¼ ë™ì‹œì— í™œìš©í•´ íš¨ìœ¨ì„±ì„ ë†’ì´ëŠ” ë°©ë²•
- í•˜ë‚˜ì˜ cpuì— ì—¬ëŸ¬ê°œì˜ ì½”ì–´ê°€ ë“¤ì–´ìˆëŠ”ê²½ìš° ê·¸ì½”ì–´ë“¤ì„ í™œìš©í•´ì„œ ë™ì‹œì— ì—¬ëŸ¬ê°œì˜ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒ
- ì˜ˆì „ì—” cpuí•˜ë‚˜ì— ì½”ì–´ í•˜ë‚˜ê°€ ë“¤ì–´ìˆë˜ì‹œì ˆì—ëŠ” í•œë³´ë“œì— ì—¬ëŸ¬ê°œì˜ cpuë¥¼ ë„£ì–´ì„œ multithreadingì„ í–ˆì—ˆìŒ ë³´í†µ 2ê°œì •ë„ ê½‚ìœ¼ë©´ ë©”ëª¨ë¦¬ ì†ë„ì˜ í•œê³„ë•Œë¬¸ì— íš¨ìœ¨ì´ì¢‹ì§€ì•Šì•˜ìŒ
- **ë¶„ì‚°ì²˜ë¦¬:** multithreadingì‹œ íš¨ìœ¨ì„ ë†’ì´ê¸°ìœ„í•´ ë„¤íŠ¸ì›Œí¬ë¡œ ì—¬ëŸ¬ê°œì˜ pcë¥¼ ì—°ê²°ì‹œí‚¤ê³  ì—¬ëŸ¬ê°œì˜ pcì— ë“¤ì–´ìˆëŠ” ì½”ì–´ë“¤ì„ ì „ë¶€ ë™ì‹œì— í™œìš©í•˜ëŠ” ê²ƒ
  - pcê°€ ì „ë¶€ í©ì–´ì ¸ ìˆì–´ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í• ìˆ˜ ì—†ìŒ
  - í†µì‹ í• ë•Œ ì—¬ëŸ¬ê°€ì§€ ë¶€ê°€ì ì¸ ì˜¤ë²„í—¤ë“œê°€ ìƒê¸°ê¸°ë„ í•¨
- multithreadingì€ ì—¬ëŸ¬ê°œì˜ threadë“¤ì´ ë©”ëª¨ë¦¬ë¥¼ ê³µìœ í•¨
  - ìœ„í—˜í•˜ê¸°ë„í•¨
- multicore cpuì—ì„œ ìë™ìœ¼ë¡œ multithreadingìœ¼ë¡œ íš¨ìœ¨ì„ ë†’ì—¬ì£¼ëŠ”ê²ƒì´ ì•„ë‹ˆê³  multithreadingì„ í•˜ë„ë¡ í”„ë¡œê·¸ë˜ë°ì„ ì§ì ‘í•´ì•¼í•¨
- threadê°€ ì‹¤íƒ€ë˜ë¼ëŠ” ì˜ë¯¸ë¥¼ ê°–ê³ ìˆì–´ ì‹¤ì„ ì´ì™¸ì— ì­ˆê¸€ì­ˆê¸€í•œ ì„ ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²½ìš°ë„ ìˆìŒ

<br>


**Process ìˆ˜í–‰ ìˆœì„œ**

1. ë©”ì¸ í•¨ìˆ˜ë¡œ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë¨ ê·¸ ë©”ì¸í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³ ìˆëŠ” threadë¥¼ ë©”ì¸ thread,ì£¼ëœ thread ë¼ê³  ë¶€ë¦„
2. ë¬´ê±°ìš´ ì‘ì—…ì„ ì‹œì‘í• ë•Œ ì—¬ëŸ¬ê°œì˜ threadë“¤ì´ ì¼ì„ ë‚˜ëˆ ì„œ ì‘ì—…í•´ì•¼í• ë•Œ multithreadingìœ¼ë¡œ í”„ë¡œê·¸ë˜ë°ì„ í•´ë‘ê³  main threadê°€ ì—¬ëŸ¬ê°œì˜ threadë¥¼ ì‹¤í–‰ì„ ì‹œí‚´
  - ë¶€ê°€ì ì¸ threadë¥¼ ì‹¤í–‰ì‹œí‚¬ë•Œ ìˆœì°¨ì ìœ¼ë¡œ ì‹œí‚¤ì§€ë§Œ ë™ì‹œì— ì‹œí‚¨ë‹¤ê³  í•˜ê¸°ë„í•¨
  - ìì‹ thread ì—ì„œ ë˜ë‹¤ë¥¸ ìì‹ thread ë¥¼ ì‹¤í–‰ì‹œí‚¬ìˆ˜ë„ ìˆìŒ
3. ìì‹ thread ëŠ” main threadê°€ ì–´ë–¤ ì‘ì—…ì„ í•˜ë˜ì§€ ê°„ì— ë³„ë„ì˜ í”„ë¡œê·¸ë¨ì¸ê²ƒ ì²˜ëŸ¼ ì‘ë™ì„ í•¨ 
4. ìì‹ threadê°€ ì‘ì—…ì„ ë§ˆì¹ ë•Œ main threadê°€ ê¸°ë‹¤ë¦¬ê³ ìˆìŒ
   - ìì‹ threadê°€ ì‘ì—…ì´ ëë‚˜ëŠ” ì‹œì ì„ main threadëŠ” ì•Œì§€ ëª»í•¨ 
5. ì‘ì—…ì´ ëë‚˜ë©´ í”„ë¡œê·¸ë¨ì´ ëë‚¨

___

![ìº¡ì²˜](https://user-images.githubusercontent.com/90514882/167283762-8b9fbad2-4859-4baf-bbfe-7e3a2c30c26d.PNG)


- **ì½”ì–´:** ë¬¼ë¦¬ì  ì½”ì–´ì˜ ê°¯ìˆ˜
- **ë…¼ë¦¬ í”„ë¡œì„¸ì„œ:** hyper threading ì´ë¼ëŠ” ê¸°ìˆ ë¡œ ë¬¼ë¦¬ì ì½”ì–´ì˜ 2ë°°ì— í•´ë‹¹í•˜ëŠ” í”„ë¡œì„¸ì„œë¥¼ ê°€ì§€ê³ ìˆëŠ”ê²ƒ ì²˜ëŸ¼ ì‚¬ìš©í• ìˆ˜ ìˆê²Œí•´ì¤Œ
- **ì´ìš©ë¥ :** í˜„ì¬ cpuê°€ ì‚¬ìš©ë˜ê³  ìˆëŠ” ë¹„ìœ¨
  - ë…¼ë¦¬ í”„ë¡œì„¸ì„œë¥¼ ëª¨ë‘ ê³ ë ¤í•œ ì»´í“¨íŒ… ëŠ¥ë ¥ì„ ë³´ì—¬ì£¼ëŠ”ê²ƒ
- **í”„ë¡œì„¸ì„œ:** ë©”ì¸ í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œì¼œì£¼ëŠ” osê°€ ë°°ì •í•´ì£¼ëŠ” ì¼ì„í•˜ëŠ” ì¡´ì¬
- **ìŠ¤ë ˆë“œ:** í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•´ì„œ ì¼ì„ í•¨

<br>

- main í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì‹¤í–‰ì´ëœë‹¤
- í”„ë¡œì„¸ìŠ¤ í•˜ë‚˜ê°€ ì°¨ì§€í•˜ëŠ” ê²ƒì€ ê¸°ë³¸ì ìœ¼ë¡œ cpuì˜ ë…¼ë¦¬ í”„ë¡œì„¸ì„œ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•¨

___

**thread**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	cout << std::thread::hardware_concurrency() << endl; // ë…¼ë¦¬ í”„ë¡œì„¸ì„œ ê°¯ìˆ˜
	cout << std::this_thread::get_id() << endl; // thread id

  // multi thread
	std::thread t1 = std::thread([] {
	cout << std::this_thread::get_id() << '\n';
	//while (true);
	});
	t1.join();		// t1ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤.
}
```

- `hardware_concurrency()` ì½”ì–´ê°¯ìˆ˜ ë¥¼ ë°›ì•„ì˜¬ìˆ˜ ìˆìŒ
- `std::this_thread::get_id()` ë©”ì¸í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ê³ ìˆëŠ” thread this_threadì˜ idë¥¼ ì¶œë ¥í•´ì¤Œ
- ë©”ì¸í•¨ìˆ˜ê°€ ë©”ì¸ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•˜ê³  `std::thread t1 = std::thread([] {cout << std::this_thread::get_id() << '\n';});` ì•ˆì—ì„œ ìì‹ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰í•¨ ìì‹ìŠ¤ë ˆë“œê°€ ëë‚œë’¤ì— ë©”ì¸ ìŠ¤ë ˆë“œì™€ í†µì‹ í•´ì•¼í•˜ëŠ”ë° í†µì‹ í•˜ê¸° ì „ì— ë©”ì¸ í•¨ìˆ˜ê°€ ëë‚˜ë²„ë ¤ ì—ëŸ¬ê°€ ë°œìƒí•¨ 
  - ì´ë¥¼ ë°©ì§€í•˜ê¸°ìœ„í•´ `t1.join()` ë¥¼ ì‚¬ìš©í• ìˆ˜ ìˆìŒ

___

**ì—¬ëŸ¬ê°œì˜ thread ì‚¬ìš©í•˜ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	std::thread t1 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t2 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t3 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	std::thread t4 = std::thread([] {
		cout << std::this_thread::get_id() << '\n';
     while(true);
	});

	t1.join();
	//t2.join();
	//t3.join();
	//t4.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
463276042468
```
- t1, t2, t3, t4 ìŠ¤ë ˆë“œê°€ ê°ê° ë³‘ë ¬ë¡œ ë™ì‹œì— ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—(ë©€í‹°ìŠ¤ë ˆë”©) idê°€ ì¤‘êµ¬ë‚œë°©ìœ¼ë¡œ ì„ì—¬ ì¶œë ¥ë¨
- coutì´ ê°ë‹¹ì„ ëª»í•´ì„œ ê¼¬ì¸ê²ƒ

___

**vectorì— thread ë„£ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	const int num_pro = std::thread::hardware_concurrency();

	vector<std::thread> my_threads;
	my_threads.resize(num_pro);

  for (auto & e : my_threads)
  {
      e = std::thread([](){
				cout << std::this_thread::get_id() << endl;
				while(true){}
          });
  }
		
	for (auto & e : my_threads)
		e.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
2438421972
9364
17412
20952
13428

9864
16900
20628
15592
4840
2584
4516
13492
20320
22612




```

- ìœ„ ì˜ˆì œì½”ë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë©´ cpuì‚¬ìš©ë¥  100í¼ë¥¼ ì‚¬ìš©í•˜ê²Œë¨
  - ì¤‘ê°„ì¤‘ê°„ ê¸€ìê°€ ê¹¨ì§
- multi thread ë¥¼ ê³µë¶€í•˜ê²Œë˜ë©´ num_threadì™€ ì‹¤ì œ ìƒì„±í•˜ëŠ” thread ê°¯ìˆ˜ë¥¼ ì‹ ê²½ì¨ì•¼í•¨
- ì¼ë°˜ì ìœ¼ë¡œ ìƒì„±í•˜ëŠ” thread ê°¯ìˆ˜ì™€ í•˜ë“œì›¨ì–´ í”„ë¡œì„¸ì„œ ê°¯ìˆ˜ë¥¼ ë§ì¶”ëŠ”ê²ƒì´ ì¼ë°˜ì ì„ 
- ëª¨ë“ ë¬¸ì œë¥¼ ë³‘ë ¬ë¡œ ë‹¤ ì‚¬ìš©í• ìˆœì—†ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë©€í‹°ìŠ¤ë ˆë”©ì€ ìœ ìš©í•¨
  
___

```cpp
#include <iostream>
#include <thread>
#include <mutex>		// semaphoreëŠ” ì—†ìŒ
using namespace std;

int main()
{
	auto work_func = [](const string & name)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	work_func("JackJack");
	work_func("Dash");
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
JackJack 5172 is working 0
JackJack 5172 is working 1
JackJack 5172 is working 2
JackJack 5172 is working 3
JackJack 5172 is working 4
Dash 5172 is working 0
Dash 5172 is working 1
Dash 5172 is working 2
Dash 5172 is working 3
Dash 5172 is working 4

```

- `std::this_thread::sleep_for(std::chrono::milliseconds(100));` ì‰¬ëŠ” ì‹œê°„ ë„£ê¸°
  - ì‹¤ì œë¡œëŠ” í•  ì‘ì—…ì„ ë„£ëŠ” ë¶€ë¶„
- `work_func("JackJack");` ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ `work_func("Dash");` ëŠ” ë†€ê³ ìˆëŠ” í˜•íƒœì„
  - multi threadingì´ ì•„ë‹ˆë©° ë¹„íš¨ìœ¨ì ì„

**multi threadingìœ¼ë¡œ ë°”ê¾¸ê¸°**

```cpp
#include <iostream>
#include <thread>

using namespace std;

int main()
{
	auto work_func = [](const string& name, const int j)
	{
		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			cout << name << " " << j << " " << std::this_thread::get_id() << " is working " << i << endl;
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack", 123);
	std::thread t2 = std::thread(work_func, "Dash", 456);

	t1.join();
	t2.join();
}
```

**ì¶œë ¥ê²°ê³¼**

```cpp
JackJack Dash 456 23564 is working 0123 16988 is working 0

JackJack 123 16988 is working 1
Dash 456 23564 is working 1
JackJack 123 16988 is working 2
Dash 456 23564 is working 2
Dash 456 23564 is working 3
JackJack 123 16988 is working 3
JackJack 123 16988 is working 4
Dash 456 23564 is working 4

```

- ë©€í‹°ì“°ë ˆë”©ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ë™ì‹œì— ì¼ì„í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•¨
- ì‘ì—…ì€ ë™ì‹œì—í•˜ëŠ”ë° ì¶œë ¥ë„ ë™ì‹œì—ë‚˜ì™€ì„œ ì§€ì €ë¶„í•¨

**mutex**

```cpp
#include <iostream>
#include <thread>
#include <mutex> 

using namespace std;

mutex mtx; // ì„ ì–¸

int main()
{	

	auto work_func = [](const string& name)
	{

		for (int i = 0; i < 5; ++i)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));

			mtx.lock();
			cout << name << " " << std::this_thread::get_id() << " is working " << i << endl;
			mtx.unlock();
		}
	};
	std::thread t1 = std::thread(work_func, "JackJack");
	std::thread t2 = std::thread(work_func, "Dash");

	t1.join();
	t2.join();
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
JackJack 4272 is working 0
Dash 12944 is working 0
Dash 12944 is working 1
JackJack 4272 is working 1
JackJack 4272 is working 2
Dash 12944 is working 2
Dash 12944 is working 3
JackJack 4272 is working 3
JackJack 4272 is working 4
Dash 12944 is working 4

```

- ì‘ì—…ì€ ë™ì‹œì—í•˜ëŠ”ë° ì¶œë ¥ë„ ì¶œë ¥ì„ ìˆœì°¨ì ìœ¼ë¡œ í•´ì¤„ìˆ˜ìˆìŒ
- mutex ëŠ” **mutual exclusion** ë¥¼ ëœ»í•¨ 
  - ìƒí˜¸ë°°ì¬ ë¼ëŠ”ëœ»
- ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì´ë¶€ë¶„ì€ ê±´ë“¤ì´ì§€ë§ê³  í•œë²ˆì— í•˜ë‚˜ì˜ìŠ¤ë ˆë“œë¥¼ ì‹¤í–‰ì‹œí‚¤ë¼ëŠ” ëœ»
- ë‘ ìŠ¤ë ˆë“œì¤‘ ì‘ì—…ì„ ë¨¼ì € ë§ˆì¹œ ìŠ¤ë ˆë“œê°€ mtx.lock ì— ì™€ì„œ ì ê¶ˆë²„ë¦¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ëª»ë“¤ì–´ì˜¤ê²Œë¨ ê·¸ í›„ ì¶œë ¥ í›„ lockì„ í’€ê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ëŒ€ê¸°ë¥¼ í•˜ê³ ìˆë‹¤ê°€ ë“¤ì–´ì˜¤ê³  ë°˜ë³µí•˜ëŠ” ê³¼ì •ì„
- `mtx.lock();` ì„í•˜ê³  `mtx.unlock();` ì„ ì•ˆí•´ë²„ë¦¬ë©´ ë¬¸ì œê°€ ë°œìƒí•¨
- ë©€í‹°ìŠ¤ë ˆë“œëŠ” ì„œë¡œ ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ì—ì„œ ë¬¸ì œë¥¼ ì–´ë–»ê²Œ í•´ê²°í•˜ëŠëƒê°€ ì¤‘ìš”í•¨


### **ğŸŒ± 19.4 ë ˆì´ìŠ¤ ì»¨ë””ì…˜, std::atomic, std::scoped_lock**

- Race Condition: ë™ì¼í•œ ë°ì´í„°ë¥¼ ì„œë¡œ ë‹¤ë¥¸ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë“¤ì´ ì ‘ê·¼í•˜ëŠ” ê³¼ì •ì—ì„œ ìƒê¸°ëŠ” ë¬¸ì œ

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	int shared_memory(0);

	auto count_func = [&](){
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();
	
	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
After
1996

```

- ì‹¤ì „ì—ì„œëŠ” ì—¬ëŸ¬ê°œì˜ ìŠ¤ë ˆë“œê°€ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ê°€ int ì •ìˆ˜í˜• í•˜ë‚˜ë¿ ì•„ë‹ˆë¼ í›¨ì”¬ë” ì»¤ì§ˆìˆ˜ìˆìŒ
- `sleep_for` ê°€ì—†ìœ¼ë©´ ì¼ì„ ë‹¨ë²ˆì— ì²˜ë¦¬í•´ì„œ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ì•Šì„ìˆ˜ë„ ìˆìŒ
- 2000 ì´ ì¶œë ¥ë˜ì•¼í•˜ëŠ”ë° ì—‰ëš±í•œ ê°’ì´ ë‚˜ì˜¤ëŠ” ì´ìœ 
  - ë‘˜ë‹¤ 1000ë²ˆì”© ë”í•˜ê¸´í•¨
  1. cpuë¡œ shared_memory ë°ì´í„°ë¥¼ ê°€ì ¸ì˜´
  2. cpuë¡œ shared_memory ë°ì´í„°ì— 1ì„ ë”í•¨
  3. 1ì„ ë”í•œ shared_memoryê°’ì„ ë‹¤ì‹œ shared_memoryë³€ìˆ˜ë¡œ ë³´ë‚´ ë®ì–´ì”Œì›€
  - cpuë¡œ ì½ì–´ë“¤ì¸ ì‚¬ì´ì— ìŠ¤ë ˆë“œ 2ê°€ ì¬ë¹¨ë¦¬ ê°’ì„ë°”ê¿”ë²„ë¦°ê²ƒ

<br>

- `std::this_thread::sleep_for(std::chrono::microseconds(1));` ì´ê²ƒì„ ì§€ì›Œë²„ë¦¬ë©´ 2000ì´ ê¹”ë”í•˜ê²Œ ì¶œë ¥ë¨
  - ë¬¸ì œê°€ ì‚¬ë¼ì§„ê²ƒì´ ì•„ë‹˜ 1000ë²ˆ ë”í•˜ëŠ”ê²Œ ìˆœì‹ê°„ì— ì¼ì–´ë‚˜ t1ì´ ëë‚œë’¤ì— t2ê°€ ì‹¤í–‰ì´ë˜ì–´ ê¹”ë”í•˜ê²Œ ì¶œë ¥ì´ëœê²ƒ ì¦‰, ë³‘ë ¬ì²˜ë¦¬ê°€ ëœê²ƒì´ ì•„ë‹˜
___

**ë ˆì´ìŠ¤ ì»¨ë””ì…˜ í•´ê²° ë°©ë²• 1 atomic**

```cpp
#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

int main()
{
	atomic<int> shared_memory(0);
	
	auto count_func = [&]()
	{
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));
			shared_memory++;		// í˜¹ì€ shared_memory.fetch_add(1);	
		}
	};

	std::thread t1 = std::thread(count_func);
	std::thread t2 = std::thread(count_func);

	t1.join();
	t2.join();

    cout << "After" << endl;
	cout << shared_memory << '\n';
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
After
2000

```

- atomic: ì›ì, ìª¼ê°¤ìˆ˜ì—†ë‹¤ ë¼ëŠ”ëœ»
  - ìŠ¤ë ˆë“œ ê³„ì‚° ì²˜ë¦¬ë°©ë²• 3ë‹¨ê³„ë¥¼ í•œë°©ì— í•˜ê²Œë” ë°”ê¾¼ê²ƒ
- `shared_memory++;` ì˜ `++` ëŠ” ì¦ê°ì—°ì‚°ìê°€ ì•„ë‹Œ atomic<int> ì˜ ì¦ê°ì—°ì‚°ìë¥¼ ì˜¤ë²„ë¡œë”©ì´ ë˜ì–´ìˆëŠ”ê²ƒ 
- ë‹¨ì ìœ¼ë¡œëŠ” `fetch_add()`, `++` ê·¸ëƒ¥ ì¦ê°ì—°ì‚°ì ë“±ë³´ë‹¤ ì¡°ê¸ˆ ëŠë¦¼
  - í•„ìš”í•œ ê³³ì—ë§Œ ì‚¬ìš©í•´ì•¼í•¨

___

**ë ˆì´ìŠ¤ ì»¨ë””ì…˜ í•´ê²° ë°©ë²• 2 mutex**

```cpp
#include <iostream>
#include <mutex>
#include <atomic>
#include <thread>

using namespace std;

mutex mtx;

int main()
{
	int shared_memory(0);

	auto count_func = [&]() {
		for (int i = 0; i < 1000; ++i)
		{
			std::this_thread::sleep_for(std::chrono::microseconds(1));

			/*mtx.lock();*/
			std::lock_guard lock(mtx);
			std::scoped_lock lock(mtx); // C ++ 17
			shared_memory++;
			/*mtx.unlock();*/
		}
	};

	thread t1 = thread(count_func);
	thread t2 = thread(count_func);

	t1.join();
	t2.join();

	cout << "After" << endl;
	cout << shared_memory << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
After
2000

```

- mutexë¥¼ ì‚¬ìš©í•˜ì—¬ `lock()` ì„ ê±¸ë©´ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼í•˜ëŠ”ê²ƒì´ ë˜ì–´ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ ë°©ì§€í• ìˆ˜ ìˆìŒ
- unlockì„ ê¹Œë¨¹ì„ìˆ˜ë„ìˆê³  ì˜ˆì™¸ì²˜ë¦¬ì‹œ unlockë¥¼ ê±´ë„ˆë›°ëŠ” ë“± ì‹¤ìˆ˜ë¥¼ í•  ê°€ëŠ¥ì„±ì´ ìˆìŒ
  - ì´ë•Œ ì‚¬ìš©í•˜ëŠ”ê²ƒì´ lcokguardê°€ ìˆìŒ
  - `std::lock_guard lock(mtx);` 
    - lock ì´ë¼ëŠ” ë³€ìˆ˜ê°€ `{}` ì•ˆì— ì„ ì–¸ì´ ë˜ì–´ `{}`ì´ ëë‚ ë•Œ ì¢…ë£Œë˜ê¸° ë•Œë¬¸ì— unlockì„ í•´ì¤„í•„ìš”ê°€ ì—†ìŒ
- `std::scoped_lock lock(mtx);`
  - C++ 17ì— ë„ì…ëœ ê¸°ëŠ¥ lock_guard ë³´ë‹¤ ì§„ë³´ëœ ê¸°ëŠ¥ ì´ê²ƒì„ ì‚¬ìš©í•˜ëŠ”ê²ƒì„ ë” ê¶Œì¥í•˜ëŠ” í¸ì´ë¼ê³  í•¨

### **ğŸŒ± 19.5 ì‘ì—… ê¸°ë°˜ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°**

- ì‘ì—… Task
- ë¹„ë™ê¸° async
- future, promise

___

- `#include <future>`
  - async,Future,Promise ë“±ì„ ì‚¬ìš©í• ìˆ˜ìˆìŒ

**multi-threading**

```cpp
{
	int result;
	std::thread t([&] {result = 1 + 2; });  // ëª¨ë“  ë°”ê¹¥ ë³€ìˆ˜ë¥¼ ë ˆí¼ëŸ°ìŠ¤ë¡œ ë°›ìœ¼ë¯€ë¡œ result ê°’ì´ ë³€í™”í•œë‹¤.
	t.join();

	cout << result << '\n';  
}
```

- ìµœê·¼ì—ëŠ” ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼í•˜ëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ë°©ì‹ì„ ì„ í˜¸í•˜ê¸°ë„í•¨
- ê¸°ë³¸ì ìœ¼ë¡œ ìŠ¤ë ˆë“œë¡œë¶€í„° ê°’ì„ ì£¼ê±°ë‹ˆ ë°›ê±°ë¦¬ í•˜ê¸°ìœ„í•´ì„  ìŠ¤ì½”í”„ë¥¼ ë„“ê²Œ ì¡ê³  ê·¸ ìŠ¤ì½”í”„ ë³€ìˆ˜ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë“¤ì´ ê³µìœ ë¥¼ í•˜ëŠ”ê²ƒì´ ì¼ë°˜ì ì„
- ìŠ¤ë ˆë“œ ìœ„ì£¼ë¡œ í”„ë¡œê·¸ë˜ë°ì´ ëœê²ƒ
- ìŠ¤ë ˆë“œê°€ ëª‡ê°œ ìƒê¸°ê³  ê·¸ ìŠ¤ë ˆë“œê°€ ê°ê° ì–´ëŠì¼ì„ í•˜ëŠ”ì§€ ì§€ì •í•´ì£¼ëŠ”ê²ƒ

___

**task-based parallellism**

<br>

**async**

```cpp
{
std::future<int> future = std::async([] {return (1 + 2);});  //  auto future ì“°ëŠ”ê²Œ ë” ê°„í¸
cout << future.get() << '\n';  // 3 ì¶œë ¥
}
```

- **async:** Asynchronous ë¹„ë™ê¸°ì ì´ë‹¤ ë¼ëŠ”ëœ»
- return ê°’ì„ futureì´ ë°›ëŠ”ê²ƒ ì²˜ëŸ¼ í”„ë¡œê·¸ë˜ë° í•œê²ƒ
- async ëŠ” ìŠ¤ë ˆë“œë¥¼ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì´ ì—¬ëŸ¬ê°œìˆìŒ
  - ë³´í†µ threadë³´ë‹¤ asyncë¥¼ ë” ì„ í˜¸í•¨
  - multi-threading ë³´ë‹¤ task-based parallellism ë¥¼ ë” ì„ í˜¸í•¨
- ì–´ë–¤ ì‘ì—…ì„ í• ê²ƒì¸ê°€ ìœ„ì£¼ í”„ë¡œê·¸ë˜ë° return ì„ í•´ì£¼ëŠ” ê°’ì„ í˜„ì¬ ë°›ì„ìˆ˜ ìˆëŠ” ê²ƒì´ ì•„ë‹˜
  - ì¼ë°˜ì ì¸ returnê³¼ ë‹¤ë¦„ ì‘ì—…ì‹œê°„ ì´ ì˜¤ë˜ ê±¸ë ¤ ë‚˜ì¤‘ì— ë°›ì„ìˆ˜ë„ìˆìŒ 
- asyncê°€ ì‹¤í–‰ë˜ëŠ” taskì™€ ì •í™•íˆ ê²°í•©ì´ ë˜ëŠ” êµ¬ì¡°ì„
- `future.get()` 
  - ë¦¬í„´ê°’ì´ intê°€ ë‚ ë¼ì˜´
  - returnê°’ì´ get() ê°’ìœ¼ë¡œ ë‚˜ì˜¤ëŠ”ê²ƒ
  - ë¦¬í„´ê°’ì„ ë°›ê¸° ì „ì´ë¼ë©´ asyncê°€ ì‘ì—…ì„ ë§ˆì¹˜ê³  ê°’ì„ return í•´ì¤„ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¼


**promsise**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	// future and promsise
	{	
		std::promise<int> prom;
		auto future = prom.get_future();

		auto t = std::thread([](std::promise<int>&& prom)
		{
            prom.set_value(1 + 2);
        }, std::move(prom));
		
		cout << future.get() << endl;
		t.join();
	}
}
```

- future ë¥¼ aysunc ì´ì™¸ì— threadì—ì„œë„ ì‚¬ìš©í• ìˆ˜ ìˆìŒ
- promsiseëŠ” async ì²˜ëŸ¼ future ë¥¼ ì£¼ì§€ì•Šê³  ìê¸° threadë¥¼ ì¤Œ futureë¥¼ ë°›ì„ìˆ˜ ìˆëŠ” ì¡´ì¬ê°€ í•„ìš”í•´ promiseë¥¼ ê±°ì³ê°€ëŠ”ê²ƒ
- promì— set_value() ë¥¼ í†µí•´ì„œ ê°’ì„ ë°›ì„ë•Œê¹Œì§€ futureê°€ ê³„ì† ê¸°ë‹¤ë¦¼
- thread ì´ê¸° ë•Œë¬¸ì— `t.join();` ì´í•„ìš”í•¨

___

**async ë™ì‹œì‹¤í–‰**

```cpp
#include <iostream>
#include <future>
#include <thread>
using namespace std;

int main()
{
	auto f1 = std::async([] {
		cout << "Async 1 start\n";
		this_thread::sleep_for(std::chrono::seconds(2)); // 2ì´ˆ ëŒ€ê¸°
		cout << "Async 1 end\n";
		});
	auto f2 = std::async([] {
		cout << "Async 2 start\n";
		this_thread::sleep_for(std::chrono::seconds(1)); // 1ì´ˆ ëŒ€ê¸°
		cout << "Async 2 end\n";
		});

	cout << "Main function\n";  // ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰

}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Main function
Async 1 start
Async 2 start
Async 2 end
Async 1 end

```

- asyncëŠ” threadì™€ ë‹¬ë¦¬ joinì´ ì—†ìŒ.

**thread ë¡œ ë°”ê¾¸ê¸°**

```cpp
{
auto f1 = std::thread([] {
	cout << "Async 1 start\n";
	this_thread::sleep_for(std::chrono::seconds(2)); // 2ì´ˆ ëŒ€ê¸°
	cout << "Async 1 end\n";
});
auto f2 = std::thread([] {
	cout << "Async 2 start\n";
	this_thread::sleep_for(std::chrono::seconds(1)); // 1ì´ˆ ëŒ€ê¸°
	cout << "Async 2 end\n";
});

cout << "Main function\n";  // ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰

f1.join();
f2.join();

}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Main function
Async 2 start
Async 1 start
Async 2 end
Async 1 end

```

### **ğŸŒ± 19.6 ë©€í‹°ì“°ë ˆë”© ì˜ˆì œ (ë°±í„° ë‚´ì  ê³„ì‚°)**

**ë°±í„° ë‚´ì  ê³„ì‚° ì „ì²´ì½”ë“œ**

```cpp
#include <iostream>
#include <chrono>
#include <mutex>	
#include <utility>
#include <vector>	
#include <atomic>
#include <numeric>		// std::inner_product
#include <random>
#include <execution>	// parallel execution
#include <future>
#include <thread>

using namespace std;

mutex mtx;

void dotProductNaive(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

void dotProductLock(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	//cout << "Thread Start" << endl;
	for (unsigned int i = start; i < end; ++i)
	{
		std::scoped_lock lock(mtx);
		sum += (v0[i] * v1[i]);
	}
	//cout << "Thread End" << endl;
}

void dotProductAtomic(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, atomic<unsigned long long> & sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

auto dotProductFuture(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end)
{
	int sum = 0;
	for (unsigned int i = start; i < end; ++i)
		sum += (v0[i] * v1[i]);
	return sum;
}


int main()
{
	const long long numData = 100'000'000;
	const unsigned int numThread = 4;
	// thread ê°œìˆ˜ ëŠ˜ë¦°ë‹¤ê³  degree of multithreadingì´ ë†’ì•„ì§€ì§€ëŠ” ì•ŠìŒ

	vector<int> vec0, vec1;
	vec0.reserve(numData);
	vec1.reserve(numData);

	std::random_device seed;
	std::mt19937_64 makerand(seed());
	std::uniform_int_distribution<> range(1, 10);

	for (long long i = 0; i < numData; ++i)
	{
		vec0.push_back(range(makerand));
		vec1.push_back(range(makerand));
	}

	cout << "ì‹¤í—˜ 1ë²ˆ - std::inner_product\n";
	{
		const auto sta = std::chrono::steady_clock::now();		// ì‹œê°„ ì¸¡ì • ì‹œì‘
		const auto sum = std::inner_product(vec0.begin(), vec0.end(), vec1.begin(), 0ull);
		// ë‘ ë²¡í„°ì˜ ê°œìˆ˜ê°€ ê°™ë‹¤ê³  ê°€ì •í•˜ë¯€ë¡œ vec1ì€ beginë§Œ ìˆì–´ë„ ë˜ë©° ullì€ unsigned long longì˜ ì•½ì
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;		

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 2ë²ˆ - Naive\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductNaive, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 3ë²ˆ - Lockguard\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		unsigned long long sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 4ë²ˆ - Atomic\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		atomic<unsigned long long> sum = 0;

		vector<std::thread> threads;
		threads.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t] = std::thread(dotProductAtomic, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
		for (unsigned int t = 0; t < numThread; ++t)
			threads[t].join();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 5ë²ˆ - Future\n";
	{
		const auto sta = std::chrono::steady_clock::now();

		unsigned long long sum = 0;

		vector<std::future<int>> futures;
		futures.resize(numThread);

		const unsigned int numPerThread = numData / numThread;
		for (unsigned int t = 0; t < numThread; ++t)
			futures[t] = std::async(dotProductFuture, std::ref(vec0), std::ref(vec1),
				t * numPerThread, (t + 1) * numPerThread);
		for (unsigned int t = 0; t < numThread; ++t)
			sum += futures[t].get();
		
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}
	// TODO : Futureì˜ divide and conquer ë°©ì‹ì€ threadì—ì„œë„ êµ¬í˜„í•´ë³´ì.
	// async ëŒ€ì‹ ì— threadì™€ promiseë¥¼ ì‚¬ìš©í•´ì„œ futureì„ ì‚¬ìš©í•´ë³´ì.
	
  cout << "ì‹¤í—˜ 6ë²ˆ - promise\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		
		vector<std::promise<int>> prom;
		vector<std::future<int>> future;
		vector<std::thread> threads;
		prom.resize(numThread);
		future.resize(numThread);
		threads.resize(numThread);
		
		unsigned long long sum(0);
		unsigned numPerThread = numData / numThread;
		for (unsigned i = 0; i < numThread; ++i)
		{
			future[i] = prom[i].get_future();
			unsigned long long tempSum(0);
			threads[i] = std::thread([&](std::promise<int>&& prom)
				{
					std::scoped_lock lock2(mtx);
					
					for (unsigned int j = 0; j < numPerThread; ++j)
						tempSum += (vec0[j] * vec1[j]);
					prom.set_value(tempSum);
				}, std::move(prom[i]));
			threads[i].join();
		}
		for (unsigned int t = 0; t < numThread; ++t)
			sum += future[t].get();

		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}

	cout << "ì‹¤í—˜ 7ë²ˆ - std::transform_reduce\n";
	{
		const auto sta = std::chrono::steady_clock::now();
		const auto sum = std::transform_reduce(std::execution::par, vec0.begin(), vec0.end(), vec1.begin(), 0ull);
		const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

		cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
		cout << "ê²°ê³¼ê°’ = " << sum << '\n';
		cout << '\n';
	}
}
```

___

**main í•¨ìˆ˜**

```cpp
using namespace std;

mutex mtx;

int main()
{
	const long long numData = 100'000'000;
	const unsigned int numThread = 4;

	vector<int> vec0, vec1;
	vec0.reserve(numData);
	vec1.reserve(numData);

	std::random_device seed;
	std::mt19937_64 makerand(seed());
	std::uniform_int_distribution<> range(1, 10);

	for (long long i = 0; i < numData; ++i)
	{
		vec0.push_back(range(makerand));
		vec1.push_back(range(makerand));
	}
```

- ë‚´ì : ê¸°í•˜í•™ ë‹·í”„ë¡œë•íŠ¸ ì™€ ê°™ì€ê²ƒ ì•ˆì˜ ì›ì†Œê°€ ë§ì„ê²½ìš°ì—ëŠ” ë‚´ì ì´ë¼ê³  ë¶€ë¦„
- 2,3ì°¨ì› vector ë¼ë¦¬ì˜ ë‚´ì ì„ ë‹· í”„ë¡œë•íŠ¸ë¼ê³  ë¶€ë¦„ 
- ìŠ¤ë ˆë“œë¥¼ ë§ì´ì“´ë‹¤ê³  ë©€í‹°ìŠ¤ë ˆë”© íš¨ìœ¨ì´ ë†’ì•„ ì§€ì§„ì•ŠìŒ
- 1ì–µê°œì˜ ëœë¤ ì›ì†Œë¥¼ ê°–ê³ ìˆëŠ” vector ë‘ê°œë¥¼ ë§Œë“ ê²ƒ

___

**inner_product**

```cpp
cout << "ì‹¤í—˜ 1ë²ˆ - std::inner_product\n";
{
	const auto sta = std::chrono::steady_clock::now();		// ì‹œê°„ ì¸¡ì • ì‹œì‘
	const auto sum = std::inner_product(vec0.begin(), vec0.end(), vec1.begin(), 0ull);
	// ë‘ ë²¡í„°ì˜ ê°œìˆ˜ê°€ ê°™ë‹¤ê³  ê°€ì •í•˜ë¯€ë¡œ vec1ì€ beginë§Œ ìˆì–´ë„ ë˜ë©° ullì€ unsigned long longì˜ ì•½ì
	const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

	cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
	cout << "ê²°ê³¼ê°’ = " << sum << '\n';
	cout << '\n';
}
```

- `#include <numeric>` 
  - `std::inner_product`
- vec1ì€ `begin()` ë§Œ ìˆìœ¼ë©´ë¨ ë‘ê°œì˜ ê°¯ìˆ˜ê°€ ê°–ë‹¤ê³  ê°€ì •í•˜ê¸° ë•Œë¬¸ì„
- auto ì—ì„œ `0ull` ì„ ë„£ì–´ì¤¬ê¸° ë•Œë¬¸ì— unsigned long long ìœ¼ë¡œ í˜•ë³€í™˜ì„ í•´ì¤Œ
- `now()` ê³„ì‚° ì‹œê°„ ì‹œì‘
- `dur.count()` ê³„ì‚° ì¢…ë£Œ ì‹œê°„ ì¶œë ¥
- ë³‘ë ¬ì²˜ë¦¬ë¥¼ í• ë•ŒëŠ” ì‚¬ì†Œí•œ ì‹¤ìˆ˜ë¡œ ê²°ê³¼ê°€ ë‹¤ë¥´ê²Œ ë‚˜ì˜¬ê²½ìš°ê°€ ìˆìŒ ë©€í‹°ì“°ë ˆë”© í”„ë¡œê·¸ë˜ë°ì‹œ ì •ë‹µì„ ê³„ì‚°í•˜ê³  ê·¸ê²ƒê³¼ ë¹„êµí•˜ê³  í¼í¬ë¨¼ìŠ¤ë¥¼ ë¹„êµí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ì—…í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ


___

**ìˆœì§„í•œ ë©€í‹° ì“°ë ˆë”©**

```cpp
void dotProductNaive(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

...

unsigned long long sum = 0;

vector<std::thread> threads;
threads.resize(numThread);

const unsigned int numPerThread = numData / numThread;

for (unsigned int t = 0; t < numThread; ++t)
	threads[t] = std::thread(dotProductNaive, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

for (unsigned int t = 0; t < numThread; ++t)
	threads[t].join();


const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
cout << "ê²°ê³¼ê°’ = " << sum << '\n';
cout << '\n';
```

- numPerThread ì„ ë”±ë–¨ì–´ì§€ê²Œ ê³„ì‚°í•˜ê±°ë‚˜ ë‚¨ì€ìˆ˜ë¥¼ ëª‡ëª‡ê°œì˜ ìŠ¤ë ˆë“œì—ê²Œ ì¼ì„ ì‹œí‚¤ëŠ”ë“±ìœ¼ë¡œ ì²˜ë¦¬í•´ì•¼í•¨
- ìŠ¤ë ˆë“œ ê°¯ìˆ˜ë§Œí¼ forë¬¸ì„ ëŒë©´ì„œ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¬
- std::ref() ë¡œ ëª…ì‹œí•´ì„œ ë„˜ê²¨ì£¼ê³ ìˆìŒ
- ìŠ¤ë ˆë“œ 1ì–µê°œë¥¼ ìŠ¤ë ˆë“œì— ë§ì¶°ì„œ ì˜ë¼ì„œ ë„£ì–´ì¤Œ
- ë ˆì´ìŠ¤ ì»¨ë””ì…˜ í˜„ìƒìœ¼ë¡œ `inner_product` ì™€ ê²°ê³¼ê°’ì´ ë‹¤ë¦„

___

**Lockguard**

```cpp
mutex mtx;

void dotProductLock(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, unsigned long long& sum)
{
	//cout << "Thread Start" << endl;
	for (unsigned int i = start; i < end; ++i)
	{
		std::scoped_lock lock(mtx); // c++ 17
		sum += (v0[i] * v1[i]);
	}
	//cout << "Thread End" << endl;
}

...

cout << "ì‹¤í—˜ 3ë²ˆ - Lockguard\n";
{
	const auto sta = std::chrono::steady_clock::now();

	unsigned long long sum = 0;

	vector<std::thread> threads;
	threads.resize(numThread);

	const unsigned int numPerThread = numData / numThread;
	for (unsigned int t = 0; t < numThread; ++t)
		threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1),
			t * numPerThread, (t + 1) * numPerThread, std::ref(sum));
	for (unsigned int t = 0; t < numThread; ++t)
		threads[t].join();

	const chrono::duration<double> dur = chrono::steady_clock::now() - sta;

	cout << "ì—°ì‚°ì— ì†Œìš”ëœ ì‹œê°„ = " << dur.count() << '\n';
	cout << "ê²°ê³¼ê°’ = " << sum << '\n';
	cout << '\n';
}
```

- `mutex mtx;` ëŠ” ì—¬ëŸ¬ìŠ¤ë ˆë“œê°€ ì ‘ê·¼í• ìˆ˜ìˆëŠ”ê³³ì— ì„ ì–¸
- scoped_lockìœ¼ë¡œ ë°©ì§€
- ê°’ì€ ì •í™•íˆ ë–¨ì–´ì§€ì§€ë§Œ ìˆ˜í–‰ì‹œê°„ì´ ë§¤ìš°ëŠë¦¼
  - scoped_lockì„ forë¬¸ ë°–ìœ¼ë¡œë¹¼ë©´ ì†ë„ê°€ ë” ë¹¨ë¦¬ì§
  - ì‹œí€€ì…œí•˜ê²Œ ì‹¤í–‰ì´ë˜ì–´ lockì„ ë¸”ëŸ­ ì „ì²´ì— ì²˜ë¦¬í•˜ëŠ”ê±´ ì˜ë¯¸ê°€ì—†ìŒ
  - scoped_lockì€ ì˜ì—­ì„ ì¢ì€ê³³ì— ë„£ì€ê²Œì¢‹ì§€ë§Œ ë„ˆë¬´ë§ì´ ì‹¤í–‰ì´ë˜ë©´ ì˜¤íˆë ¤ëŠë ¤ì§

___

**atomic**

```cpp
void dotProductAtomic(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end, atomic<unsigned long long> & sum)
{
	for (unsigned int i = start; i < end; ++i)
	{
		sum += (v0[i] * v1[i]);
	}
}

...

const unsigned int numPerThread = numData / numThread;

for (unsigned int t = 0; t < numThread; ++t)
	threads[t] = std::thread(dotProductLock, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread, std::ref(sum));

for (unsigned int t = 0; t < numThread; ++t)
	threads[t].join();
```

- lock_guard ì— ë¹„í•´ êµ¬í˜„ì´ ê°„ë‹¨í•¨ 
- ê²°ê³¼ëŠ” ë™ì¼í•˜ê²Œ ë‚˜ì™”ìœ¼ë‚˜ ëŠë¦¼
- ë”í•´ì£¼ëŠ” ì—°ì‚°ì´ ë¹ˆë²ˆí•˜ì—¬ í¼í¬ë¨¼ìŠ¤ê°€ ëŠë ¤ì§

___

**Task-based parallelism (std::async)**

```cpp
auto dotProductFuture(const vector<int>& v0, const vector<int>& v1,
	const unsigned int start, const unsigned int end)
{
	int sum = 0;
	for (unsigned int i = start; i < end; ++i)
		sum += (v0[i] * v1[i]);
	return sum;
}

...

unsigned long long sum = 0;

vector<std::future<int>> futures;
futures.resize(numThread);

const unsigned int numPerThread = numData / numThread;
for (unsigned int t = 0; t < numThread; ++t)
	futures[t] = std::async(dotProductFuture, std::ref(vec0), std::ref(vec1), t * numPerThread, (t + 1) * numPerThread);

for (unsigned int t = 0; t < numThread; ++t)
	sum += futures[t].get();
```

- int ë¡œ ë°›ëŠ” ì´ìœ ëŠ” ë¶€ë¶„í•©ì€ intë¡œ ë“¤ì–´ì˜¤ê¸°ë•Œë¬¸ì— intë¡œ ë°›ìŒ
  - unsigned long long ìœ¼ë¡œ ë°”ê¿”ë„ë¨
- ë©€í‹°ìŠ¤ë ˆë”©ì‹œ ê°ê°ì˜ ìŠ¤ë ˆë“œê°€ ì—°ì‚°ì„í•˜ê³  ëë‚¸ê²°ê³¼ë¥¼ ë°›ì•„ì™€ ì·¨í•©í•˜ëŠ”ê²ƒì´ ì œì¼ì¢‹ìŒ
- ìœ„ì˜ ë©€í‹°ìŠ¤ë ˆë”© ì˜ˆì œì—ì„  sum ì´ë¼ëŠ” ê¸€ë¡œë²Œ ë³€ìˆ˜ì— ì—¬ëŸ¬ìŠ¤ë ˆë“œê°€ ë‹¬ë ¤ë“¤ì–´ ê°’ì„ ë”í•´ë‚˜ê°€ëŠ” ë°©ì‹ì´ì—‡ê³  asyncê°€ ì‘ë™í• ë•Œ ë¶€ë¶„í•©ì„ ë¦¬í„´í•´ì£¼ê³  ê·¸ê±¸ futuresë¡œ ë°›ì•„ì™€ í•©ì¹˜ëŠ” ë°©ì‹
  - ìœ„ ë©€í‹°ìŠ¤ë ˆì‰ ì˜ˆì œì˜ í•¨ìˆ˜ì—ì„  ê°’ì„ ë¦¬í„´ì„ ëª»í•´ì¤¬ì§€ë§Œ Futureì—ì„  ë¦¬í„´ì´ ê°€ëŠ¥ í•¨
- ê²°ê³¼ê°€ ì˜ë‚˜ì˜¤ê³  ì†ë„ê°€ `inner_product`ì˜ 1/4 ì •ë„ì˜ ì†ë„ê°€ ë‚˜ì˜´

___

**std::transform_reduce**

- std::dot í”„ë¡œë•íŠ¸ì˜ ë³‘ë ¬ë²„ì „ì´ std::transform_reduce ë¼ëŠ” í•¨ìˆ˜ì„
- std::sort ë“±ì´ ë³‘ë ¬ì²˜ë¦¬ë¥¼ ì§€ì›í•¨

```cpp
const auto sum = std::transform_reduce(std::execution::par, vec0.begin(), vec0.end(), vec1.begin(), 0ull);
```

- `std::execution::par`
  - par íŒ¨ëŸ¬ë ì˜ ì•½ì
  - ë³‘ë ¬ë¡œ ì‹¤í–‰
- `std::execution::seq`
  - seq ì‹œí€€ì…œì˜ ì•½ì
  - ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰

### **ğŸŒ± 19.7 ì™„ë²½í•œ ì „ë‹¬ê³¼ std::forward**

- Perfect Forwarding


```cpp
#include <iostream>	
#include <vector>
#include <utility> // std::forward

using namespace std;

struct myStruct
{};

void func(struct myStruct& s) { cout << "Pass by L-ref\n"; }  // L-value Reference ì˜¤ë²„ë¡œë”©
void func(struct myStruct&& s) { cout << "Pass by R-ref\n"; }  // R-value Reference ì˜¤ë²„ë¡œë”©

template<typename T>   // ì—¬ëŸ¬ê°€ì§€ íƒ€ì…ì„ Të¡œ ë°›ì„ ìˆ˜ ìˆë‹¤.
void func_wrapper(T t)
{
    func(t);
}

int main()
{
	myStruct s;

	func(s);			
	func(myStruct()); // ì ë‹¹í•œ ê²ƒì„ IDEê°€ ì˜ ì°¾ì•„ì„œ ì—°ê²°í•´ì¤€ë‹¤.

    cout << endl;

	func_wrapper(s);
	func_wrapper(myStruct());
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Pass by L-ref
Pass by R-ref

Pass by L-ref
Pass by L-ref

```

- ì§ì ‘ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ”ê²ƒì€ ì»´íŒŒì¼ëŸ¬ê°€ L-valueì¸ì§€ R-value ì¸ì§€ êµ¬ë¶„í•´ì¤Œ
- í…œí”Œë¦¿ ì‚¬ìš©ì‹œì—ëŠ” êµ¬ë¶„ì„ ì•ˆí•´ì¤Œ
  - í…œí”Œë¦¿íƒ€ì´ì¦ˆê°€ë˜ë©´ì„œ L-valueì¸ì§€ R-value ì¸ì§€ ì •ë³´ê°€ ë‚ ë¼ê°€ì„œ L-valueê°€ ë¨

___

**std::forward**

```cpp
#include <iostream>	
#include <vector>
#include <utility> // std::forward

using namespace std;

struct myStruct
{};

void func(struct myStruct& s) { cout << "Pass by L-ref\n"; }
void func(struct myStruct&& s) { cout << "Pass by R-ref\n"; }

template<typename T>
void func_wrapper(T&& t)
{
	func(std::forward<T>(t));
}

int main()
{
	myStruct s;

	func_wrapper(s);
	func_wrapper(myStruct());
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Pass by L-ref
Pass by R-ref

```

- `std::forward` ê°€ í•˜ëŠ”ì¼ì„ Tê°€ ë“¤ì–´ì˜¬ë•Œ L-value ë¡œ ë“¤ì–´ì˜¤ë©´ L-value ë¡œ ë¦¬í„´í•´ì£¼ê³  R-value ë¡œ ë“¤ì–´ì™”ìœ¼ë©´ R-valueë¡œ ë¦¬í„´í•´ì¤Œ

___

**Move Semantics ì™€ ì—°ê´€ì§€ì–´ ìƒê°í•´ë³´ê¸°**

```cpp
#include <iostream>	
#include <vector>
#include <utility>

using namespace std;

class CustomVector
{
public:
	unsigned n_data = 0;  // ë™ì  ë°°ì—´ì˜ ì‚¬ì´ì¦ˆê°€ ë  ë©¤ë²„ ë³€ìˆ˜
	int *ptr = nullptr;  // ë™ì  ë°°ì—´ í¬ì¸í„°ê°€ ë  ë©¤ë²„ ë³€ìˆ˜ (í• ë‹¹ì€ init í•¨ìˆ˜ì—ì„œ)

	CustomVector(const unsigned & _n_data, const int & _init = 0)
	{
		cout << "Constructor" << endl;
		
		init(_n_data, _init);
	}

	CustomVector(CustomVector & l_input)  // L-value ë§Œ ë°›ì„ ìˆ˜ ìˆë‹¤.
	{
		cout << "Copy construtor" << endl;

		init(l_input.n_data);


        // ğŸ‰ê¹Šì€ ë³µì‚¬ 
		for (unsigned i = 0; i < n_data; ++i)  
			ptr[i] = l_input.ptr[i];
	}

	CustomVector(CustomVector && r_input) // R-value ë§Œ ë°›ì„ ìˆ˜ ìˆë‹¤.
	{
		cout << "Move construtor" << endl;

        // ğŸ‰ì–•ì€ ë³µì‚¬ 
        // ì†Œìœ ê¶Œ ì´ì „
		n_data = r_input.n_data;
		ptr = r_input.ptr;

        // ì†Œìœ ê¶Œ ë°•íƒˆ
		r_input.n_data = 0;
		r_input.ptr = nullptr;
	}
	
	~CustomVector()
	{
		delete[] ptr;
	}

	void init(const unsigned & _n_data, const int & _init = 0)
	{
		n_data = _n_data;
		ptr = new int[n_data];
		for (unsigned i = 0; i < n_data; ++i)
			ptr[i] = _init; 
	}
};


void doSomething(CustomVector & vec)
{
	cout << "Pass by L-reference" << endl;
	CustomVector new_vec(vec);
}

void doSomething(CustomVector && vec)
{
	cout << "Pass by R-reference" << endl;
	CustomVector new_vec(std::move(vec));  // R-valueë¡œ vecì„ ë°›ì•˜ë”ë¼ë„ std::moveë¡œì„œ ë„˜ê²¨ì£¼ì–´ì•¼ í•œë‹¤. 
}

template<typename T>
void doSomethingTemplate_O(T && vec)  // ì˜¬ë°”ë¥´ê²Œ R-value, L-valueë¥¼ êµ¬ë¶„í•´ì„œ ì»´íŒŒì¼ í•œë‹¤.
{
	doSomething(std::forward<T>(vec));
}

template<typename T>
void doSomethingTemplate_X(T vec)  // R-value, L-valueë¥¼ êµ¬ë¶„í•´ì„œ ì»´íŒŒì¼ í•˜ì§€ ëª»í•˜ê³  ê·¸ëƒ¥ ë‹¤ L-valueë¡œ ì²˜ë¦¬í•´ë²„ë¦°ë‹¤.
{
	doSomething(vec);
}
```

- `void doSomething(CustomVector && vec)` move() ë¥¼ë¹¼ê³  ê·¸ëƒ¥ë„£ì–´ë²„ë¦¬ë©´ L-valueë¡œ ë°›ì•„ copy Constructor ê°€ í˜¸ì¶œë¨
- vec ìì²´ëŠ” ë³€ìˆ˜ë¼ l-valueë¡œ ë“¤ì–´ê°
- R-value ë¡œ íŒŒë¼ë©”íƒ€ë¥¼ ë°›ëŠ” í•¨ìˆ˜ë¥¼ ì˜¤ë²„ë¡œë”©í• ë•ŒëŠ” `std::move()` ë¥¼ì¨ì„œ ëª…í™•í•˜ê²Œ êµ¬í˜„í•˜ê¸°

**L-value ê¹Šì€ ë³µì‚¬**

```cpp
int main()
{
    CustomVector my_vec(10, 1024);
	CustomVector temp(my_vec);  // my_vec ì€ L-value

	cout << my_vec.n_data << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Constructor
Copy constructor
10
```

**R-value ì–•ì€ ë³µì‚¬**

```cpp
int main()
{
    CustomVector my_vec(10, 1024);
	CustomVector temp(std::move(my_vec));  // my_vec ì€ R-value

	cout << my_vec.n_data << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Constructor
Move constructor
0
```

- std::move() ë¡œ R-value ë¡œ ë°”ê¿”ì¤€ë‹¤ëŠ” ê°œë…ë³´ë‹¨ Move constructor ë¥¼ ë¶€ë¥¸ë‹¤ëŠ” ëŠë‚Œì´ ê°•í•¨ 
- R-value ë¥¼ íŒŒë¼ë©”íƒ€ë¡œ ë„£ì–´ì£¼ì–´ Move constructor ê°€ ì‹¤í–‰ë¨ 
- ê¹Šì€ë³µì‚¬ì™€ ì–•ì€ ë³µì‚¬ ìˆ˜í–‰ì‹œê°„ ì°¨ì´ê°€ ë§ì´ ë‚ ê²ƒì„

___

```cpp
int main()
{
    CustomVector my_vec(10, 1024);
	CustomVector temp(std::move(my_vec));  // my_vec ì€ R-value

	cout << my_vec.n_data << endl;
}
```

**ì¶œë ¥ ê²°ê³¼**

```cpp
Constructor
Move constructor
0
```

- my_vecì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ë¥¼ ë§Œë“¤ ëŒ€, my_vecì„ ë˜ ì‚¬ìš©í•˜ê² ë‹¤ëŠ” ì˜ì§€ê°€ ìˆë‹¤ë©´ ì†Œìœ ê¶Œì´ ë°•íƒˆë˜ì§€ ì•Šê²Œë” ê¹Šì€ ë³µì‚¬ë¥¼ ì‚¬ìš©í•˜ëŠ” L-valueë¡œì„œ ë„˜ê²¨ì•¼ í•˜ê³  `CustomVector(10, 8)`ì²˜ëŸ¼ ë”ëŠ” ì‚¬ìš©í•  ì¼ì´ ì—†ëŠ” R-valueë¼ë©´ ì´ë™ ìƒì„±ìë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.

___

**template**

```cpp
template<typename T> // í‹€ë¦° ì˜ˆì œ
void doSomethingTemplate_X(T vec)  // R-value, L-valueë¥¼ êµ¬ë¶„í•´ì„œ ì»´íŒŒì¼ í•˜ì§€ ëª»í•˜ê³  ê·¸ëƒ¥ ë‹¤ L-valueë¡œ ì²˜ë¦¬í•´ë²„ë¦°ë‹¤.
{
	doSomething(vec);
}

template<typename T> // ì˜¬ë°”ë¥¸ ì˜ˆì œ
void doSomethingTemplate_O(T&& vec)  // ì˜¬ë°”ë¥´ê²Œ R-value, L-valueë¥¼ êµ¬ë¶„í•´ì„œ ì»´íŒŒì¼ í•œë‹¤.
{
	doSomething(std::forward<T>(vec));
}

int main()
{
    CustomVector my_vec(10, 1024);

	doSomethingTemplate_O(my_vec);
    doSomethingTemplate_O(CustomVector(10, 8));

	my_vec;
}
```

### **ğŸŒ± 19.8 ìë£Œí˜• ì¶”ë¡  autoì™€ decttype**

- Type Inference

**ì „ì²´ì½”ë“œ**

```cpp
#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>

using namespace std;

class Examples
{
public:
	void ex1()
	{
		std::vector<int> vect;
		for (std::vector<int>::iterator itr = vect.begin(); itr != vect.end(); ++itr)
			cout << *itr;
		for (auto itr = vect.begin(); itr != vect.end(); itr++)
			cout << *itr;

		for (auto itr : vect) //for (const & itr : vect)
			cout << itr;
	}
	void ex2()
	{
		int x = int();
		auto auto_x = x;
		const int& crx = x;
		auto auto_crx1 = crx; //autoëŠ” í˜•ì„ ë°›ì•„ë“¤ì¼ ë•Œ constë¥¼ ë–¼ ë²„ë¦°ë‹¤.
		const auto& auto_crx2 = crx;  //autoì— constì™€ &ë¥¼ ë°›ì•„ì¤˜ì•¼ í•œë‹¤.
		volatile int vx = 1024;
		//volatileì€ ê°’ì´ ìì£¼ ë³€í•˜ê¸° ë•Œë¬¸ì— ìµœì í™”í•  ë•Œ ëº´ ë‹¬ë¼ëŠ” ë§.
		auto avx = vx; //ì—¬ê¸°ë„ volatileì„ ë–¼ê³  intë§Œ ë‚¨ê¸´ë‹¤.
		volatile auto vavx = vx;
		//autoëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ê²ƒë§Œ ë³€í™˜í•˜ê³ , ìì˜í•œ ê²ƒì€ ì¶”ê°€í•´ì•¼ í•œë‹¤.
	}

	template<class T>
	void func_ex3(T arg)
	{}

	/*template <class T>
	void func_ex3(const T& arg)
	{}
	*/  //ì´ë ‡ê²Œ ì¶”ê°€í•´ì•¼ í•œë‹¤.

	void ex3()
	{
		const int& crx = 123;
		func_ex3(crx);    //ì—¬ê¸°ì„œ const ì™€ &ë¥¼ë—´ ë²„ë¦°ë‹¤.
	}

	void  ex4()
	{
		const int c = 0;
		auto& rc = c;
		//rc = 123; //error //ì—¬ê¸°ì„œ constê°€ ì—¬ì „íˆ ë¶™ì–´ ìˆë‹¤.
		//ì—¬ê¸°ì„œ const intì˜ referenceëŠ” ë¬´ì¡°ê±´ constê°€ ë¶™ì–´ì•¼ í•œë‹¤(ì•„ë‹ˆë©´ ëª» ê°€ì ¸ì˜´)
		//ê·¸ë˜ì„œ ì´ëŸ´ ë• autoê°€ constë¥¼ ë¶™ì¸ë‹¤.
	}

	void ex5() //amendment = ê°œì •
	{
		int i = 42;
		auto&& ri_1 = i; //l-value  //ì™¼ìª½ì— l-valueê°€ ë“¤ì–´ì˜¤ë©´ ë¬´ì¡°ê±´ l-value.
		auto&& ri_2 = 42; //r-value
	}

	void ex6()
	{
		int x = 42;
		const int* p1 = &x;
		auto p2 = p1;   //const int * ê¹Œì§€ ì°¾ì•„ì¤Œ.
	}

	template <typename T, typename S>
	void func_ex7(T lhs, S rhs)
	{
		auto prod1 = lhs * rhs;   //ê³±í•˜ê¸°ë¥¼ í•œ ê²°ê³¼ê°’ì˜ í˜•ì´ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ëª¨ë¦„!

		//typedef typeof(lhs * rhs) product_type; //pre-c++11 'some' compilers
		//ì¼ë¶€ ì»´íŒŒì¼ëŸ¬ì—ì„œ ì œê³µí•´ì¤¬ìŒ. ì¦‰, ë°ì´í„° íƒ€ì…ì„ ë¦¬í„´í•´ì£¼ëŠ” í•¨ìˆ˜ê°€ ìˆì—ˆìŒ.
		typedef decltype(lhs* rhs) product_type;
		//ì´ê²ƒì´ ì •ì‹ìœ¼ë¡œ ë„˜ì–´ì˜´. decltypeìœ¼ë¡œ.

		product_type prod2 = lhs * rhs;
		decltype(lhs * rhs) prod3 = lhs * rhs; //ìë£Œí˜•ì²˜ëŸ¼ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
	}

	template <typename T, typename S>
	auto func_ex8(T lhs, S rhs) -> decltype(lhs* rhs)
	{
		return lhs * rhs;
	}
	//decltype(lhs * rhs) func_ex8(T lhs, S rhs)
	//ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ì½ì–´ë“¤ì´ëŠ” ìˆœì„œ ìƒ ì½ì„ ìˆ˜ ì—†ë‹¤.

	void ex7_8()
	{
		func_ex7(1.0, 345);
		func_ex8(1.2, 345);
	}

	struct S
	{
		int m_x;
		S()
		{
			m_x = 42;
		}
	};

	void ex9()
	{
		int x;
		const int cx = 42;
		const int& crx = x;
		const S* p = new S();
		auto a = x;
		auto b = cx;
		auto c = crx;
		auto d = p;
		auto e = p->m_x;
		//eëŠ” ê·¸ëƒ¥ integerê°€ ëœë‹¤. pëŠ” constì§€ë§Œ ë³µì‚¬í•´ì„œ ìƒê´€ì—†ì–´ì§€ëŠ” ê²ƒ

		typedef decltype(x) x_type;	//int
		typedef decltype(cx) cx_type; //const int
		typedef decltype(crx) crx_type; //const int &
		typedef decltype(p->m_x) m_x_type; //int
		//ë©¤ë²„ëŠ” intë¡œ ì„ ì–¸ë˜ì–´ ìˆì–´ì„œ.
		//declared typeì€ ì„ ì–¸ëœ íƒ€ì… ê·¸ëŒ€ë¡œë¥¼ ë‹¤ ê°€ì ¸ì˜´.

		typedef decltype((x)) x_with_parens_type;  //add references to lvalues
		typedef decltype((cx)) cx_with_parens_type;
		typedef decltype((crx)) crx_with_parens_type;
		typedef decltype((p->m_x)) m__with_parens_type;
		//referenceë¼ ë³€í™”ê°€ ë˜ë©´ ì•ˆëœë‹¤ëŠ” constë„ ê°™ì´ ê°€ì ¸ì˜´
	}

	const S foo()
	{
		return S();
	}

	const int& foobar()
	{
		return 123;
	}

	void ex10()
	{
		std::vector<int> vect = { 42, 43 };
		auto a = foo();   //S
		typedef decltype(foo()) foo_type; //const S
		auto b = foobar();
		typedef decltype(foobar()) foobar_type;

		auto itr = vect.begin();
		typedef decltype(vect.begin()) iterator_type;

		auto first_element = vect[0];
		decltype(vect[1]) second_element = vect[1];
	}

	void ex11()
	{
		int x = 0;
		int y = 0;
		const int cx = 42;
		const int cy = 43;
		double d1 = 3.14;
		double d2 = 2.72;

		typedef decltype(x* y) prod_xy_type; //int
		auto a = x * y; //int

		typedef decltype(cx* cy) prod_cxcy_type; //int
		auto a = cx * cy; //in //result is prvalue, ìƒìˆ˜ì´ë¯€ë¡œ ê·¸ëƒ¥ int

		typedef decltype(d1 < d2 ? d1 : d2) cond_type; // l-valueì—ëŠ” &ê°€ ë¶™ëŠ”ë‹¤.
		auto c = d1 < d2 ? d1 : d2;   //ê·¸ëƒ¥ double

		typedef decltype(x < d2 ? x : d2) cond_type_mixed; //doubleë¡œ í˜•ë³€í™˜ì´ ì˜ ëœë‹¤.
		auto d = x < d2 ? x : d2;  

		//auto d = std::min(x, dbl); //error, minì€ ë°ì´í„° íƒ€ì…ì´ ê°™ì•„ì•¼ ë¹„êµí•´ì¤Œ.
	}

	template<typename T, typename S>
	auto fpmin_wrong(T x, S y) -> decltype(x < y ? x : y)
	{
		return x < y ? x : y;
	}
	//ì—¬ê¸°ì„œ Tì™€ Sì˜ í˜•ì´ ê°™ìœ¼ë©´ referenceê°€ ë¶™ëŠ”ê²Œ ë‹¨ì .

	template<typename T, typename S>
	auto fpmin(T x, S y) ->
		typename std::remove_reference<decltype(x < y ? x : y)>::type
		//referenceë¥¼ ì œê±°í•œ íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤.
	{
		return x < y ? x : y;
	}

	void ex12()
	{
		int i = 42;
		double d = 45.1;
		//auto a = std::min(i, d); //error
		auto a = std::min(static_cast<double>(i), d);
		int& j = i;
		typedef decltype(fpmin_wrong(d, d)) fpmin_return_type1;  //doubleì˜ reference
		typedef decltype(fpmin_wrong(d, d)) fpmin_return_type2; //ê·¸ëƒ¥ double
		typedef decltype(fpmin_wrong(d, d)) fpmin_return_type3; //ê·¸ëƒ¥ double
	}

	void ex13()
	{
		std::vector<int> vect; //vect is empty
		typedef decltype(vect[0]) integer;
		//ì‹¤ì œ ìˆ˜í–‰ì€ ì•ˆí•´ì„œ ë¬¸ì œëŠ” ì•ˆ ìƒê¹€
	}

	template<typename R>
	class SomeFunctor
	{
	public:
		typedef R result_type;
		SomeFunctor()
		{

		}
		result_type operator() ()
		{
			return R();
		}
	};

	void ex14()
	{
		SomeFunctor<int> func;
		typedef decltype(func)::result_type integer; //nested type;
		//í•¨ìˆ˜ ì•ˆì˜ nested typeë„ ê°„í¸í•˜ê²Œ ì ‘ê·¼ ê°€ëŠ¥.
	}

	void ex15()
	{
		auto lambda = []() {return 42; };
		decltype(lambda) lambda2(lambda);
		decltype((lambda)) lambda3(lambda);
		cout << "Lambda functions" << endl;
		cout << &lambda << " " << &lambda2 << endl;
		cout << &lambda << " " << &lambda3 << endl;
	}

	void ex16()
	{

		//generic lambda
		auto lambda = [](auto x, auto y)
		{
			return x + y;
		};
		cout << lambda(1.1, 2) << " " << lambda(3, 4) << " " << lambda(4.5, 2.2) << endl;
	}
};
int main()
{
	Examples examples;

	examples.ex1();
	examples.ex2();
	examples.ex3();
	examples.ex10();
	examples.ex12();
	examples.ex14();
	examples.ex15();
	examples.ex16();
}
```

___


**ì˜ˆì œ 1**

```cpp
using namespace std;

void ex()
{
	vector<int> vect;
	
//  1ï¸âƒ£
	for (vector<int>::const_iterator cit = vect.begin(); cit != vect.end(); ++cit)
		cout << *cit;
//  2ï¸âƒ£
	for (auto itr = vect.begin(); itr != vect.end(); ++itr)
		cout << *itr;
//  3ï¸âƒ£
	for (auto itr : vect)
		cout << itr;
}
```

- vector ì‚¬ìš©ì‹œ ì´ˆê¸°í™”í• ë•Œ autoê°€ ìë™ìœ¼ë¡œ ì¸ì‹í•´ì£¼ê¸° ë•Œë¬¸ì— í¸í•´ì§

___


**ì˜ˆì œ 2**

```cpp
void ex2()
{
	int x = int();
	auto auto_x = x;
	const int& crx = x;
	auto auto_crx1 = crx; //autoëŠ” í˜•ì„ ë°›ì•„ë“¤ì¼ ë•Œ constë¥¼ ë–¼ ë²„ë¦°ë‹¤.
	const auto& auto_crx2 = crx;  //autoì— constì™€ &ë¥¼ ë°›ì•„ì¤˜ì•¼ í•œë‹¤.
	volatile int vx = 1024;
	//volatileì€ ê°’ì´ ìì£¼ ë³€í•˜ê¸° ë•Œë¬¸ì— ìµœì í™”í•  ë•Œ ëº´ ë‹¬ë¼ëŠ” ë§.
	auto avx = vx; //ì—¬ê¸°ë„ volatileì„ ë–¼ê³  intë§Œ ë‚¨ê¸´ë‹¤.
	volatile auto vavx = vx;
	//autoëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ê²ƒë§Œ ë³€í™˜í•˜ê³ , ìì˜í•œ ê²ƒì€ ì¶”ê°€í•´ì•¼ í•œë‹¤.
}
```

- autoì— const int & ë¥¼ ë„£ìœ¼ë©´ constë‚˜ &ë¥¼ ë‹¤ ë–¼ì–´ë²„ë¦¼
  - const auto& ì™€ê°™ì´ ì§€ì •ì„ í•´ì£¼ë©´ ì‚¬ìš©í• ìˆ˜ ìˆìŒ
- `volatile:` ê°’ì´ ìì£¼ë°”ë€Œê¸°ë•Œë¬¸ì— ìµœì í™”ì‹œ ë¹¼ë‹¬ë¼ëŠ” ëœ» 
  - ë©€í‹°ìŠ¤ë ˆë”©ì‹œ ì‚¬ìš©

___

**ì˜ˆì œ 3**

```cpp
template<class T>
void func_ex3(T arg)
{}

/*template <class T>
void func_ex3(const T& arg)
{}
*/  //ì´ë ‡ê²Œ ì¶”ê°€í•´ì•¼ í•œë‹¤.

void ex3()
{
	const int& crx = 123;
	func_ex3(crx);    //ì—¬ê¸°ì„œ const ì™€ &ë¥¼ë—´ ë²„ë¦°ë‹¤.
}
```

- `const int & crx = 123;` ë¥¼ íŒŒë¼ë©”íƒ€ë¡œ ë„£ì–´ì¤¬ì„ë•Œ template T ì˜ í˜•íƒœë¡œ ë°›ì•„ì˜¤ë©´ const ì™€ & ë‹¤ë–¼ê³  intë§Œ ë‚¨ìŒ
- ì˜ˆì œ 2 ì™€ê°™ì´ íŒŒë¼ë©”íƒ€ì— const & ë“± ì§€ì •ì„í•´ì•¼í•¨
- template íƒ€ì… ë””ëŸ­ì…˜ë¡œ autoì™€ ë¹„ìŠ·í•œ ë°©ì‹ì´ë‹¤

___

**ì˜ˆì œ 4**

```cpp
void ex()
{
	const int c = 0;
	auto& rc = c;
    // rc = 123 - error!
}
```

- ë ˆí¼ëŸ°ìŠ¤ë¡œ ê°€ì ¸ì˜¬ë ¤ê³ í• ë•ŒëŠ” ê°€ì ¸ì˜¤ëŠ” ë°ì´í„°ê°€ ë ˆí¼ëŸ°ìŠ¤ì—¬ ì•¼ í•˜ê³  ì´ë•Œ auto ì—ì„œëŠ” constë„ ê°™ì´ ì¶”ë¡ ì„ ì‹œì¼œì¤Œ
___

**ì˜ˆì œ 5**

```cpp
void ex()
{
	int i = 40;
	auto && ri = i;		// riëŠ” l-value. int& ri ì™œëƒí•˜ë©´ ë“¤ì–´ì˜¨ê²Œ l-valueë‹ˆê¹Œ
	auto && ri2 = 42;	// ri2ëŠ” r-value. int&& ri2
	auto && ri3 = std::move(i); // ri3ëŠ” r-value.  int && ri3
}
```

- ëŒ€ì…ë˜ëŠ” ì¡´ì¬ê°€ l-value ë©´ ë ˆí¼ëŸ°ìŠ¤ë¡œ ë°”ë€œ
- ëŒ€ì…ë˜ëŠ” ì¡´ì¬ê°€ r-value ë©´ r-valueë¡œ ë°›ì•„ë“œë¦¼

___

**ì˜ˆì œ 6**

```cpp
void ex()
{
	int i = 40;
	const int* pi = &i;
	auto p = pi;		
    
    // ex2, ex4ì™€ëŠ” ë‹¬ë¦¬ ì´ë²ˆì—ëŠ” intê°€ ì•„ë‹ˆë¼ const int * ê¹Œì§€ ë‹¤ ê°€ì ¸ì˜´
	// ì¦‰, í¬ì¸í„°ì¼ ê²½ìš°ì—ëŠ” autoê°€ ê°’ì„ ë‹¤ ê°€ì ¸ì˜¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŒ
}
```

- `const int*` ê¹Œì§€ ì¶”ë¡ í•´ì¤Œ

___

**decltype**

**ì˜ˆì œ 7**

```cpp
template <typename T, typename S>
void func_ex7(T lhs, S rhs)
{
	auto prod1 = lhs * rhs;   //ê³±í•˜ê¸°ë¥¼ í•œ ê²°ê³¼ê°’ì˜ í˜•ì´ ì–´ë–»ê²Œ ë˜ëŠ”ì§€ ëª¨ë¦„!

	//typedef typeof(lhs * rhs) product_type; //pre-c++11 'some' compilers
	//ì¼ë¶€ ì»´íŒŒì¼ëŸ¬ì—ì„œ ì œê³µí•´ì¤¬ìŒ. ì¦‰, ë°ì´í„° íƒ€ì…ì„ ë¦¬í„´í•´ì£¼ëŠ” í•¨ìˆ˜ê°€ ìˆì—ˆìŒ.
	typedef decltype(lhs* rhs) product_type;
	//ì´ê²ƒì´ ì •ì‹ìœ¼ë¡œ ë„˜ì–´ì˜´. decltypeìœ¼ë¡œ.

	product_type prod2 = lhs * rhs;
	decltype(lhs * rhs) prod3 = lhs * rhs; //ìë£Œí˜•ì²˜ëŸ¼ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
}

void ex7_8()
{
	func_ex7(1.0, 345);
	func_ex8(1.2, 345);
}
```

- C++ 11 ì´ì „ì—ëŠ” ê³„ì‚°ëœê°’ì˜ ë°ì´í„° íƒ€ì… ì„ ë¦¬í„´ë°›ì•„ ì‚¬ìš©í–ˆì—ˆìŒ
- `decltype()` ì•ˆì—ì„  ì‹¤í–‰ë˜ëŠ”ê±´ ì•„ë‹ˆê³  ì¶”ë¡ ë˜ëŠ” ê²ƒ

___

**ì˜ˆì œ 8**

```cpp
template <typename T, typename S>

template <typename T, typename S>
auto func_ex8(T lhs, S rhs) -> decltype(lhs* rhs)
{
	return lhs * rhs;
}
//decltype(lhs * rhs) func_ex8(T lhs, S rhs)
//ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ì½ì–´ë“¤ì´ëŠ” ìˆœì„œ ìƒ ì½ì„ ìˆ˜ ì—†ë‹¤.

void ex7_8()
{
	func_ex7(1.0, 345);
	func_ex8(1.2, 345);
}
```

- ë¦¬í„´ íƒ€ì…ì—ë„ ì‚¬ìš©í• ìˆ˜ ìˆìŒ
___

**ì˜ˆì œ 9**

```cpp
struct S
{
	int m_x;
	S()
	{
		m_x = 42;
	}
};

void ex9()
{
	int x;
	const int cx = 42;
	const int& crx = x;
	const S* p = new S();

	auto a = x;
	auto b = cx;
	auto c = crx;
	auto d = p;
	auto e = p->m_x;
	//eëŠ” ê·¸ëƒ¥ integerê°€ ëœë‹¤. pëŠ” constì§€ë§Œ ë³µì‚¬í•´ì„œ ìƒê´€ì—†ì–´ì§€ëŠ” ê²ƒ

	typedef decltype(x) x_type;	//int
	typedef decltype(cx) cx_type; //const int
	typedef decltype(crx) crx_type; //const int &
	typedef decltype(p->m_x) m_x_type; //int
	//ë©¤ë²„ëŠ” intë¡œ ì„ ì–¸ë˜ì–´ ìˆì–´ì„œ.
	//declared typeì€ ì„ ì–¸ëœ íƒ€ì… ê·¸ëŒ€ë¡œë¥¼ ë‹¤ ê°€ì ¸ì˜´.

	typedef decltype((x)) x_with_parens_type;  //add references to lvalues
	typedef decltype((cx)) cx_with_parens_type;
	typedef decltype((crx)) crx_with_parens_type;
	typedef decltype((p->m_x)) m__with_parens_type;
	//referenceë¼ ë³€í™”ê°€ ë˜ë©´ ì•ˆëœë‹¤ëŠ” constë„ ê°™ì´ ê°€ì ¸ì˜´
}
```

- `(())` ë ˆí¼ëŸ°ìŠ¤ë¥¼ ë”í•´ì¤Œ 
  - ì›ë˜ ë ˆí¼ëŸ°ìŠ¤ë¼ë©´ ê·¸ëƒ¥ ìœ ì§€í•¨

___

**ì˜ˆì œ 10**

```cpp
const S foo()
{
	return S();
}

const int& foobar()
{
	return 123;
}

void ex10()
{
	std::vector<int> vect = { 42, 43 };
	auto a = foo();   //S
	typedef decltype(foo()) foo_type; //const S
	auto b = foobar(); // int
	typedef decltype(foobar()) foobar_type; // const int &

	auto itr = vect.begin();
	typedef decltype(vect.begin()) iterator_type;

	auto first_element = vect[0]; // int
	decltype(vect[1]) second_element = vect[1]; // int &
}
```

- auto ì—ì„  ë¦¬í„´íƒ€ì…ì„ Së¡œë§Œ ë°›ê³ 
- vectorì— ì˜¤ë²„ë¡œë”© ë˜ì–´ìˆëŠ” `[]` ì˜¤í¼ë ˆì´í„°ê°€ ë¦¬í„´í• ë•Œ `int &` ë¥¼ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜ì„

___

**ì˜ˆì œ 11**

```cpp
void ex11()
{
	int x = 0;
	int y = 0;
	const int cx = 42;
	const int cy = 43;
	double d1 = 3.14;
	double d2 = 2.72;

	typedef decltype(x* y) prod_xy_type; //int
	auto a = x * y; //int

	typedef decltype(cx* cy) prod_cxcy_type; //int
	auto a = cx * cy; //in // result is prvalue, ìƒìˆ˜ì´ë¯€ë¡œ ê·¸ëƒ¥ int

	typedef decltype(d1 < d2 ? d1 : d2) cond_type; // l-valueì—ëŠ” &ê°€ ë¶™ëŠ”ë‹¤.
	auto c = d1 < d2 ? d1 : d2;   //ê·¸ëƒ¥ double

	typedef decltype(x < d2 ? x : d2) cond_type_mixed; //doubleë¡œ í˜•ë³€í™˜ì´ ì˜ ëœë‹¤.
	auto d = x < d2 ? x : d2;

	//auto d = std::min(x, dbl); //error, minì€ ë°ì´í„° íƒ€ì…ì´ ê°™ì•„ì•¼ ë¹„êµí•´ì¤Œ.
	
	template<typename T, typename S>
	auto fpmin_wrong(T x, S y) -> decltype(x < y ? x : y)
	{
		return x < y ? x : y;
	}
	//ì—¬ê¸°ì„œ Tì™€ Sì˜ í˜•ì´ ê°™ìœ¼ë©´ referenceê°€ ë¶™ëŠ”ê²Œ ë‹¨ì .

	template<typename T, typename S>
	auto fpmin(T x, S y) ->
		typename std::remove_reference<decltype(x < y ? x : y)>::type
		//referenceë¥¼ ì œê±°í•œ íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤.
	{
		return x < y ? x : y;
	}
}
```

- fpmin_wrong ë¶€ìŠ¤íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— fpminì´ë¼ëŠ” ê²ƒì´ ë“¤ì–´ìˆì—ˆìŒ
- `remove_reference` ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì œê±°í•œ 

___

**ì˜ˆì œ 12**

```cpp
void ex12()
{
	int i = 42;
	double d = 45.1;
	//auto a = std::min(i, d); //error
	auto a = std::min(static_cast<double>(i), d);
	int& j = i;
	typedef decltype(fpmin_wrong(d, d)) fpmin_return_type1;  //doubleì˜ reference
	typedef decltype(fpmin_wrong(i, d)) fpmin_return_type2; //ê·¸ëƒ¥ double
	typedef decltype(fpmin_wrong(j, d)) fpmin_return_type3; //ê·¸ëƒ¥ double
}
```
___

**ì˜ˆì œ 13**

```cpp
void ex13()
{
	std::vector<int> vect; //vect is empty
	typedef decltype(vect[0]) integer;
	//ì‹¤ì œ ìˆ˜í–‰ì€ ì•ˆí•´ì„œ ë¬¸ì œëŠ” ì•ˆ ìƒê¹€
}
```

- decltype ì€ ì‹¤ì œ ìˆ˜í–‰ì„ ì•ˆí•˜ê¸° ë•Œë¬¸ì— vectorì— ë‚´ìš©ë¬¼ì´ ì—†ì–´ë„ ì—ëŸ¬ê°€ ë°œìƒì´ì•ˆë¨

___

**ì˜ˆì œ 14**

```cpp
template<typename R>
class SomeFunctor
{
public:
	typedef R result_type;
	SomeFunctor()
	{

	}
	result_type operator() ()
	{
		return R();
	}
};

void ex14()
{
	SomeFunctor<int> func;
	typedef decltype(func)::result_type integer; //nested type;
	//í•¨ìˆ˜ ì•ˆì˜ nested typeë„ ê°„í¸í•˜ê²Œ ì ‘ê·¼ ê°€ëŠ¥.
}
```

___

**ì˜ˆì œ 15**

```cpp
void ex15()
{
	auto lambda = []() {return 42; }; // class lambda
	decltype(lambda) lambda2(lambda); // ê°™ì€ê¸°ëŠ¥ì„í•˜ëŠ” ëŒë‹¤í•¨ìˆ˜ê°€ í•˜ë‚˜ë” ìƒê¹€
	decltype((lambda)) lambda3(lambda); // ë ˆí¼ëŸ°ìŠ¤ë¥¼ ë¦¬í„´ë°›ì•„ ë„£ì–´ì£¼ëŠ”í˜•íƒœ
	cout << "Lambda functions" << endl;
	cout << &lambda << " " << &lambda2 << endl; // ì„œë¡œ ë‹¤ë¦„
	cout << &lambda << " " << &lambda3 << endl; // ì„œë¡œ ê°™ìŒ
}
```
___

**ì˜ˆì œ 16**

```cpp
void ex16()
{

	//generic lambda
	auto lambda = [](auto x, auto y)
	{
		return x + y;
	};
	cout << lambda(1.1, 2) << " " << lambda(3, 4) << " " << lambda(4.5, 2.2) << endl;
}
```

- ëŒë‹¤ì—ë„ autoë¥¼ ì‚¬ìš©í• ìˆ˜ ìˆìŒ

# ğŸ“Œì°¸ì¡°ë§í¬
ì¸í”„ëŸ° **ë”°ë¼í•˜ë©´ì„œ ë°°ìš°ëŠ” C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**ê³µë¶€í•˜ëŠ” ì‹ë¹µë§˜ ğŸ‘±â€â™€ï¸ ë‹˜ì˜ ë¸”ë¡œê·¸** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)

**maxlafe-ê°œë°œ ë¸”ë¡œê·¸** - [https://maxcomfem.tistory.com/22](https://maxcomfem.tistory.com/22)