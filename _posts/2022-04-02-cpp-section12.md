---
published: true
title:  "따라하며 배우는 C++ Section 12. 가상 함수들"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-04-28 
last_modified_at: 2022-04-28
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 12. 가상 함수들

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 12. 가상 함수들**

### **🌱 12.1 다형성의 기본 개념**

- 자식 클래스의 객체에 부모 클래스의 포인터를 사용한다면?

```cpp
#include <iostream>
#include <string>

using namespace std;

class Animal
{
protected:
	string m_name;

public:
	Animal(std::string name)
		:m_name(name)
	{}

public:
	string getName() { return m_name; }

	void speak() const
	{
		cout << m_name << " ??? " << endl;
	}
};

class Cat : public Animal
{
public:
	Cat(string name)
		: Animal(name)
	{}

	void speak() const
	{
		cout << m_name << " Meow " << endl;
	}
};

class Dog : public Animal
{
public:
	Dog(string name)
		: Animal(name)
	{}

	void speak() const
	{
		cout << m_name << " Woof " << endl;
	}
};

int main()
{
	Animal animal("My animal");
	Cat cat("My cat");
	Dog dog("My dog");

	animal.speak();
	cat.speak();
	dog.speak();

	Animal* ptr_animal1 = &cat;
	Animal* ptr_animal2 = &dog;

	ptr_animal1->speak();
	ptr_animal2->speak();

	//My animal ? ? ?
	//My cat Meow
	//My dog Woof
	//My cat ? ? ?
	//My dog ? ? ?


	return 0;
}
```

- 자식클래스를 부모클래스의 포인터를 사용하여 캐스팅하여 호출하면 자신이 부모클래스로 인식하여 호출함

___


```cpp
#include <iostream>
#include <string>

using namespace std;

class Animal
{
protected:
	string m_name;

public:
	Animal(std::string name)
		:m_name(name)
	{}

public:
	string getName() { return m_name; }

	void speak() const
	{
		cout << m_name << " ??? " << endl;
	}
};

class Cat : public Animal
{
public:
	Cat(string name)
		: Animal(name)
	{}

	void speak() const
	{
		cout << m_name << " Meow " << endl;
	}
};

class Dog : public Animal
{
public:
	Dog(string name)
		: Animal(name)
	{}

	void speak() const
	{
		cout << m_name << " Woof " << endl;
	}
};

int main()
{
	Cat cats[] = { Cat("cat1"), Cat("cat2"), Cat("cat3"), Cat("cat4"), Cat("cat5") };
	Dog dogs[] = { Dog("dog1"),Dog("dog2") };

  Animal* my_animals[] = { &cats [0],&cats[1] ,&cats[2] ,&cats[3] ,&cats[4],
	&dogs[0],& dogs[1] };

	for (int i = 0; i < 7; ++i)
		my_animals[i]->speak();

    // cat1 ???
    // cat2 ???
    // cat3 ???
    // cat4 ???
    // cat5 ???
    // dog1 ???
    // dog2 ???

	return 0;
}
```

- 상속받은 부모클래스가 같기 때문에 `my_animals[]` 안에 cats와 dogs 를 같이넣을수 있음

**virtual**

```cpp
#include <iostream>
#include <string>

using namespace std;

class Animal
{
protected:
	string m_name;

public:
	Animal(std::string name)
		:m_name(name)
	{}

public:
	string getName() { return m_name; }

	virtual void speak() const
	{
		cout << m_name << " ??? " << endl;
	}
};

class Cat : public Animal
{
public:
	Cat(string name)
		: Animal(name)
	{}

	void speak() const
	{
		cout << m_name << " Meow " << endl;
	}
};

class Dog : public Animal
{
public:
	Dog(string name)
		: Animal(name)
	{}

	void speak() const
	{
		cout << m_name << " Woof " << endl;
	}
};

int main()
{
	Cat cats[] = { Cat("cat1"), Cat("cat2"), Cat("cat3"), Cat("cat4"), Cat("cat5") };
	Dog dogs[] = { Dog("dog1"),Dog("dog2") };

	Animal* my_animals[] = { &cats [0],&cats[1] ,&cats[2] ,&cats[3] ,&cats[4],
	&dogs[0],& dogs[1] };

	for (int i = 0; i < 7; ++i)
		my_animals[i]->speak();

    // cat1 Meow
    // cat2 Meow
    // cat3 Meow
    // cat4 Meow
    // cat5 Meow
    // dog1 Woof
    // dog2 Woof

	return 0;
}
```

- `virtual void speak() const` 부모클래스에 멤버함수 앞에 `virtual` 키워드를 붙여주면 자식클래스인것 처럼 동작함

### **🌱 12.2 가상 함수와 다형성**

- 가상 함수 Virtual Functions 
- 다형성 Polymorphism

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	void print() { cout << "A" << endl; }
};

class B : public A
{
public:
	void print() { cout << "B" << endl; }
};

class C : public B
{
public:
	void print() { cout << "C" << endl; }
};

class D : public C
{
public:
	void print() { cout << "D" << endl; }
};
int main()
{
	A a;
	B b;
	C c;
	D d;

	A& ref = b;
	ref.print(); // A

	return 0;
}
```

- 레퍼런스를 A에 뒀다는 이유로 A로 출력됨
- 포인터로 해도 동일함

**virtual**

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	virtual void print() { cout << "A" << endl; }
};

class B : public A
{
public:
	void print() { cout << "B" << endl; }
};

class C : public B
{
public:
	void print() { cout << "C" << endl; }
};

class D : public C
{
public:
	void print() { cout << "D" << endl; }
};
int main()
{
	A a;
	B b;
	C c;
	D d;

	A& ref = b;
	ref.print(); // B

	return 0;
}
```

- B클래스로 만들어진 인스턴스를 A로 넣었는데 A안에있는 print()가 virtual 일경우 B클래스의 print() 가 실행이됨
- 레퍼런스에 c를 넣어도 C가 출력됨 A의 레퍼런스를 통해서 print()를 호출했을때 B를 사용하는것이아닌 C를 사용함
- 실무에서 기억안날땐 간단한 예제를 만들고 실행시켜서 테스트해보고 문법 되새김하기

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	virtual void print() { cout << "A" << endl; }
};

// class B
class B : public A
{
public:
	void print() { cout << "B" << endl; }
};

class C : public B
{
public:
	void print() { cout << "C" << endl; }
};

class D : public C
{
public:
	void print() { cout << "D" << endl; }
};
int main()
{
	A a;
	B b;
	C c;
	D d;

	B& ref = c;
	ref.print(); // C

	return 0;
}
```

- 상속단계를 끊었을때는 B가 출력이됨
- 가장 상위클래스에 있는게 virtual이 되면 하위 클래스들도 virtual이 적용이됨
  - 관습적으로 하위 클래스에도 virtual 을 적어줌

**오버라이딩시 리턴타입이 다를경우 에러가 발생함**

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	virtual void print() { cout << "A" << endl; }
};

class B : public A
{
public:
	virtual void print() { cout << "B" << endl; }
};

class C : public B
{
public:
	virtual void print() { cout << "C" << endl; }
};

class D : public C
{
public:
	virtual int print() { cout << "D" << endl;  return 0; } // Error
};

int main()
{
	A a;
	B b;
	C c;
	D d;

	B& ref = c;
	ref.print(); // C

	return 0;
}
```

- 많으면 3단계 보통 2단계 virtual 함수를 사용함
- virtual 테이블에서 함수를 찾아가는 과정을 거침
  - 호출이 빈번한 함수에 사용하면 퍼포먼스가 안좋음
  - for roop 안에 넣으면 현저히 느려짐

### **🌱 12.3 override, final, 공변 반환값**

- 공변 반환 값 Covariant

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	virtual void print(int x) { cout << "A" << endl; }
};

class B : public A
{
public:
	virtual void print(short x) { cout << "B" << endl; }
};


int main()
{
	A a;
	B b;

	A& ref = b;
	ref.print(1); // A

	return 0;
}
```

- A가 출력되는 이유
- 함수는 파라메타가 다르면 오버라이딩을 할수가 없음

___

**override**

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	virtual void print(int x) { cout << "A" << endl; }
};

class B : public A
{
public:
	virtual void print(short x) override { cout << "B" << endl; } // Error
};


int main()
{
	A a;
	B b;

	A& ref = b;
	ref.print(1); // A

	return 0;
}
```
- 예비조치로 override를 치면됨
  - 미리 에러를 잡을수 있음
- 자식클래스에서 어떤함수를 구현할때 상위클래스에 virtual 함수를 오버라이드하고싶은거라면 override를 적어 이함수는 무조건 오버라이드 해야한다고 컴파일러에게 미리 알려주는것
- const, 함수이름 등을 다르게했을때 찾을수 있음

___

**final**

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	virtual void print() { cout << "A" << endl; }
};

class B : public A
{
public:
	virtual void print() final { cout << "B" << endl; }
};

class C : public B
{
public:
	virtual void print() final { cout << "C" << endl; } // Error
};


int main()
{
	A a;
	B b;

	A& ref = b;
	ref.print(); 

	return 0;
}
```

- 밑에서 override를 못하게 막아버리고싶을때 사용하는 키워드

```cpp
#include <iostream>

using namespace std;

class A
{
public:
	void print() { cout << "A" << endl; }
	virtual A* getThis() { 
		cout << "B::getThis()" << endl; 
		return this; }
};

class B : public A
{
public:
	void print() { cout << "B" << endl; }
	virtual B* getThis() { 
		cout << "B::getThis()" << endl;
		return this; }
};

int main()
{
	A a;
	B b;

	A& ref = b;
	b.getThis()->print();
	ref.getThis()->print();

	cout << typeid(b.getThis()).name() << endl;
	cout << typeid(ref.getThis()).name() << endl;

  // B::getThis()
  // B
  // B::getThis()
  // A
  // class B * __ptr64
  // class A * __ptr64

	return 0;
}
```

- 레퍼런스 가 A이기 때문에 B의 포인터를 리턴해줘도 내부적으로 A포인터로 변환한 다음에 호출하는 구조임

### **🌱 12.4 가상 소멸자**

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
	~Base()
	{
		cout << "~Base()" << endl;
	}
};

class Dericed :public Base
{
private:
	int* m_array;

public:
	Dericed(int length)
	{
		m_array = new int[length];
	}

	~Dericed()
	{
		cout << "~Dericed()" << endl;
		delete[] m_array;
	}
};

int main()
{
	Dericed dericed(5);

	//~Dericed()
	//~Base()

	return 0;
}
```

- 소멸자 호출순서는 생성자 호출순서의 반대임

**다형성 구조**

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
	~Base()
	{
		cout << "~Base()" << endl;
	}
};

class Dericed :public Base
{
private:
	int* m_array;

public:
	Dericed(int length)
	{
		m_array = new int[length];
	}

	~Dericed()
	{
		cout << "~Dericed()" << endl;
		delete[] m_array;
	}
};

int main()
{
	Dericed* dericed = new Dericed(5);
	Base* base = dericed;
	delete base;

  // ~Base()

	return 0;
}
```

- base의 소멸자만 생성이됨
  - 메모리 릭이 생김
  - 컨테이너를 사용하면 자동으로 해결됨

___

**소멸자에 virtual키워드**

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
	virtual ~Base()
	{
		cout << "~Base()" << endl;
	}
};

class Dericed :public Base
{
private:
	int* m_array;

public:
	Dericed(int length)
	{
		m_array = new int[length];
	}

	virtual ~Dericed() override
	{
		cout << "~Dericed()" << endl;
		delete[] m_array;
	}
};

int main()
{

	Dericed* dericed = new Dericed(5);
	Base* base = dericed;
	delete base;

  // ~Dericed()
  // ~Base()

	return 0;
}
```

- virtual을 떼면 `override` 를 적었을때 에러가 발생함

### **🌱 12.5 동적 바인딩과 정적 바인딩**

- Binding

**정적 바인딩 Static Binding**

```cpp
#include <iostream>

using namespace std;

int add(int x, int y)
{
    return x + y;
}

int subtract(int x, int y)
{
    return x - y;
}


int main()
{
    int x, y;
    cin >> x >> y;

    int op;

    cout << "0: add, 1: subtract" << endl;
    cin >> op;

	// static binding(early binding) 
    int result;
    switch (op)
    {
    case 0: result = add(x, y); break;
    case 1: result = subtract(x, y); break;
    }
}
```

- 모든 변수명이나 함수명이 빌드타임에 정리되어 있는것을 static binding(early binding) 이라고함

**동적 바인딩 Dynamic Binding**

```cpp
#include <iostream>

using namespace std;

int add(int x, int y)
{
    return x + y;
}

int subtract(int x, int y)
{
    return x - y;
}


int main()
{
    int x, y;
    cin >> x >> y;

    int op;

    cout << "0: add, 1: subtract" << endl;
    cin >> op;

    int(*func_ptr)(int, int) = nullptr;
    switch (op)
    {
    case 0: func_ptr = add; break;
    case 1: func_ptr = subtract; break;
    }

	cout << func_ptr(x, y) << endl;
}
```

- func_ptr의 주소가 런타임에 결정됨
- 펑션포인터에 저장되어 있는 주소를 찾아가서 주소자리에 있는 함수를 실행시킴

___

- 속도: 정적 바인딩 > 동적 바인딩 

- 대신 동적 바인딩을 사용하면 프로그램이 조금 더 유연해짐

### **🌱 12.6 가상 (함수) 표**

- Virtual Tables
- virtual 이 선언되면 virtual의 표를만들고 동적바인딩을 함

**부모 class virtual 함수 선언 순서**
  1. virtual 함수가 선언되면 virtual의 표에 가서 해당 함수의 포인터를 찾음
  2. 해당 함수의 포인터가 가르키는 주소에감
  3. 그 주소에 있는 함수를 실행시킴

**자식 class virtual 함수 선언 순서**
  1. virtual 함수가 선언되면 virtual의 표에 가서 해당 함수의 포인터를 찾음
  2. 오버라이딩이 되어있는 함수면 자식클래스의 함수로 가서 실행시킴
  3. 오버라이딩이 되어있지 않은 함수면 부모클래스로 가서 실행시킴

- 자식클래스로 생성이 된객체로 호출해도 Virtual Tables 이 바뀌지 않기때문에 다형성을 사용할수 있는것

___

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
    void fun1() {};
    void fun2() {};
};

class Derived : public Base
{

};

int main()
{
    cout<< sizeof(Base) << endl; // 1
    cout<< sizeof(Derived) << endl; // 1

    return 0;
}
```

**virtual**

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
    virtual void fun1() {};
    void fun2() {};
};

class Derived : public Base
{

};

int main()
{
    cout << sizeof(Base) << endl; // 8
    cout << sizeof(Derived) << endl; // 8

    return 0;
}
```

- 부모클래스는 가상 함수를 가짐, 가상 함수 포인터를 갖고 있음
- 가상 함수 포인터 때문에 가상 함수를 가지지 않았을 때보다 크기가 더 커짐
- 자식클래스는 부모클래스로부터 가상 함수 포인터를 상속받기 때문에 얘도 똑같이 크기가 더 커짐

### **🌱 **

### **🌱 **

### **🌱 **

### **🌱 **

### **🌱 **

# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)