---
published: true
title:  "따라하며 배우는 C++"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL, C++]

toc: true
toc_sticky: true
 
date: 2022-04-02
last_modified_at: 2022-04-02
---

# 🤔 학습목표
- 따라하며 배우는 C++

# 📃 학습내용
## 📍 **따라하며 배우는 C++**
> 선수지식으로 유튜브에있는 따배씨 언어 강의를 다 듣고왔는데 결재할만한 강의라고 판단되어 인프런에서 따배씨++ 강의를 구매하였다
네이버 포인트로 4만원정도 가량 모아둔돈을 사용해서 결재했다 네이버 포인트를 차곡차곡 모아두길 잘한것같다

- ### **강의 구매 인증!!**
![강의 구매 인증!!](https://user-images.githubusercontent.com/90514882/161372466-ba058849-459b-4c5c-8647-68313849cbe9.PNG)


### 📌 **섹션0. 시작해봅시다**

**🌱 0.0 C++ 꼭 공부해야 할까?**

- **피카소**
  - 좋은 예술가는 베낀다.
  - 위대한 예술가는 훔친다.

- **공부순서**
1. 올바른 타이핑 방법을 연습한다
2. 간단한 개념을 이해한다
   - 처음엔 완벽히 이해할필요없이 간단히 배웠던걸 떠올릴정도로 익히기
3. 예제를 따라 해본다
   - 직접 따라서 타이핑하고 실행하기
4. 문제가 생기면 해결한다
5. 예제를 내 맘대로 바꿔본다

**다른 언어를 배울때**
- 프로그래밍을 배우는 이유는 무언가를 만들기 위해서
- 블록체인, 인공지능, 데이터처리, 게임개발 등등...
- C나 C++ 를 배우면 다른언어를 배울때 핵심 요소만 배워서 바로 적용하기 좋음 

**🌱 0.1 프로그래밍 언어란**

- **프로그램**
  - 우리가 원하는 기능을 수행해줌
- **어플리케이션**
  - 애플에서나온것과 맞추기위해 이름이 어플리케이션임 프로그램이랑 똑같음
- 소프트웨어
- 하드웨어 

- **기계어(Machine Language)**
  - Machine 컴퓨터를 의미함
  - 전압에 따라 신호를 인식함 
    - 0과 1
  - 어셈블리 언어(Assembly Language)
    - 메모리의 정보를 옮기는 등의 사용되는 저수준 언어

- **고수준 언어(High-Level Languages)**
  - c, c++, Pascal, java 등등
  - 하드웨어에 가까운것이 저수준 언어
  - 사람에 가까운 언어가 고수준 언어

- **컴파일러**
  - 컴파일러도 프로그램임
  - 고수준 언어로 쓰여진 코드 → 컴파일러 → 실행파일(코드로 만들어진 프로그램)
  - 실행파일 → 중앙처리장치(CPU) → 실행결과 
  - 실행파일은 하드디스크에 저장됨
    - 개발환경에서 안보여주는 경우도있음

- **인터프리터(interpreter)**
  - 고수준 언어로 쓰여진 스크립트 → 인터프리터 → 중앙처리장치(CPU) → 실행 결과
  - 스크립트: 코드랑 똑같은데 인터프리터로 작성된 프로그램을 스크립트라고 불린 관습이 있음
  - 여러번 실행시키면 인터프리터를 여러번 거쳐야하기때문에 느림
  - 인터프리터도 프로그램임

- **이식성(Portability)**
  - os마다 컴파일러가 다름
  - 실행파일도 다름
    - 윈도우즈 와 리눅스의 실행파일이 달라서 서로호환이 안되는경우가있음
    - 자바: 소스파일 → 컴파일러 → 바이트 코드
      - 바이트코드 → 윈도우 가상 기계 → 윈도우즈 실행결과
      - 바이트 코드 → 리눅스 가상 기계 → 리눅스 실행결과

**🌱 0.2 C/C++ 언어 소개**

- **Dennis Ritchin(1941 - 2011)**
  - C언어 창시자
  - C++ 이전에 C가 있었음
  - 어셈블리 언어가 불편해서 C 언어를 만듬

- **Biarne Stroustrup**
  - c++ 창시자
  - c++ 는 c에서 확장된개념 객체지향기능이 추가됨 

- **C/C++ 언어의 설계 철학**
  - 프로그래머를 믿어라
  - 실제 세계에서 쓸모가 있어야 한다
  - 프로그래머가 스스로 스타일을 선택할 수 있어야 한다
  - 유용한 기능을 추가하는 것이 오용보다 더 중요하다
  - 프로그래머의 의도를 알 수 없다면 스스모 명시하게 한다
  - c++ 아래에 다른 언어 없다
    - 어셈블리어는 예외

- 파이썬 내부가 C++로 이루어짐

**🌱 0.3 프로그래밍 과정 소개**

1. 풀어야 할 문제를 정의한다
2. 해법을 설계한다
3. 해법을 구현하는 프로그램을 작성한다 (write)
4. 프로그램을 컴파일 한다 (compile)
   - g++ - 컴파일러 
   - cpp 파일을 오브젝트 파일로 만드는 것
5. 오브젝트 파일 (Object)들을 링킹 한다 (Linking)
   - 링커가 오브젝트파일들을 모아서 실행파일을 만듬
   - 링커에 런타임 서포트가 추가됨
     - 런타임 서포트: 다른 프로그래머가 만든 것들 오픈소스개념임 
6. 테스트해보고 문제가 있으면 고친다

**🌱 0.4.0 통합개발환경의 기본적인 사용법 - 윈도우즈 비쥬얼 스튜디오**
- 통합개발환경 IDE(Integrated Development Environnment) 
- 비주얼 c++ → 윈도우 개발 마법사

**Application type**
- Windows Application (.exe)
- Console Application (.exe)
  - 콘솔창으로 결과를 실행할때 사용
- Dynamic Link Library (.dll)
  - 기존에 만들어진 프로그램에 기능을 추가할때 사용
- Static Library (.lib)
  - 기존에 만들어진 프로그램에 기능을 추가할때 사용 

**Precompiled Header** 
- 대형 프로젝트할때 빌트타임을 줄여주는것
- 멀티 플랫폼 코드를 짤때는 사용하면 안됨
  - 리눅스에서 컴파일이 안됨
  - 윈도우즈 전용파일일때 사용

- 에러 떳을때 한글로하면 알아보기힘들기때문에 영어로설정하는게좋음

- 소스 폴더 우클릭 → add → New item → C++ File (.cpp)

- #include
  - 다 갖고와서 포함시킨다는 개념

- 빌드 솔루션 버튼
 
- exe
  - excute 의 약자로 실행파일 이름임

- 프로젝트 파일 우클릭 → 상위 폴더 열기

- myfirstHelloWorld → myfirstHelloWorld(cpp 파일 저장경로) → x64 → Debug → obj파일 저장 경로 
  - 리눅스는 o
  - 윈도우는 obj

- myfirstHelloWorld → x64 → Debug → exe 파일 저장경로

- VSC에서 exe 파일 실행 시키기
  - 디버깅 하기않고 실행 (Ctrl + F5)

- VSC 쓰지않고 exe 파일 실행 시키기
  - cmd 

**C++ HelloWorld 소스코드**
```cpp
#include <iostream>

int main()
{
	std::cout << "Hello, World!" << std::endl;

	return 0;
}
```
- std::cout
  - 스탠다드 콘솔 아웃 이라는뜻

- 코드에 갖다대고 정의로 이동

- << 물흘러가는 모양이랑 비슷해서 stream이라고함
- :: 네임 스페이스라고함 

- cmd 로고 누르면 환경설정 등 메뉴가나옴
- 빌드 → 솔루션 정리
  - 이전 빌드했던 데이터 싹 사라짐

- 디버그 와 릴리즈 가있음
  - 릴리즈 모드에선 디버그가 안됨
  - 릴리즈로 빌드하면 용량이 4배나 줄어들음
  - 실제 배포할때는 릴리즈모드로 해야함
  - 개발할때는 디버그 모드

- x86
  - 이름만 x86 칩번호이름이라그럼 실직적으론 32비트
  - x86 칩에 대응하는게 x64 64비트
  - 32비트와 64비트의 차이
    - 64비트에서는 메모리를 많이 사용할때 사용
    - 32비트에서는 제한이 있음
    - 최근엔 64로 대부분 사용

**🌱 0.4.1 통합개발환경의 기본적인 사용법 - 윈도우즈 리눅스 코드블럭스**

- 윈도우와 리눅스 를 왔다갈다 할때 사용함
- 오픈소스임

**🌱 0.4.2 비쥬얼 스튜디오 솔루션, 프로젝트 관리**
- **솔루션**
  - 프로젝트 1
  - 프로젝트 2
  - ...

- 새프로젝트 만들면 프로젝트가아니라 솔루션을 만드는 것임

- 솔루션에 우클릭 → 추가 → 새프로젝트 로 프로젝트 추가
- 프로젝트 폴더 우클릭 → 추가 → 새 항목 으로 cpp파일 추가

- 빌드는 여러개의 프로젝트라도 솔루션파일 내부에 저장됨
- 디버그는 볼트체인 프로젝트가 실행됨 
  - 프로젝트 우클릭 → 시작 프로젝트로 설정으로 변경가능
- 콘솔창이 바로 떳다가 사라지는 경우
  - 프로젝트 우클릭 → 속성 → 링커 → 시스템 → 하위 시스템을 콘솔로 바꾸기 
- sln은 솔루션 파일임

**🌱 0.5 코딩하다 막혔을 때는?**

- 당황하지도 분노하지도 말자
- IDE의 도움을 받는다 
  - 아웃풋 창을 읽기
- 검색엔진의 도움을 받는다
  - 스택오버플로우
- 커뮤니티의 도움을 받는다
- 커뮤니케이션이 중요함

### 📌 **섹션1. C++의 기초적인 사용법**

**🌱 1.1 프로그램의 구조**

- 표현식 (Expressions)
- 명령문 (Statements)
- 함수 (Functions)
- 라이브러리, 표준 라이브러리

- 숫자 0 은 0안에 막대기가 그어짐 O랑 구분할때좋음
- 운영체제가 실행시켜주는것
- 프로그램의 최소단위를 함수라고함
  - 함수: 입력이 주어지면 함수에서 처리를 해서 출력이 나오는것
  - main 함수를 바꿀순없음
    - OS가 프로그램을 실행할떄 main부터 찾음
  - 컴파일러는 빈줄을 안읽음
  - 함수에 아무것도 안넣을때는 void 나 아무것도 안넣음

```cpp
#include <iostream>

int main(void)
{
	int x = 2;
	x = 5;
	int y = x + 3;

	std::cout << y << std::endl;

	return 0;
}
```

- return 은 main 함수의 출력값을 돌려주는 것
  - 리턴 스테이트먼트 라고불름
  - 관습적으로 명령문이라고 부름
  - C나 C++에서는 문장의 끝을 표현하는걸 ; 로 표현함 

- 1+1 이런 요소들을 Expressions 이라고함
- int x;
  - int 라는 정수형 데이터를 x라는 이름으로 메모리를 할당하는것

- 숫자 2 나 5 이런것들을 리터럴 (literal) 이라고 부름

- iostream
  - 입출력을 가능하게 해주는 기능을 포함 시킴
- `#include` 이 붙는걸 전처리기 (preprocessor directive) 라고부름
- 네임스페이스
  - 비슷한 기능들을 하는 걸 묶어놓거나
  - 이름이 겹칠수 있는것들을 다른공간에 모아두는것

- :: 네임스페이스 안에 들어있는 cout에 접근 하는것
- << 아웃풋 오퍼레이터 연산자다 라는 것
- `std::endl` 띄어 쓰기됨

**문제**
- **Q.표현식과 명령문의 차이는 뭘까?**
  - A. 
    - 표현식 (Expression)은 ‘수식’이라는 뜻으로 하나 이상의 값으로 표현(reduce)될 수 있는 코드를 말한다 `1+1`이나 `2+5` 등등
    - 명령문(statement)는 ‘진술’, ‘서술’의 의미로 프로그래밍에서는 실행가능한(executable) 최소의 독립적인 코드 조각을 일컫는다 `return 3` 같은 것들
    -  **expression은 statement의 부분집합이다**
- **Q. 함수와 라이브러리의 차이는 뭘까?**
  - A. 
    - 함수란 어떠한 기능을 수행해주는 것 입출력이 없을수도있음
    - 라이브러리는 기존에 다른 프로그래머들이 만들어놓은 함수의 집합체 
- **Q. C++에서 문장을 끝내는 기호는 뭘까?**
  - A. 세미콜론 `;`
- **Q. 문법 오류란 무엇인가?**
  - A. 컴파일러가 이해할수 없는 오류를 말함

**🌱 1.2 주석 comments**

**주석 잘 다는 방법**
- 주석이란 컴파일러가 코드를 무시하게 하는 것
- C 나 C++ 에서 주석다는법
  - `//x = 5;`
  - `/*x = 5;*/`

- **비쥬얼 스튜디오에서는 Ctrl + K → Ctrl + C 로 주석 처리 할수있음** 
- **비쥬얼 스튜디오에서는 Ctrl + K → Ctrl + U 로 주석 처리 할수있음**

- 주석을 달때는 내가지금 왜하는지 무엇을 하는지 기록해두기
  - 구현 단계에서는 어떻게 구현한다고 쓰는게 좋음
- 주석은 기능에 대한 설명보다는 어떻게 되어서 이 기능이 되는지 적어야함
  - `// set sight to be 0` 이런거 금지
- 내가 헷갈릴 만한것들에 주석 달기
```cpp
	int sight = 10;

	//...

	// 마법의 물약을 먹어서 시야 거리가 0
	// set sight to be 0
	sight = 0;
```

**🌱 1.3 변수와의 첫 만남**
- 객체 (object)
  - 메모리에 저장이 되어있는 어떠한 정보
- 변수 (variavles)
  - 메모리에 담겨있는 객체의 이름
- Left-values 과 Right-values
  - L-Values
  - R-Values
  - 구분하는 기준도 메모리 주소를 프로그래머가 직접적으로 접근할수 있는지 없는지
- 초기화(initialization)와 대입(assignment)
- 초기화를 안 했을 때의 문제점
- 컴퓨터 프로그래밍은 정보를 다루는것

**변수의 종류**

**int** 
  - integer의 약자
  - `int x = 123;`
    - x라는 변수를 선언했다 라는 뜻
    - x라는 변수이름이 가르키고있는 메모리 공간에 123이라는 정수를 저장 한다 라는 의미
  - `int x; x = 123;`
  - `=` 을 assignment 라고함 대입에 가까움
  - `&` 를 ampersand 라고함
    - `std::cout << &x << std::endl;` 내부적으로 x의 메모리 주소를 표현할때 &을 사용함
  - `x = 123`
    - x가 L-values
    - 123이 R-values
  - `x = x + 2;`
    - 오른쪽에 있는 x는 변수로써 작동하는게 아닌 현재 가지고있는 값이 R-values 가됨
  - `int x;` 이렇게 선언만하고 초기화`X=3`를 안해주면 Warring 이 발생함
  - 릴리즈모드에서도 워닝은 뜸 OS 에서 자기 맘대로 값을 넣음 변수는 꼭 초기화하기

- **런타임에러**
  - 메모리에 접근할때 뭔가 석연찮을때 뜸
  - OS 에서 경고해주는것


```cpp
#include <iostream>

int main(void)
{
	int x = 123; // initaliztion
	x = 5; // assignment

	std::cout << &x << std::endl;
	return 0;
}
```
- `int x = 123` 
  - 메모리 자리를 할당받을때 123을 바로 넣어버리는 것(initaliztion) ,assignment 랑 다름 꼭 구분하기
  - `int x(123)` 이렇게 사용할수도 있음 

**출력결과 예측하기**
```cpp
#include <iostream>

int main(void)
{
	int x = 1;
	x = x + 2;
	std::cout << x << std::endl; //#1

	int y = x;
	std::cout << y << std::endl; //#2

	//is (x + y) ;-value or r-value ?
	std::cout << x + y << std::endl; //#3

	std::cout << x << std::endl; //#4

	int z;
	std::cout << z << std::endl; //#1

	return 0;
}
```
1. 3
2. 3
3. 6
4. 3
5. 0
    - 초기화를 안해줘서 os에서 임의로 할당할텐데 vs에서 에러가 떠서 빌드 자체가 안됨 

**🌱 1.4 입출력 스트림과의 첫 만남 cin,cout**

**cin**
- 콘솔 인을 의미함
- `std::cin >> x;` 이런식으로 사용함
- 정수형데이터에 큰값을 넣으면 정수형데이터의 최대 데이터가 출력됨

```cpp
#include <iostream> // cout, cin, endl, ...
#include <cstdio> // printf

int main(void)
{
	using namespace std;

	int x = 1;

	cout << "Before your input, x was" << x << endl;

	cin >> x;

	cout << "Your input is" << x << endl;

	return 0;
}
```

**cout**
- 콘솔 아웃을 의미함
- `#include <iostream> // cout, cin, endl, ...`
  - 인풋 아웃풋 스트림을 포함(include) 해줘야 사용가능
  - `std::cout`
    - std 는 네임 스페이스 안에 정의 되어있는 cout을 사용하기 위해서 :: 를 사용함 
  - `std::cout << "I love this lecture" << std::endl;`
    - << 를 아웃풋 오퍼레이터 라고함

- std::cout << "abc" << "\t" << "def" << std::endl;
  - `"\t"` 탭기능임
  - \t 어떠한 기능을 의미

- std::cout << "I love this lecture\n";// << std::endl;
  - `\n` 은 줄바꿈 기능

- `using namespace std;` 사용하면 std 를 안붙여도됨
  - 컴파일러가 엔드라인이나 세미콜론을 만났을때 네임스페이스안에서 찾아서 컴파일해줌
- `cout << "\a";`
  - 띵동 소리를 출력해줌
- C언어에서는 prinf("문자열"); 이렇게 출력함

```cpp
#include <iostream> // cout, cin, endl, ...
#include <cstdio> // printf

int main(void)
{
	using namespace std;
	int x = 1024;
	double pi = 3.141592;

	cout << "I love this lecture\n";// << std::endl;
	cout << "x is" << x << "pi is"<< pi << std::endl;

	cout << "abc" << "\t" << "def" << std::endl;
	cout << "ab" << "\t" << "cdef" << std::endl;

	cout << "\a";
	return 0;
}
```

**endl**
- 엔드라인을 의미함

**🌱 1.5 함수와의 첫 만남**

**입출력이 있는 예제코드1**

```cpp
#include <iostream> // cout, cin, endl, ...
#include <cstdio> // printf

using namespace std;

int addTwoNumbers(int num_a, int num_b)
{
	int sum = num_a + num_b;

	return sum;
}

int main(void)
{

	cout << addTwoNumbers(1, 2) << endl;
	cout << addTwoNumbers(3, 4) << endl;
	cout << addTwoNumbers(8, 13) << endl;

	return 0;
}
```

**입출력이 없는 예제코드**
```cpp
#include <iostream> // cout, cin, endl, ...
#include <cstdio> // printf

using namespace std;

void printHelloWorld()
{
	cout << "Hello World" << endl;

	return;

	cout << "Hello World" << endl; // 실행되지않음
}
int main(void)
{
	printHelloWorld();

	return 0;
}
}
```

**함수 리턴값으로 바로 초기화 하기**
```cpp
#include <iostream> // cout, cin, endl, ...
#include <cstdio> // printf

using namespace std;

int addTwoNumbers(int a, int b)
{
	return a + b;
}


int main(void)
{
	int sum = addTwoNumbers(1, 2);

	return 0;
}

```
**함수 (Function)**
- 한가지 패턴이 여러번 나타나면 함수로 구분
- 함수의 자료형과 리턴 자료형은 같아야함 

**리턴값 (return values)**
- 함수에서 계산된 값을 돌려주는 값
- `return 0;`이 리턴값임


**매개변수 (parameters)**
- 함수에 들어와서 사용되는값
- `int addTwoNumbers(int num_a, int num_b)` 중 `(int num_a, int num_b)`가 매개변수임

**인수 (arguments)**
- 함수를 호출,콜 할때 사용되는 값 `cout << addTwoNumbers(1, 2) << endl;` 중 `(1, 2)` 가 인수임 

>**함수명에 마우스 우클릭 → 이름바꾸기(Ctrl + R, Ctrl + R) 눌러서 이름 전체 바꾸기 가능**
- 비쥬얼 스튜디오에서 숫자 왼쪽에 브레이크 포인트 찍어서 확인 가능, F9눌러서 찍어도됨
    - F10, F11 으로 한단계 씩 넘어가며 확인가능 
    - 한단계 씩 넘어가면서 변수에 마우스 갖다대면 현재 변수값이 뜸

- 출력값이 없는 함수에는 void 값을 넣어줌
  - `void printHelloWorld(void)` 
    - `(void)` 는 `()` 처럼 아무것도 안넣어도됨
    - 출력해줄 값이 없다면 `return;` 을 넣어도됨
    - return 값을 만나면 바로 값을 반환해주기 때문에 return 아래의 구문은 실행되지 않음

- 함수 끼리 호출 가능
  - **C++ 은 함수안에서 함수를 정의 할 수 없음!**

**연습문제**
- 사용자로 부터 여러번 입력받아서 여러번 출력하는 코드 작성하기

```cpp
#include <iostream> // cout, cin, endl, ...
#include <cstdio> // printf

using namespace std;

int addTwoNumbers(int a, int b)
{
	return a + b;
}

int main(void)
{
	int a;
	int b;
	cin >> a;
	cin >> b;
	cout << addTwoNumbers(a, b) << endl;

	return 0;
}
```





**🌱 1.**
**🌱 1.**
**🌱 1.**
**🌱 1.**


### 📌 **섹션2. 변수와 기본적인 자료형**

### 📌 **섹션3. 연산자들**

### 📌 **섹션4. 변수 범위와 더 다양한 변수형**

### 📌 **섹션5. 흐름제어**

### 📌 **섹션6. 행렬,문자열,포인터,참조**

### 📌 **섹션7. 함수**

### 📌 **섹션8. 객체지향의 기초**

### 📌 **섹션9. 연산자 오버로딩**

### 📌 **섹션10. 객체를 사이의 관계에 대해**

### 📌 **섹션11. 상속**

### 📌 **섹션12. 가상 함수들**

### 📌 **섹션13. 템플릿**

### 📌 **섹션14. 예외 처리**

### 📌 **섹션15 의미론적 이동과 스마트 포인터**

### 📌 **섹션16. 표준 템플릿 라이브러리**

### 📌 **섹션17. std:string 문자열 클래스**

### 📌 **섹션18. 입력과 출력**

### 📌 **섹션19. 모던 C++필수 요소들**

### 📌 **섹션20. 중급 프로그래머들의 상식**


# 😊 배우게 된 점
**2022-04-02 TIL** - 오늘 처음 인프런 강의를 구매하고 ~~~ 까지 강의를 들었는데 진짜 너무재밌다... 재밌어서 기분 좋을 정도 강의 천천히 꼼꼼하게 알려주셔서 메모하면서 듣기도 좋다


# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)