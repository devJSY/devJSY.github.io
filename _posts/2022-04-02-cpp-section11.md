---
published: true
title:  "따라하며 배우는 C++ Section 11. 상속"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-04-25
last_modified_at: 2022-04-25
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 11. 상속

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 11. 상속**

### **🌱 11.1 상속의 기본 (1)**

- Inheritance (is-a relationship)
- 상속의 기본적인 문법적인 측면
- 객체지향에서의 상속은 부모클래스가 사라진다던가 없어지는 의미가 아님 다만 안보일 뿐임

**상속 기본 문법**

```cpp
#include <iostream>

using namespace std;

class Mother
{
private:
	int m_i;

public:
	/*Mother(const int& i_in)
		: m_i(i_in)
	{
		std::cout << "Mother constructor " << std::endl;
	}*/

	void setValue(const int& i_in)
	{
		m_i = i_in;
	}

	int getValue()
	{
		return m_i;
	}
};

class Child :public Mother // derived class
{

};

class Daughter : public Mother
{

};

class Son : public Mother
{

};

int main()
{
	Mother mother;
	mother.setValue(1024);
	cout << mother.getValue() << endl; // 1024

	Child child;
	child.setValue(128);
	cout << child.getValue() << endl; // 128

	return 0;
}
```

- `class Child :public Mother {}` 
  - `Mother` class 를 상속받는 `child` class
  - public 대신 private를 사용해도됨
- 자식클래스는 부모클래스에 있는것들을 기본적으로 다 사용함
  - 그 와중에 캡슐화같은 개념을 유지
- 부모클래스로 부터 많은 자식 클래스를 유도해서 만들수 있음
  - 상속을 받은 클래스를 **derived class** 라고 부름
- 원 취지는 여러 클래스가 있고 그것으로부터 일반화된 요소들을 뽑아서 만드는 것

___

```cpp
#include <iostream>

using namespace std;

class Mother
{
protected:
	int m_i;

public:
	/*Mother(const int& i_in)
		: m_i(i_in)
	{
		std::cout << "Mother constructor " << std::endl;
	}*/

	void setValue(const int& i_in)
	{
		m_i = i_in;
	}

	int getValue()
	{
		return m_i;
	}
};

class Child :public Mother 
{
private:
	double m_d;

public:
	void setValue(const int& i_in, const double& d_in)
	{
		Mother::setValue(i_in);
		m_d = d_in;
	}

	void setValue(const double& d_in)
	{
		m_d = d_in;
	}

	double getValue()
	{
		return m_d;
	}
};

int main()
{
	Mother mother;
	mother.setValue(1024);
	cout << mother.getValue() << endl; // 1024

	Child child;
	child.Mother::setValue(1024);
	child.setValue(128);
	cout << child.getValue() << endl; // 128

	return 0;
}
```

- 부모클래스와 자식클래스의 동일한 이름의 함수를 만든뒤 호출하게되면 자식클래스의 함수가 실행이됨
  - 상속 상태를 유지하려면 
- private 는 자식한테도 허용이 안됨
  - public은 밖에서도 다 접근이 가능함
  - 이때 protected 를 사용할수 있음
    - private를 사용하면서 자식한테도 허용이 됨
- 자식 생성자를 만드는 목적은 부모 클래스로부터받은 변수와 자식 클래스의 변수를 함께 사용하기 위해 처음에 같이 만듬

___

**자식 클래스 초기화 방법**

```cpp
#include <iostream>

using namespace std;

class Mother
{
protected:
	int m_i;

public:
	/*Mother(const int& i_in)
		: m_i(i_in)
	{
		std::cout << "Mother constructor " << std::endl;
	}*/

	void setValue(const int& i_in)
	{
		m_i = i_in;
	}

	int getValue()
	{
		return m_i;
	}
};

class Child :public Mother 
{
private:
	double m_d;

public:
	Child(const int& i_in, const double& d_in)
		/*: m_i(i_in), m_d(d_in)*/
	{
		Mother::setValue(i_in);
		m_d = d_in;
	}

	void setValue(const int& i_in, const double& d_in)
	{
		Mother::setValue(i_in);
		m_d = d_in;
	}

	void setValue(const double& d_in)
	{
		m_d = d_in;
	}

	double getValue()
	{
		return m_d;
	}
};

int main()
{
	Mother mother;
	mother.setValue(1024);
	cout << mother.getValue() << endl; // 1024

	Child child(1024,128);
	/*child.Mother::setValue(1024);
	child.setValue(128);*/
	cout << child.Mother::getValue() << endl; // 1024
	cout << child.getValue() << endl; // 128

	return 0;
}
```

- `: m_i(i_in), m_d(d_in)` 자식 생성자에서 이게 안되는 이유는 생성자 호출 순서 때문임
  - 부모클래스의 `protected` 등과는 연관이없음
- 자식 클래스가 생성이 될때 내부적으로 부모클래스의 생성자를 같이 호출함
- 상속을 받을때는 부모클래스를 싸그리 다 가져오는것이 아니고 생성되는 단계를 거쳐서 받아옴


```cpp
class Mother
{
protected:
	int m_i;

public:
	Mother()
		: m_i(0)
	{}

};
```

- 상속받기 어려울 때 이런식으로 부모클래스의 생성자를 디폴트 생성자로 해놓는 경우도 있음
- 기본 생성자를 알아서 호출해주기 때문임

**상속 제일 깔끔한 방법**

```cpp
#include <iostream>

using namespace std;

class Mother
{
protected:
	int m_i;

public:
	Mother(const int& i_in)
		: m_i(i_in)
	{
		std::cout << "Mother constructor " << std::endl;
	}

	void setValue(const int& i_in)
	{
		m_i = i_in;
	}

	int getValue()
	{
		return m_i;
	}
};

class Child :public Mother 
{
private:
	double m_d;

public:
	Child(const int& i_in, const double& d_in)
		:Mother(i_in), m_d(d_in)
	{}

	void setValue(const int& i_in, const double& d_in)
	{
		Mother::setValue(i_in);
		m_d = d_in;
	}

	void setValue(const double& d_in)
	{
		m_d = d_in;
	}

	double getValue()
	{
		return m_d;
	}
};

int main()
{
	Mother mother(0);
	mother.setValue(1024);
	cout << mother.getValue() << endl;

	Child child(1024,128);
	cout << child.Mother::getValue() << endl;
	cout << child.getValue() << endl; 

	return 0;
}

```

- 자식클래스가 들어온 변수값을 부모클래스에 넣어주기
- 기본적으로는 싹 퍼블릭으로 놓고 디폴트 생성자를 만들어서하면 머리안아프게 할순있지만 객체지향에 익숙해지면 위와같이 구현할 수 있음

### **🌱 11.2 상속의 기본 (2)**

- Inheritance (is-a relationship)

- 학생, 교사 는 사람이라는 객체로 묶을수 있음
  - 공통적인 부분을 묶어서 하나의 객체로 만들수 있음
- class Wizard 
  - Bass class를 부모클래스를 뜻함
  - 기본적으로 사용하는것을 자동으로 타이핑해주는 도구
  - 위자드말고 직접 만들어 사용하는 경우도 있음
- class는 여러 헤더파일을 만들어 분리하는게 좋음
- 부모클래스의 멤버변수를 관리하는 1차적인건 부모클래스에 있음 자식클래스가 호출되는 상황에선 멤버변수가 아직 정리안되어 있음
- 자식클래스에서 부모클래스의 생성자를 호출해서 간접적으로 초기화하는 방식으로감 
- 객체지향의 장점으로 중복되는 기능을 추가, 수정, 유지보수할때 부모클래스에서만 바꿔주면 전부 적용되니 편함
- 함수 밖에 `using namespace std` 를 사용하면 include 되는 모든 파일에 전부 적용이 되기 때문에 비추임
  - 기능 함수를 cpp파일로 빼고 cpp파일 안에서 사용하는게 일반적임
- 보통은 부모클래스에 기능을 때려박는것보단 자식클래스에 기능을 나누는게 유지보수하기 좋음
  - 다른사람이 보기에도 납득이가는 구조로 설계를해야 좋음
- 자식클래스에 구현된 기능을 부모클래스로 호출은 불가능함

**Person.h**

```cpp
#pragma once

#include<iostream>
#include <string>

class Person
{
	private:
	std::string m_name;
	
	public:
	// 1.
	// Person()
	// 	: m_name("No Name")
	// {}
	
	// 2.
	Person(const std::string & name_in = "No Name")
		: m_name(name_in)
	{}
	
	void setName(const std::string & name_in)
	{
		m_name = name_in;
	}
	
	std::string getName() const
	{
		return m_name;
	}
	
	void doNothing() const
	{
		std::cout << m_name << " is doing nothing " << std::endl;
	}
};
```

**Teacher.h**

```cpp
#pragma once

// #include <string>
#include "Person.h"

class Teacher : public Person
{
	private:
	///TODO: more members like home address, ...
	
	public:
	Teacher(const std::string & name_in = "No name")
		: Person(name_in)
	{}
	
	void teach()
	{
		std::cout << getName() << " is teaching " << std::endl;
	}
	
	friend std::ostream & operator << (std::ostream & out, const Teacher & teacher)
	{
		out <<teacher.getName();
		return out;
	}
};
```

**Student.h**

```cpp
#pragma once

#include "Person.h"

class Student : public Person
{
	private:
	int m_intel; // intelligence
	
	public:
	Student(const std::string & name_in = "No name", const int & intel_in = 0)
		// : m_name(name_in), m_intel(intel_in)
		: Person(name_in), m_intel(intel_in)
	{}
	
	void setIntel(const int & intel_in)
	{
		m_intel = intel_in;
	}
	
	int getIntel()
	{
		return m_intel;
	}
	
	void study()
	{
		std::cout << getName() << " is studying " << std::endl;
	}
	
	friend std::ostream & operator << (std::ostream & out, const Student & student)
	{
		out << student.getName();
		return out;
  }
	
```

**school.cpp**

```cpp
#include "Student.h"
#include "Teacher.h"

int main()
{
	Student std("Jack Jack");
	std.setName("Jack Jack 2");
	std::cout << std.getName() << std::endl;
	
	Teacher teacher1("Dr. H");
	teacher1.setName("Dr. K");
	
	std::cout << teacher1.getName() << std::endl;
	
	std::cout << std << std::endl;
	std::cout << teacher1 << std::endl;
	
	std.doNothing();
	teacher1.doNothing();
	
	std.study();
	teacher1.teach();
	
	// 자식클래스에 구현된걸 부모클래스에는 가져다 못쓴다!
	
	return 0;
}
```

### **🌱 **

### **🌱 **

### **🌱 **


# 😊 배우게 된 점

# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)