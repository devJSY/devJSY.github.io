---
published: true
title:  "따라하며 배우는 C++ Section 10. 객체를 사이의 관계에 대해"
excerpt: ""

categories:
  - 따배씨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-04-23 
last_modified_at: 2022-04-23
---

# 🤔 학습목표
- 따라하며 배우는 C++ Section 10. 객체를 사이의 관계에 대해

# 📃 학습내용
## 📍 **따라하며 배우는 C++ Section 10. 객체를 사이의 관계에 대해**

### **🌱 10.1 객체들의 관계**

- object Relationship

- 구성(요소) Composition
  - 관계를 표현하는 동사: Part-of
  - 예시: *두뇌*는 **육체**의 일부이다.
- 집합 Aggregation
  - 관계를 표현하는 동사: Has-a
  - 예시: 어떤 **사람**이 *자동차*를 가지고 있다.
  - 구성보단 조금 느슨한 연결 관계를 의미함
- 연계, 제휴 Association
  - 관계를 표현하는 동사: Uses-a
  - 예시: **환자**는 *의사*의 치료를 받는다, **의사**는 *환자들*로부터 치료비를 받는다.
  - 집합 보다 더 느슨함 서로 도움을 주고받음
- 의존 Dependency
  - 관계를 표현하는 동사: Depends-on
  - 예시: **나**는 (다리가 부러져서 한 달 동안) *목발*을 짚었다.
  - 연계, 제휴 보다 더 느슨함 의존관계임

**클래스** - 클래스
*멤버클래스* -  멤버클래스

___

- 구성(요소) Composition
  - 관계의 형태 : 전체/ 부품
  - 다른 클래스에도 속할 수 있는가? : No
  - 멤버의 존재를 클래스가 관리? : Yes
  - 방향성 : 단방향
- 집합 Aggregation
  - 관계의 형태 : 전체/ 부품
  - 다른 클래스에도 속할 수 있는가? : Yes
  - 멤버의 존재를 클래스가 관리? : No
  - 방향성 : 단방향
- 연계, 제휴 Association
  - 관계의 형태 : 용도 외엔 무관
  - 다른 클래스에도 속할 수 있는가? : Yes
  - 멤버의 존재를 클래스가 관리? : No
  - 방향성 : 단방향 or 양방향
- 의존 Dependency
  - 관계의 형태 : 용도 외엔 무관
  - 다른 클래스에도 속할 수 있는가? : Yes
  - 멤버의 존재를 클래스가 관리? : Yes
  - 방향성 : 단방향

### **🌱 10.2 구성 관계**

- 구성 관계 Composition

**기본 코드**

**main.cpp**

```cpp
//#include <iostream>
#include "Monster.h"

using namespace std;

int main()
{
	Monster mon1("Sanson", 0, 0);

	//while (1) // game loop
	{
		//event
		mon1.moveTo(1, 1);
		cout << mon1 << endl;
	}


	return 0;
}
```

**monster.h**

```cpp
#pragma once
#include <iostream>
#include <string>

class Monster
{
private:
	std::string m_name;
	int m_x; // location
	int m_y;

public:
	Monster(const std::string name_in, const int& x_in, const int& y_in)
		: m_name(name_in), m_x(x_in), m_y(y_in)
	{}

	void moveTo(const int& x_target, const int& y_target)
	{
		m_x = x_target;
		m_y = y_target;
	}

	friend std::ostream &operator << (std::ostream& out, const Monster& monster)
	{
		out << monster.m_name << " " << monster.m_x << " " << monster.m_y << std::endl;
		return out;
	}
};
```

- 몬스터의 이름과 위치를 출력해주는 코드
___

**location 분리하기**


**main.cpp**

```cpp
//#include <iostream>
#include "Monster.h"

using namespace std;

int main()
{
	Monster mon1("Sanson", Position2D(0, 0));

	cout << mon1 << endl; // Sanson 0 0

	//while (1) // game loop
	{
		//event
		mon1.moveTo(Position2D(1,1));
		cout << mon1 << endl; // Sanson 1 1
	}

	return 0;
}
```

**Monster.h**

```cpp
#pragma once

#include <string>
#include "Position2D.h"

class Monster
{
private:
	std::string m_name; // char, unsigned legth;
	Position2D m_location;
	//int m_x; // location
	//int m_y;

public:
	Monster(const std::string name_in, const Position2D & pos_in)
		: m_name(name_in), m_location(pos_in)
	{}

	void moveTo(const Position2D& pos_target)
	{
		m_location.set(pos_target);
		/*m_x = x_target;
		m_y = y_target;*/
	}

	friend std::ostream &operator << (std::ostream& out, const Monster& monster)
	{
		out << monster.m_name << " " << monster.m_location;
		return out;
	}
};
```

**Position2D.h**

```cpp
#pragma once

#include <iostream>

class Position2D
{
private:
	int m_x; 
	int m_y;

public:
	Position2D(const int& x_in, const int& y_in)
		: m_x(x_in), m_y(y_in)
	{}

	// TODO: overload operator =

	void set(const Position2D& pos_target)
	{
		set(pos_target.m_x, pos_target.m_y);
		// m_x = pos_target.m_x;
		// m_y = pos_target.m_y;
	}

	void set(const int& x_target, const int& y_target)
	{
		m_x = x_target;
		m_y = y_target;
	}

	friend std::ostream& operator << (std::ostream& out, const Position2D& pos2d)
	{
		out << pos2d.m_x << " " << pos2d.m_y;
		return out;
	}
};
```

- 이렇게 나눠두면 몬스터 클래스 이외에 워리어 클래스등 만들때도 `Position2D`를 사용할수 있음
  - 이런식으로 몬스터가 `Position2D`를 사용하는 관계를 컴포지션 이라고부름
  - `m_location`이 `Monster`의 일부이다
- 서브클래스는 가급적 빨리 쪼게기
- `set()` 함수와 같은 함수는 상위클래스에서는 그냥 가져다쓰고 어떤기능을할지는 안보이는것이 좋음
  - `Position2D` 내에서만 적용되는것이 좋음

___

- `Position2D`는 재사용을 목적으로 만든것이고 Monster class 내의` Position2D m_location;`  `m_location`은 `Monster` 고유의 것임
- Monster 클래스는 구성(요소) Composition 임





### **🌱 **

### **🌱 **

### **🌱 **

# 😊 배우게 된 점

# 📌참조링크
인프런 **따라하면서 배우는 C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)