---
published: true
title:  "ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 10. ê°ì²´ë¥¼ ì‚¬ì´ì˜ ê´€ê³„ì— ëŒ€í•´"
excerpt: ""

categories:
  - ë”°ë°°ì”¨++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2022-04-23 
last_modified_at: 2022-04-24
---

# ğŸ¤” í•™ìŠµëª©í‘œ
- ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 10. ê°ì²´ë¥¼ ì‚¬ì´ì˜ ê´€ê³„ì— ëŒ€í•´

# ğŸ“ƒ í•™ìŠµë‚´ìš©
## ğŸ“ **ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++ Section 10. ê°ì²´ë¥¼ ì‚¬ì´ì˜ ê´€ê³„ì— ëŒ€í•´**

### **ğŸŒ± 10.1 ê°ì²´ë“¤ì˜ ê´€ê³„**

- object Relationship

- êµ¬ì„±(ìš”ì†Œ) Composition
  - ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë™ì‚¬: Part-of
  - ì˜ˆì‹œ: *ë‘ë‡Œ*ëŠ” **ìœ¡ì²´**ì˜ ì¼ë¶€ì´ë‹¤.
- ì§‘í•© Aggregation
  - ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë™ì‚¬: Has-a
  - ì˜ˆì‹œ: ì–´ë–¤ **ì‚¬ëŒ**ì´ *ìë™ì°¨*ë¥¼ ê°€ì§€ê³  ìˆë‹¤.
  - êµ¬ì„±ë³´ë‹¨ ì¡°ê¸ˆ ëŠìŠ¨í•œ ì—°ê²° ê´€ê³„ë¥¼ ì˜ë¯¸í•¨
- ì—°ê³„, ì œíœ´ Association
  - ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë™ì‚¬: Uses-a
  - ì˜ˆì‹œ: **í™˜ì**ëŠ” *ì˜ì‚¬*ì˜ ì¹˜ë£Œë¥¼ ë°›ëŠ”ë‹¤, **ì˜ì‚¬**ëŠ” *í™˜ìë“¤*ë¡œë¶€í„° ì¹˜ë£Œë¹„ë¥¼ ë°›ëŠ”ë‹¤.
  - ì§‘í•© ë³´ë‹¤ ë” ëŠìŠ¨í•¨ ì„œë¡œ ë„ì›€ì„ ì£¼ê³ ë°›ìŒ
- ì˜ì¡´ Dependency
  - ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë™ì‚¬: Depends-on
  - ì˜ˆì‹œ: **ë‚˜**ëŠ” (ë‹¤ë¦¬ê°€ ë¶€ëŸ¬ì ¸ì„œ í•œ ë‹¬ ë™ì•ˆ) *ëª©ë°œ*ì„ ì§šì—ˆë‹¤.
  - ì—°ê³„, ì œíœ´ ë³´ë‹¤ ë” ëŠìŠ¨í•¨ ì˜ì¡´ê´€ê³„ì„

**í´ë˜ìŠ¤** - í´ë˜ìŠ¤
*ë©¤ë²„í´ë˜ìŠ¤* -  ë©¤ë²„í´ë˜ìŠ¤

___

- êµ¬ì„±(ìš”ì†Œ) Composition
  - ê´€ê³„ì˜ í˜•íƒœ : ì „ì²´/ ë¶€í’ˆ
  - ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ë„ ì†í•  ìˆ˜ ìˆëŠ”ê°€? : No
  - ë©¤ë²„ì˜ ì¡´ì¬ë¥¼ í´ë˜ìŠ¤ê°€ ê´€ë¦¬? : Yes
  - ë°©í–¥ì„± : ë‹¨ë°©í–¥
- ì§‘í•© Aggregation
  - ê´€ê³„ì˜ í˜•íƒœ : ì „ì²´/ ë¶€í’ˆ
  - ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ë„ ì†í•  ìˆ˜ ìˆëŠ”ê°€? : Yes
  - ë©¤ë²„ì˜ ì¡´ì¬ë¥¼ í´ë˜ìŠ¤ê°€ ê´€ë¦¬? : No
  - ë°©í–¥ì„± : ë‹¨ë°©í–¥
- ì—°ê³„, ì œíœ´ Association
  - ê´€ê³„ì˜ í˜•íƒœ : ìš©ë„ ì™¸ì—” ë¬´ê´€
  - ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ë„ ì†í•  ìˆ˜ ìˆëŠ”ê°€? : Yes
  - ë©¤ë²„ì˜ ì¡´ì¬ë¥¼ í´ë˜ìŠ¤ê°€ ê´€ë¦¬? : No
  - ë°©í–¥ì„± : ë‹¨ë°©í–¥ or ì–‘ë°©í–¥
- ì˜ì¡´ Dependency
  - ê´€ê³„ì˜ í˜•íƒœ : ìš©ë„ ì™¸ì—” ë¬´ê´€
  - ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ë„ ì†í•  ìˆ˜ ìˆëŠ”ê°€? : Yes
  - ë©¤ë²„ì˜ ì¡´ì¬ë¥¼ í´ë˜ìŠ¤ê°€ ê´€ë¦¬? : Yes
  - ë°©í–¥ì„± : ë‹¨ë°©í–¥

### **ğŸŒ± 10.2 êµ¬ì„± ê´€ê³„**

- êµ¬ì„± ê´€ê³„ Composition

**ê¸°ë³¸ ì½”ë“œ**

**main.cpp**

```cpp
//#include <iostream>
#include "Monster.h"

using namespace std;

int main()
{
	Monster mon1("Sanson", 0, 0);

	//while (1) // game loop
	{
		//event
		mon1.moveTo(1, 1);
		cout << mon1 << endl;
	}


	return 0;
}
```

**monster.h**

```cpp
#pragma once
#include <iostream>
#include <string>

class Monster
{
private:
	std::string m_name;
	int m_x; // location
	int m_y;

public:
	Monster(const std::string name_in, const int& x_in, const int& y_in)
		: m_name(name_in), m_x(x_in), m_y(y_in)
	{}

	void moveTo(const int& x_target, const int& y_target)
	{
		m_x = x_target;
		m_y = y_target;
	}

	friend std::ostream &operator << (std::ostream& out, const Monster& monster)
	{
		out << monster.m_name << " " << monster.m_x << " " << monster.m_y << std::endl;
		return out;
	}
};
```

- ëª¬ìŠ¤í„°ì˜ ì´ë¦„ê³¼ ìœ„ì¹˜ë¥¼ ì¶œë ¥í•´ì£¼ëŠ” ì½”ë“œ
___

**location ë¶„ë¦¬í•˜ê¸°**


**main.cpp**

```cpp
//#include <iostream>
#include "Monster.h"

using namespace std;

int main()
{
	Monster mon1("Sanson", Position2D(0, 0));

	cout << mon1 << endl; // Sanson 0 0

	//while (1) // game loop
	{
		//event
		mon1.moveTo(Position2D(1,1));
		cout << mon1 << endl; // Sanson 1 1
	}

	return 0;
}
```

**Monster.h**

```cpp
#pragma once

#include <string>
#include "Position2D.h"

class Monster
{
private:
	std::string m_name; // char, unsigned legth;
	Position2D m_location;
	//int m_x; // location
	//int m_y;

public:
	Monster(const std::string name_in, const Position2D & pos_in)
		: m_name(name_in), m_location(pos_in)
	{}

	void moveTo(const Position2D& pos_target)
	{
		m_location.set(pos_target);
		/*m_x = x_target;
		m_y = y_target;*/
	}

	friend std::ostream &operator << (std::ostream& out, const Monster& monster)
	{
		out << monster.m_name << " " << monster.m_location;
		return out;
	}
};
```

**Position2D.h**

```cpp
#pragma once

#include <iostream>

class Position2D
{
private:
	int m_x; 
	int m_y;

public:
	Position2D(const int& x_in, const int& y_in)
		: m_x(x_in), m_y(y_in)
	{}

	// TODO: overload operator =

	void set(const Position2D& pos_target)
	{
		set(pos_target.m_x, pos_target.m_y);
		// m_x = pos_target.m_x;
		// m_y = pos_target.m_y;
	}

	void set(const int& x_target, const int& y_target)
	{
		m_x = x_target;
		m_y = y_target;
	}

	friend std::ostream& operator << (std::ostream& out, const Position2D& pos2d)
	{
		out << pos2d.m_x << " " << pos2d.m_y;
		return out;
	}
};
```

- ì´ë ‡ê²Œ ë‚˜ëˆ ë‘ë©´ ëª¬ìŠ¤í„° í´ë˜ìŠ¤ ì´ì™¸ì— ì›Œë¦¬ì–´ í´ë˜ìŠ¤ë“± ë§Œë“¤ë•Œë„ `Position2D`ë¥¼ ì‚¬ìš©í• ìˆ˜ ìˆìŒ
  - ì´ëŸ°ì‹ìœ¼ë¡œ ëª¬ìŠ¤í„°ê°€ `Position2D`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê´€ê³„ë¥¼ ì»´í¬ì§€ì…˜ ì´ë¼ê³ ë¶€ë¦„
  - `m_location`ì´ `Monster`ì˜ ì¼ë¶€ì´ë‹¤
- ì„œë¸Œí´ë˜ìŠ¤ëŠ” ê°€ê¸‰ì  ë¹¨ë¦¬ ìª¼ê²Œê¸°
- `set()` í•¨ìˆ˜ì™€ ê°™ì€ í•¨ìˆ˜ëŠ” ìƒìœ„í´ë˜ìŠ¤ì—ì„œëŠ” ê·¸ëƒ¥ ê°€ì ¸ë‹¤ì“°ê³  ì–´ë–¤ê¸°ëŠ¥ì„í• ì§€ëŠ” ì•ˆë³´ì´ëŠ”ê²ƒì´ ì¢‹ìŒ
  - `Position2D` ë‚´ì—ì„œë§Œ ì ìš©ë˜ëŠ”ê²ƒì´ ì¢‹ìŒ

___

- `Position2D`ëŠ” ì¬ì‚¬ìš©ì„ ëª©ì ìœ¼ë¡œ ë§Œë“ ê²ƒì´ê³  Monster class ë‚´ì˜` Position2D m_location;`  `m_location`ì€ `Monster` ê³ ìœ ì˜ ê²ƒì„
- Monster í´ë˜ìŠ¤ëŠ” êµ¬ì„±(ìš”ì†Œ) Composition ì„


### **ğŸŒ± 10.3 ì§‘í•© ê´€ê³„**

- Association
- ì»´í¬ì§€ì…˜ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ë™ê¸°í™”ë¥¼ êµ¬í˜„í•´ì¤„ìˆ˜ë„ ìˆì§€ë§Œ ë¶ˆí¸í•¨
- for-each ë¬¸ ì‚¬ìš©ì‹œ &ì„ ì•ˆë¶™ì—¬ì£¼ë©´ ê°’ì´ ì—…ë°ì´íŠ¸ê°€ ì•ˆë¨
  - `for (auto & element: ë°°ì—´)`

ì½”ë“œ êµ¬ì¡° ì„¤ëª…
- Lecture í´ë˜ìŠ¤
  - string m_name : ê°•ì˜ ì´ë¦„
  - Teacher teacher : ê°•ì˜ ë‹´ë‹¹ êµì‚¬ ê°ì²´
  - std::vector<Student> students : ìˆ˜ê°•í•˜ëŠ” í•™ìƒë“¤ ê°ì²´ ë²¡í„°

- ê°ê°ì˜ ì»´í¬ì§€ì…˜ìœ¼ë¡œ ê°–ê³ ìˆìœ¼ë©´ ê°ê° ì£¼ì†Œê°€ ë‹¤ë¥´ê¸°ë•Œë¬¸ì— ê°’ì„ ì—…ë°ì´íŠ¸í• ë•Œ ë™ê¸°í™” í•˜ëŠ” ë“±ì˜ ë¶ˆí¸í•¨ì´ ìˆê¸°ë•Œë¬¸ì— í¬ì¸í„°ë“±ìœ¼ë¡œ ë°›ì•„ì™€ì„œ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ë²•ì´ ìˆë‹¤.
- ë¶„ì‚°ì²˜ë¦¬ í• ë•ŒëŠ” Associationì„ í•´ì•¼í•¨ìœ¼ë¡œ ë™ê¸°í™”ê°€ í•„ìš”í•¨

___

- Lecture í´ë˜ìŠ¤
  - *ë©¤ë²„*
    - string m_name : ê°•ì˜ ì´ë¦„
    - **Teacher teacher** : ê°•ì˜ ë‹´ë‹¹ êµì‚¬ ê°ì²´
    - **std::vector\<Student> students** : ìˆ˜ê°•í•˜ëŠ” í•™ìƒë“¤ ê°ì²´ ë²¡í„°

<br>

**Student.h**

```cpp
#pragma once

#include <iostream>
#include <string>

class Student
{
private:
	std::string m_name;
	int m_intel; 

public:
	Student(const std::string & name_in = "No Name", const int & intel_in = 0)
		: m_name(name_in), m_intel(intel_in)
	{}

	void setName(const std::string & name_in)
	{
		m_name = name_in;

	}

	void setIntel(const int & intel_in)
	{
		m_intel = intel_in;
	}

	int getIntel()
	{
		return m_intel;
	}

	friend std::ostream & operaotr << (std::ostream & out, const Student & student)
	{
		out << student.m_name << " " << student.m_intel;
		return out;
	}
};
```

- *ë©¤ë²„*
  - string m_name : í•™ìƒ ì´ë¦„
  - **int m_intel** : í•™ìƒ ì§€ëŠ¥

<br>

**Teacher.h**

```cpp
#pragma once

#include <string>

class Teacher
{
private:
	std::string m_name;

public:
    Teacher()
    {}

	Teacher(const std::string & name_in)
		: m_name(name_in)
	{}

	void setName(const std::string & name_in)
	{
		m_name = name_in;
	}

	std::string getName()
	{
		return m_name;
	}

	friend std::ostream & operaotr << (std::ostream & out, const Teacher & teacher)
	{
		out << teacher.m_name;
		return out;
	}
};
```

- *ë©¤ë²„*
  - string m_name : êµì‚¬ ì´ë¦„

<br>

**Lecture.h**

```cpp
#pragma once

#include <vector>
#include "Student.h"
#include "Teacher.h"

class Lecture
{
private:
	std::string m_name;

	Teacher teacher;
	std::vector<Student> students; 

public:
	Lecture(const std::string & name_in)
		: m_name(name_in)
	{}

	void assignTeacher(const Teacher & const teacher_input)
	{
		teacher = teacher_input;
	}

	void registerStudent(const Student & const student_input)
	{
		students.push_back(student_input);
	}

	void study()
	{
		std::cout << m_name << " Study " << std::endl;

		for (auto & element : students)
			element.setIntel(element.getIntel() + 1);
	}

	friend std::ostream & operator << (std::ostream & out, const Lecture & lecture)
	{
		out << "Lecture name: " << lecture.m_name << std::endl;

		out << lecture.teacher << std::endl;
		for (auto element : lecture.students)
			out << element << std::endl;

     return out;
	}
};
```

```cpp
class Lecture
{
private:
	std::string m_name;

	Teacher teacher;
	std::vector<Student> students; 
```

<br>

**ì˜ˆì‹œ 1**

**main.cpp**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include "Lecture.h"

int main()
{
	using namespace std;

	//composition relationship
	Lecture lec1("C++");
	lec1.assignTeacher(Teacher("Prof. Hong"));
	lec1.registerStudent(Student("Jack Jack", 0));
	lec1.registerStudent(Student("Dash, 1"));
	lec1.registerStudent(Student("Violet", 2));

	Lecture lec2("Java");
	lec2.assignTeacher(Teacher("Prof. Good"));
	lec2.registerStudent(Student("Jack Jack", 0));

	{
		cout << lec1 << endl;
		cout << lec2 << endl;

		lec2.study();

		cout << lec1 << endl;
		cout << lec2 << endl;
	}

	return 0;
}
```

**ì˜ˆì‹œ 2**

**main.cpp**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include "Lecture.h"

int main()
{
	using namespace std;

    Student std1("Jack Jack", 0);
	Student std2("Dash", 1);
	Student std3("Violet", 2);

	Teacher teacher1("Prof. Hong");
	Teacher teacher2("Prof. Good");

	//composition relationship
	Lecture lec1("C++");
	lec1.assignTeacher(teacher1);
	lec1.registerStudent(std1);
	lec1.registerStudent(std2);
	lec1.registerStudent(std3);

	Lecture lec2("Java");
	lec2.assignTeacher(teacher2);
	lec2.registerStudent(std1);

	{
		cout << lec1 << endl;
		cout << lec2 << endl;

		lec2.study();

		cout << lec1 << endl;
		cout << lec2 << endl;
	}

	return 0;
}
```

**ì§‘í•© ê´€ê³„ : í¬ì¸í„° ì‚¬ìš©í•˜ê¸°**

ì§‘í•© ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì½”ë“œ

**Lecture.h**

```cpp
#include <vector>
#include "Student.h"
#include "Teacher.h"

class Lecture
{
private:
	std::string m_name;

	Teacher *teacher;
	std::vector<Student*> students;

public:
	Lecture(const std::string & name_in)
		: m_name(name_in)
	{}

	~Lecture()
	{
		delete teacher;
		cout << "delete teacher" << endl;
		
		for (auto & element : students)
		{
		    delete element;
		}
		cout << "delete students" << endl;
	}

	void assignTeacher(Teacher * const teacher_input)
	{
		teacher = teacher_input;
	}

	void registerStudent(Student * const student_input)
	{
		students.push_back(student_input);
	}

	void study()
	{
		std::cout << m_name << "Study " << std::endl << std::endl;

		for (auto element : students)
			(*element).setIntel((*element).getIntel() + 1);
	}

	friend std::ostream & operator << (std::ostream & out, const Lecture & lecture)
	{
		out << "Lecture name: " << lecture.m_name << std::endl;

		out << lecture.teacher << std::endl;
		for (auto element : lecture.students)
			out << *element << std::endl;

     return out;
	}
};
```

**main.cpp**

```cpp
#include <iostream>
#include <vector>
#include <string>
#include "Lecture.h"

int main()
{
	using namespace std;

	// ê°™ì€ í•™ìƒì´ë‚˜ êµìˆ˜ë¥¼ ì¬ìƒì„±í•˜ì§€ ì•Šë„ë¡ 
	Student *std1 = new Student("Jack Jack", 0);
	Student *std2 = new Student("Dash", 1);
	Student *std3 = new Student("Violet", 2);

	Teacher *teacher1 = new Teacher("Prof. Hong");
	Teacher *teacher2 = new Teacher("Prof. Good");

	{
		cout << lec1 << endl;
		cout << lec2 << endl;

		//event
		lec2.study();

		cout << lec1 << endl;
		cout << lec2 << endl;
	}
}
```

### **ğŸŒ± 10.4 ì œíœ´ ê´€ê³„**

- Association

- ì „ë°© ì„ ì–¸ì´ í•„ìš”í•¨
- ì• ë‘ ê´€ê³„ì— ë¹„í•´ ëœ ì‚¬ìš©í•¨
- ì„œë¡œê°€ ë‚´ë¶€ì˜ ìƒëŒ€ë°©ì„ ë©¤ë²„ë¡œì¨ ê°–ê³ ìˆëŠ” í˜•íƒœ
  - í•œìª½ì—ì„  ì „ë°©ì„ ì–¸ì„í•˜ê±°ë‚˜ í•¨ìˆ˜ë¥¼ ì•„ë˜ë¡œ ë¹¼ê±°ë‚˜ í•´ì•¼í•¨

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Doctor; // ì „ë°© ì„ ì–¸

class Patient
{
private:
	string m_name;
	vector<Doctor*> m_doctors;  // ì´ í™˜ìê°€ ì œíœ´í•˜ëŠ” ì˜ì‚¬ë“¤

public:
	Patient(string name_in)
		: m_name(name_in)
	{}

	void addDoctor(Doctor * new_doctor)  // ì œíœ´í•˜ëŠ” ì˜ì‚¬ ì¶”ê°€
	{
		m_doctors.push_back(new_doctor);  
	}

	void meetDoctors()  // ì œíœ´í•˜ëŠ” ì˜ì‚¬ë“¤ ì¶œë ¥
	{
		for (auto & ele : m_doctors)
		{
			cout << "Meet doctor : " << ele->m_name << endl;
		}
	}

	friend class Doctor;
};


class Doctor
{
private:
	string m_name;
	vector<Patient*> m_patients;  // ì´ ì˜ì‚¬ê°€ ì œíœ´í•˜ëŠ” í™˜ìë“¤ 

public:
	Doctor(string name_in)
		: m_name(name_in)
	{}

	void addPatient(Patient * new_patient)  // ì œíœ´í•˜ëŠ” í™˜ìë“¤ ì¶”ê°€
	{
		m_patients.push_back(new_patient);
	}

	void meetPatients()  // ì œíœ´í•˜ëŠ” í™˜ìë“¤ ì¶œë ¥
	{
		for (auto & ele : m_patients)
		{
			cout << "Meet patient : " << ele->m_name << endl;
		}
	}

	friend class Patient; 
};


int main()
{
	Patient *p1 = new Patient("Jack Jack");
	Patient *p2 = new Patient("Dash");
	Patient *p3 = new Patient("Violet");

	Doctor *d1 = new Doctor("Doctor K");
	Doctor *d2 = new Doctor("Doctor L");

	p1->addDoctor(d1);
	d1->addPatient(p1);

	p2->addDoctor(d2);
	d2->addPatient(p2);

	p2->addDoctor(d1);
	d1->addPatient(p2);

	//patients meet doctors
	p1->meetDoctors(); 

	//doctors meet patients
	d1->meetPatients();

	//delets
	delete p1;
	delete p2;
	delete p3;

	delete d1;
	delete d2;

	return 0;

}
```

### **ğŸŒ± 10.5 ì˜ì¡´ ê´€ê³„**

- Denpendencies
- ì„ ì–¸êµ¬ê°„ì—ì„  includeê°€ í•„ìš”ì—†ê³  êµ¬í˜„êµ¬ê°„ì—ì„œë§Œ include í•´ì£¼ë©´ ë¨



**Timer.h**

```cpp
#pragma once

#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

class Timer
{
	using clock_t = std::chrono::high_resolution_clock;
	using second_t = std::chrono::duration<double, std::ratio<1>>;

	std::chrono::time_point<clock_t> start_time = clock_t::now();

public:
	void elapsed()
	{
		std::chrono::time_point<clock_t> end_time = clock_t::now();

		std::cout << std::chrono::duration_cast<second_t>(end_time - start_time).count() << std::endl;
	}
};
```

**Worker.h**

```cpp
#pragma once

class Worker
{
public:
	void doSomething();  // êµ¬í˜„ì€ Worker.cpp ì—ì„œ
};
```

**Worker.cpp**

```cpp
#pragma once

#include "Worker.h"
#include "Timer.h"

void Worker::doSomething()
{
	Timer timer; // start timer

	// ì‹¤í–‰ ì‹œê°„ ì´ ëŒ€ìƒì´ ë˜ëŠ” ì½”ë“œ ë„£ê¸°

	timer.elapsed(); // end timer and report elapsed time
}
```

**Main.cpp**

```cpp
#include "Worker.h"

using namespace std;

int main()
{
	Worker().doSomething();

	return 0;
}
```


### **ğŸŒ± 10.6 ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤**

- Container Classes
- ìŠ¤íƒ ë‹¤ë“œ í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬ - ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤
- ì•„ë˜ì˜ ì»¨í…Œì´ë„ˆ í´ë˜ìŠ¤ë¥¼ ì§ì ‘ êµ¬í˜„í•´ ë³´ê¸°

```cpp
#include <iostream>
#include <vector>
#include <array>

using namespace std;

class IntArray
{
private:
	int m_length = 0;
	int* m_data = nullptr;

public:
	// Constructors
	// Destructors
	// initalize()
	// reset();
	// resize();
	// insertBefore(const int & value, const int & ix);
	// remove (const int & ix);
	// push_back (const int & value);
};

int main()
{
	// IntArray my_arr{1,3,5,7,9};
	// my_arr.insertBefore(10,1);		// 1,10,3,5,7,9
	// my_arr.remove(3);				// 1,10,3,7,9
	// my_arr.push_back(13);			// 1,10,3,7,9,13

	std::vector<int> int_vec;
	std::array<int, 10> int_array;

	return 0;
}
```

# ğŸ“Œì°¸ì¡°ë§í¬
ì¸í”„ëŸ° **ë”°ë¼í•˜ë©´ì„œ ë°°ìš°ëŠ” C++** - [https://www.inflearn.com/course/following-c-plus](https://www.inflearn.com/course/following-c-plus)

**ê³µë¶€í•˜ëŠ” ì‹ë¹µë§˜ ğŸ‘±â€â™€ï¸ ë‹˜ì˜ ë¸”ë¡œê·¸** - [https://ansohxxn.github.io/](https://ansohxxn.github.io/)